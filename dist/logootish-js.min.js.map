{"version":3,"sources":["webpack://logootish-js/webpack/universalModuleDefinition","webpack://logootish-js/webpack/bootstrap","webpack://logootish-js/./src/utils.ts","webpack://logootish-js/./src/index.ts","webpack://logootish-js/./src/listmodel/index.ts","webpack://logootish-js/./src/bst.ts","webpack://logootish-js/./src/listmodel/logoot.ts","webpack://logootish-js/./src/ints.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","arraymap","array","fn","length","newarray","splice","FatalError","Error","fatal","Comparable","cmp","allKeys","obj","keys","concat","getOwnPropertySymbols","MemberPtr","val","allValues","map","k","BreakException","catchBreak","e","EventState","ListDocumentModel","LogootInt","LogootPosition","NodeType","InsertionConflictError","MinimalJoinFunction","a","b","branches","filter","br","branch","jf","ldoc_bst","Bst","known_position","logoot_bst","start","clock","canJoin","range_search","create_range_search","lesser_find_greatest","greater_find_least","push_point","all_greater","_lesser","_greater","search","lesser","greater","before_position","after_position","sort","logoot_start","lesser_length","ldoc_length","last_branch","first_branch","logoot_end","undefined","remaining_length","branch_order","indexOf","branchLength","slice","most_lesser","groups","end","inverseOffsetLowest","rclk","_range","nodes","ldoc_end","unshift","removal_sets","forEach","cg","group","rlen","type","DATA","offsetLowest","len","branch_removals","levels","depth_removals","last_removal","push","onRemoval","Math","min","removals","branch_set","entries","depth_set","nstart","nrclk","level","nend","assign","_skip_ranges","skip_ranges","includes","lesser_end","splitAround","copy","sub","js_int","vgroup","LogootNodeGroup","conflict_order","original_known_end","operations","known_position_shift","applyShift","ic","lstart","insert","offset","translate","source","dest","splitCg","ng","ncg","ConflictGroup","known_end","excerpt_length","origin","moved_length","add","joinCg","lcg","fetch_position","next_length","remove","other","last_start","last_group","next_group","group_level_start","clamp","group_level_end","empty_length","empty_offset","newgroup","last_join","next_join","already_joined","insertSingleBranchGroup","group_length","group_offset","insertPos","fixJoined","joined","should_join","conflicted","conflicting","mark","operateOnAllGteq","data","_mergeNode","REMOVAL","BstNode","RangeSearch","cf","points","pd","bucket","last_bucket","inclusive","point","current","clear_buckets","traverse_left","left","passed_bucket","right","Boolean","range_buckets","el","bst_root","node","gteqcmp","getBucketInfo","successor","setSuccessor","gtcmp","eqcmp","ptr","_getInorderSuccessor","result","should_remove","endm1","operation","undef","operateOnAllRange","operateOnAllLteq","operateOnAll","str","toString","split","join","Int32","done","itstart","values","itend","next","gteq","eventnode","pos","fromJSON","ints","toJSON","Array","fill","max","preserve_levels","clamped","equivalentPositionAtLevel","JSON","Schema","items","nt_string","position","reduce","some","g","at","n_branches","TypeError","getNeighbors","gr","old","eachNode","cb","rval","String","IntType","super","int32","Int32Array"],"mappings":"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","file":"logootish-js.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"logootish-js\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"logootish-js\"] = factory();\n\telse\n\t\troot[\"logootish-js\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\n * @file Various utilities that don't belong anywhere else.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n\n/**\n * Like the built-in map function, but it replaces the element with an arbitrary\n * number of elements, making it a combination of map, push, and filter.\n * @template T - The type of the array elements.\n * @param array - The array to map. It will be modified.\n * @param fn - The element mapper function. It takes the current element as an\n * argument and returns the element(s) take its place.\n * @return The same array that was passed as an argument.\n */\nfunction arraymap<T>(array: T[], fn: (el: T) => T[]): T[] {\n  for (let i = 0; i < array.length; ) {\n    const newarray = fn(array[i])\n    array.splice(i, 1, ...newarray)\n    i += newarray.length ? newarray.length : 1\n  }\n  return array\n}\n\n/**\n * A class created with a variable `fatal` added and set to true. This is used\n * for ensuring that a client knows to shut down a document if an error has\n * indicated that the document is corrupt.\n */\nclass FatalError extends Error {\n  fatal = true\n}\n\n/**\n * One of zero, one, or negative one.\n */\ntype CompareResult = -1 | 0 | 1\n/**\n * A function type that takes `T` and returns a CompareResult.\n */\ntype CompareFunction<T> = (other: T) => CompareResult\n/**\n * A function type that takes two of a type `T` and returns a CompareResult.\n */\ntype DualCompareFunction<T> = (a: T, b: T) => CompareResult\n\n/**\n * A utility abstract class with no implementation for the function `cmp` and\n * implementations for `gt`, `gteq`, `eq`, `lteq`, and `lt` functions.\n * @template T The other type that can be compared.\n */\nabstract class Comparable<T> {\n  /**\n   * Compare this object to another one.\n   */\n  abstract cmp(other: T): CompareResult\n  /**\n   * @return True if this object is greater than the one provided.\n   */\n  gt(n: T): boolean {\n    return this.cmp(n) === 1\n  }\n  /**\n   * @return True if this object is greater than or equal to the one provided.\n   */\n  gteq(n: T): boolean {\n    return this.cmp(n) >= 0\n  }\n  /**\n   * @return True if this object is equal to the one provided.\n   */\n  eq(n: T): boolean {\n    return this.cmp(n) === 0\n  }\n  /**\n   * @return True if this object is less than or equal to the one provided.\n   */\n  lteq(n: T): boolean {\n    return this.cmp(n) <= 0\n  }\n  /**\n   * @return True if this object is less than the one provided.\n   */\n  lt(n: T): boolean {\n    return this.cmp(n) === -1\n  }\n}\n\n/**\n * Designed to emulate pointers to members of an object. This is useful inside\n * the B-trees. This should not be used like a C pointer: If the value in the\n * destination object changes, so does the value reported by this object.\n * @template T - The container object type.\n * @template K - The key inside the object.\n */\nclass MemberPtr<T, K extends keyof T> {\n  private obj: T\n  private key: K\n  /**\n   * @param obj - The object with the member to reference.\n   * @param key - The key of the reference inside the object.\n   */\n  constructor(obj: T, key: K) {\n    this.obj = obj\n    this.key = key\n  }\n  /**\n   * The value of the 'pointer.'\n   */\n  get value(): T[K] {\n    return this.obj[this.key]\n  }\n  set value(val: T[K]) {\n    this.obj[this.key] = val\n  }\n}\n\nfunction allKeys<T, K extends keyof T>(obj: T): K[] {\n  return (Object.keys(obj) as K[]).concat(\n    Object.getOwnPropertySymbols(obj) as K[]\n  )\n}\n\nfunction allValues<T, V extends T[keyof T]>(obj: T): V[] {\n  return allKeys(obj).map((k) => obj[k]) as V[]\n}\n\nconst BreakException = {}\nfunction catchBreak(fn: () => void): void {\n  try {\n    fn()\n  } catch (e) {\n    if (e !== BreakException) {\n      throw e\n    }\n  }\n}\n\nexport {\n  arraymap,\n  FatalError,\n  CompareResult,\n  CompareFunction,\n  DualCompareFunction,\n  Comparable,\n  MemberPtr,\n  allKeys,\n  allValues,\n  BreakException,\n  catchBreak\n}\n","/**\n * @file This file imports the ListDocumentModel and defines event handling\n * systems.\n * @TODO Move event abstraction layer here\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport {\n  ListDocumentModel,\n  LogootInt,\n  LogootPosition,\n  NodeType\n} from './listmodel'\n\nenum EventState {\n  /**\n   * Not being actively sent and can be modified.\n   */\n  PENDING,\n  /**\n   * In transit. Cannot be modified.\n   */\n  SENDING,\n  /**\n   * Already sent. Also cannot be modified.\n   */\n  COMPLETE\n}\n\n/**\n * Generic event interface.\n */\ninterface LogootishEvent {\n  state: EventState\n  readonly type: string\n  // eslint-disable-next-line\n  toJSON(): any\n}\n\nexport { EventState, ListDocumentModel, LogootInt, LogootPosition, NodeType }\n","/**\n * @file This file contains the bulky position manipulation logic for any list-\n * based CRDT (arrays, text, rich text, etc.)\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport {\n  FatalError,\n  CompareResult,\n  allValues,\n  BreakException,\n  catchBreak\n} from '../utils'\nimport { Bst } from '../bst'\n\nimport {\n  LogootInt,\n  LogootPosition,\n  NodeType,\n  ConflictGroup,\n  LogootNodeGroup,\n  BranchKey\n} from './logoot'\n\ntype KnownPositionBst = Bst<ConflictGroup, { known_position: number }>\ntype LogootBst = Bst<LogootNodeGroup, { start: LogootPosition }>\n\n/**\n * A Logoot removal.\n */\ntype Removal = {\n  branch: BranchKey\n  start: LogootPosition\n  length: number\n  rclk: LogootInt\n}\n\ntype RemovalOperation = {\n  type: 'r'\n  start: number\n  length: number\n}\ntype InsertionOperation = {\n  type: 'i'\n  start: number\n  offset: number\n  length: number\n}\ntype TranslationOperation = {\n  type: 't'\n  source: number\n  length: number\n  dest: number\n}\ntype MarkOperation = {\n  type: 'm'\n  start: number\n  length: number\n  conflicting: boolean\n}\n/**\n * An operation returned by `_mergeNode` to be run on the local document.\n */\ntype Operation =\n  | RemovalOperation\n  | InsertionOperation\n  | TranslationOperation\n  | MarkOperation\n\n/**\n * An error thrown when an insertion is attempted at the boundary between two\n * branches that are not the one in the active document.\n */\nclass InsertionConflictError extends Error {}\n\n/**\n * A function that determines if two `LogootNodeGroup`s should be in the same\n * `ConflictGroup`. The two arguments must be in order.\n * @param a - The first `LogootNodeGroup`\n * @param b - The second `LogootNodeGroup`\n * @returns True if the two groups can be joined.\n */\ntype JoinFunction = (a: LogootNodeGroup, b: LogootNodeGroup) => boolean\n/**\n * A `JoinFunction` that joins two nodes if they have the same branches that are\n * in conflict.\n */\nconst MinimalJoinFunction = (\n  a: LogootNodeGroup,\n  b: LogootNodeGroup\n): boolean => {\n  if (a.branches.filter((br) => !b.br(br)).length) {\n    return false\n  }\n  if (b.branches.filter((br) => !a.br(br)).length) {\n    return false\n  }\n  return true\n}\n\n/**\n * A representation of the Logootish Document Model for mapping \"real,\"\n * continuous `known_position`s to Logoot positions. This is useful when working\n * with strings, arrays, or, just in general, anything that needs a fixed order.\n * This does not actually store the data in question, but stores a mapping of\n * real indices in the data to the Logoot positions of that element. This is\n * used to transform edits between ones in the Logoot and local position spaces.\n * One important thing to note: Logoot edits (insertions/removals) can be\n * applied in any order. Local edits **must** be applied in a consistent order.\n * @TODO Conflict resolution does not exist. **This will create significant\n * changes to this API**\n */\nclass ListDocumentModel {\n  /**\n   * The BST maps out where all insertion nodes are in the local document's\n   * memory. It is used to go from position -> node\n   */\n  ldoc_bst: KnownPositionBst = new Bst(\n    (a, b) => (a.known_position - b.known_position) as CompareResult\n  )\n  /**\n   * This BST maps Logoot position identifiers to their text node to allow\n   * lookup of text position from Logoot ID\n   */\n  logoot_bst: LogootBst = new Bst((a, b) => a.start.cmp(b.start))\n  /** A map of removals that do not yet have text to remove */\n  // removal_bst: LogootBst = new Bst((a, b) => a.start.cmp(b.start))\n  /**\n   * This is a Lamport clock. A proper vector clock would have too many entries\n   * for large, multi-user documents.\n   * See the Logoot paper for why. Unlike the Logoot implementation, this is\n   * incremented with each removal only and is kept constant with insertions.\n   */\n  clock = new LogootInt()\n  branch: BranchKey\n\n  canJoin: JoinFunction\n\n  constructor(branch: BranchKey, jf: JoinFunction = MinimalJoinFunction) {\n    this.branch = branch\n    this.canJoin = jf\n  }\n\n  /**\n   * The goal of this method is to find the Logoot position corresponding to a\n   * particular local position. Unlike the old version, this does **not**\n   * actually record the insertion. The output of this must be passed in to\n   * `insertLogoot` for that to happen. This provides greater flexibility for\n   * the programmer. All insertions will be determined on the `branch` variable\n   * of this class. This means that if this funcion is called and the start\n   * position is in between two atoms, the first on `branch` and the second not,\n   * the resulting order will leave the new atom after the first atom, but *not\n   * necessarily* after the second atom since conflicts allow atoms to appear\n   * out of their Logoot order. However, if an insertion is attempted between\n   * two atoms on branches that are not `branch`, then it will not be possible\n   * to determine where the resulting node should go. A `InsertionConflictError`\n   * will be thrown. UI should respond to this by informing the user to resolve\n   * the conflict first.\n   * @param start - The position of the insertion\n   * @param length - The length of the insertion\n   * @returns An object containing `start` (a LogootPosition), `length`, `br`\n   * (just `this.branch`), and `rclk` (just `this.clock`). The `start` value is\n   * the only one that is actually calculated. The others are returned for\n   * convenience.\n   */\n  insertLocal(\n    start: number,\n    length: number\n  ): {\n    start: LogootPosition\n    length: number\n    br: BranchKey\n    rclk: LogootInt\n  } {\n    // Search:\n    // n < start   -> _lesser\n    // start <= n  -> _greater\n    const range_search = this.ldoc_bst.create_range_search()\n    range_search.lesser_find_greatest = true\n    range_search.greater_find_least = true\n    range_search.push_point({ known_position: start }, '_lesser', false)\n    range_search.all_greater('_greater')\n    const { _lesser, _greater } = this.ldoc_bst.search(range_search)\n\n    let lesser: ConflictGroup\n    let greater: ConflictGroup\n    if (_lesser && _lesser.length) {\n      // The earliest one will not be a only a removal if nodes are ordered\n      // properly. We can ignore the removals in between\n      lesser = _lesser.sort((a, b) => a.logoot_start.cmp(b.logoot_start))[0]\n    }\n    if (_greater && _greater.length) {\n      // Now grab the last element...\n      greater = _greater.sort((a, b) => b.logoot_start.cmp(a.logoot_start))[0]\n    }\n\n    let before_position\n    let after_position\n\n    const lesser_length = lesser ? lesser.ldoc_length : 0\n    if (lesser && lesser.known_position + lesser_length === start) {\n      if (\n        greater &&\n        lesser.last_branch === greater.first_branch &&\n        lesser.last_branch !== this.branch\n      ) {\n        throw new InsertionConflictError()\n      }\n      before_position = lesser.logoot_end\n      after_position = greater ? greater.logoot_start : undefined\n    } else if (lesser) {\n      ;((): void => {\n        let remaining_length = start - lesser.known_position\n        if (lesser.branch_order.indexOf(this.branch) < 0) {\n          remaining_length -= lesser.ldoc_length\n        } else {\n          remaining_length -= lesser.branchLength(\n            lesser.branch_order.slice(\n              0,\n              lesser.branch_order.indexOf(this.branch)\n            )\n          )\n        }\n        if (remaining_length < 0) {\n          throw new FatalError('Search returned out of order nodes')\n        }\n        if (remaining_length === 0) {\n          // We're at the left end here, so we have to look up *another* lesser\n          // Search:\n          // n < lesser.known_position   -> _lesser\n          // lesser.known_position <= n  -x\n          const range_search = this.ldoc_bst.create_range_search()\n          range_search.lesser_find_greatest = true\n          range_search.push_point(\n            { known_position: lesser.known_position },\n            '_lesser',\n            false\n          )\n          const { _lesser } = this.ldoc_bst.search(range_search)\n\n          let most_lesser\n          if (_lesser && _lesser.length) {\n            most_lesser = _lesser.sort((a, b) =>\n              a.logoot_start.cmp(b.logoot_start)\n            )[0]\n          }\n          // Now, go in between the two nodes just as we would've above\n          before_position = most_lesser.logoot_end\n          after_position = lesser.logoot_start\n          return\n        }\n\n        // So, we're not at the start. Find a good position\n        for (let i = 0; i < lesser.groups.length; i++) {\n          const { end } = lesser.groups[i]\n          remaining_length -= lesser.groups[i].branchLength([this.branch])\n\n          if (remaining_length < 0) {\n            before_position = after_position = end.inverseOffsetLowest(\n              -remaining_length\n            )\n            return\n          } else if (remaining_length === 0) {\n            before_position = end\n            after_position = lesser.groups[i + 1]\n              ? lesser.groups[i + 1].start\n              : greater\n              ? greater.logoot_start\n              : undefined\n            return\n          }\n        }\n        // We must be in between two branches that are not ours\n        throw new InsertionConflictError()\n      })()\n    } else if (greater) {\n      after_position = greater.logoot_start\n    }\n\n    return {\n      start: new LogootPosition(length, before_position, after_position),\n      length,\n      br: this.branch,\n      rclk: this.clock\n    }\n  }\n\n  /**\n   * Finds the sets of Logoot positions in a certain real text range. This is\n   * used to find the removal operations to perform, but it does **not**\n   * actually record the updates, just like `insertLocal`.\n   * @param start - The position to start removing, inclusive.\n   * @param length - The length of the removal\n   * @returns - An object containing an array of `removals`. Each removal has a\n   * `start` LogootPosition, a numeric `length`, a `branch` (which is a\n   * BranchKey), and a `rclk` vector clock value.\n   */\n  removeLocal(start: number, length: number): { removals: Removal[] } {\n    // Search:\n    // n < start   -> _lesser\n    // start <= n  -> _greater\n    const range_search = this.ldoc_bst.create_range_search()\n    range_search.lesser_find_greatest = true\n    range_search.greater_find_least = true\n    range_search.push_point({ known_position: start }, '_lesser', false)\n    range_search.push_point({ known_position: start + length }, '_range', false)\n    range_search.all_greater(undefined)\n    const { _lesser, _range } = this.ldoc_bst.search(range_search)\n\n    const nodes = _range || []\n    if (_lesser && _lesser.length) {\n      // The earliest one will not be a only a removal if nodes are ordered\n      // properly. We can ignore the removals in between\n      const l = _lesser.sort((a, b) => a.logoot_start.cmp(b.logoot_start))[0]\n      if (l.ldoc_end > start) {\n        nodes.unshift(l)\n      }\n    }\n\n    const removal_sets: { [key: string]: { [key: number]: Removal[] } } = {}\n    function onRemoval(\n      br: BranchKey,\n      start: LogootPosition,\n      len: number,\n      rclk: LogootInt\n    ): void {\n      if (len <= 0) {\n        return\n      }\n      if (!removal_sets[(br as unknown) as string]) {\n        removal_sets[(br as unknown) as string] = {}\n      }\n      const branch_removals = removal_sets[(br as unknown) as string]\n\n      if (!branch_removals[start.levels]) {\n        branch_removals[start.levels] = []\n      }\n      const depth_removals = branch_removals[start.levels]\n      const last_removal = depth_removals[depth_removals.length - 1]\n\n      if (\n        last_removal &&\n        last_removal.branch === br &&\n        last_removal.start.offsetLowest(last_removal.length).cmp(start) === 0 &&\n        last_removal.rclk.cmp(rclk) === 0\n      ) {\n        last_removal.length += len\n      } else {\n        depth_removals.push({ branch: br, start, length: len, rclk })\n      }\n    }\n\n    let remaining_length = start + length - nodes[0].known_position\n    // TODO: This is *really* inefficient for obvious reasons\n    catchBreak(() =>\n      nodes.forEach((cg) => {\n        cg.branch_order.forEach((br) => {\n          cg.groups.forEach((group) => {\n            if (!group.br(br)) {\n              return\n            }\n            let { start, length: rlen } = group\n            const { type, rclk } = group.br(br)\n\n            if (type === NodeType.DATA) {\n              if (remaining_length > length) {\n                start = start.offsetLowest(remaining_length - length)\n                rlen -= remaining_length - length\n              }\n              onRemoval(br, start, Math.min(rlen, remaining_length), rclk)\n              remaining_length -= group.length\n            }\n            if (remaining_length <= 0) {\n              throw BreakException\n            }\n          })\n        })\n      })\n    )\n\n    const removals: Removal[] = []\n    allValues(removal_sets).forEach((branch_set) => {\n      Object.entries(branch_set).forEach(([, depth_set]) => {\n        depth_set.forEach((o) => removals.push(o))\n      })\n    })\n\n    return { removals }\n  }\n\n  /**\n   * This is the most important method in the `ListDocumentModel`. This method\n   * adds atoms to the BSTs. By consequence, it replaces nodes and generates\n   * conflicts as necessary to add the node to the BST. **Users should never\n   * call this function directly.**\n   * @param br - The branch to insert on\n   * @param nstart - The start Logoot position of the insertion\n   * @param length - The length of the insertion\n   * @param nrclk - The clock value for the insertion\n   * @param type - The type of node to add. Anything other than data will result\n   * in data being removed if it conflicts on the same branch\n   * @param canJoin - A `JoinFunction` to determine if two node groups should\n   * be joined together in the same conflict group\n   */\n  _mergeNode(\n    br: BranchKey,\n    nstart: LogootPosition,\n    length: number,\n    nrclk: LogootInt,\n    type: NodeType,\n    canJoin: JoinFunction\n  ): Operation[] {\n    const level = nstart.levels\n    const nend = nstart.offsetLowest(length)\n\n    if (this.clock.cmp(nrclk) < 0) {\n      this.clock.assign(nrclk)\n    }\n\n    // Search:\n    // n < nstart          -> _lesser\n    // nstart <= n < nend  -> _skip_ranges\n    // nend <= n           -> _greater\n    const range_search = this.logoot_bst.create_range_search()\n    range_search.lesser_find_greatest = true\n    range_search.greater_find_least = true\n    range_search.push_point({ start: nstart }, '_lesser', false)\n    range_search.push_point({ start: nend }, '_skip_ranges', false)\n    range_search.all_greater('_greater')\n    const { _lesser, _skip_ranges, _greater } = this.logoot_bst.search(\n      range_search\n    )\n\n    let lesser\n    let greater\n    if (_lesser && _lesser.length > 1) {\n      throw new FatalError(\n        'Corrupt BST. There are multiple nodes at a position.'\n      )\n    } else if (_lesser && _lesser.length) {\n      lesser = _lesser[0]\n    }\n    if (_greater && _greater.length > 1) {\n      throw new FatalError(\n        'Corrupt BST. There are multiple nodes at a position.'\n      )\n    } else if (_greater && _greater.length) {\n      greater = _greater[0]\n    }\n    const skip_ranges = _skip_ranges\n      ? _skip_ranges.sort((a, b) => a.start.cmp(b.start))\n      : []\n\n    if (lesser && skip_ranges.includes(lesser)) {\n      skip_ranges.splice(skip_ranges.indexOf(lesser), 1)\n    }\n    if (greater && skip_ranges.includes(greater)) {\n      skip_ranges.splice(skip_ranges.indexOf(greater), 1)\n    }\n    if (lesser) {\n      skip_ranges.unshift(lesser)\n    }\n    // Split lesser if there's no way that it will conflict (which will be if\n    // it's on a higher level)\n    if (\n      lesser &&\n      lesser.start.levels < level &&\n      lesser.start.cmp(nstart) < 0 &&\n      lesser.end.cmp(nend) > 0\n    ) {\n      const lesser_end = lesser.splitAround(\n        nstart\n          .copy()\n          .level(lesser.start.levels)\n          .sub(lesser.start.level(lesser.start.levels)).js_int\n      )\n      skip_ranges.push(lesser_end)\n    } else if (greater) {\n      skip_ranges.push(greater)\n    }\n\n    // Ensure that there's something at the end of the list so that it will\n    // always run regardless and if there are nodes, that there is always a node\n    // last in the array at the end position\n    if (\n      !skip_ranges.length ||\n      skip_ranges[skip_ranges.length - 1].end.cmp(nend) < 0\n    ) {\n      const vgroup = new LogootNodeGroup()\n      vgroup.start = nend\n      skip_ranges.push(vgroup)\n    }\n\n    // Keep track of all the conflict groups we're automatically modifying\n    let conflict_order: ConflictGroup[] = []\n    skip_ranges.forEach(({ group }) => {\n      if (\n        group &&\n        !conflict_order.includes(group) &&\n        group.branch_order.length\n      ) {\n        conflict_order.push(group)\n      }\n    })\n    conflict_order = conflict_order.sort(\n      (a, b) => a.known_position - b.known_position\n    )\n\n    const original_known_end = conflict_order.length\n      ? conflict_order[conflict_order.length - 1].ldoc_end\n      : 0\n\n    // Track all the operations that have been performed and the offset that\n    // should be placed on nodes after this one. This will modify the nodes\n    // in `conflict_order`\n    const operations: Operation[] = []\n    let known_position_shift = 0\n    const applyShift = (\n      cg: ConflictGroup,\n      start: number,\n      length: number,\n      ic: boolean\n    ): void => {\n      known_position_shift += length\n\n      // Record the Logoot start of this new CG\n      const lstart = cg.logoot_start\n      for (let i = conflict_order.length - 1; i > 0; i--) {\n        const n = conflict_order[i]\n        // Bail out if we've passed our position\n        if (ic) {\n          if (n.known_position < start || n.logoot_start.cmp(lstart) < 0) {\n            return\n          }\n        } else {\n          if (n.known_position <= start || n.logoot_start.cmp(lstart) <= 0) {\n            return\n          }\n        }\n        // Add to the known_position, ignoring the current node\n        if (n !== cg) {\n          conflict_order[i].known_position += length\n        }\n      }\n    }\n    const remove = (cg: ConflictGroup, start: number, length: number): void => {\n      if (length === 0) {\n        return\n      }\n      operations.push({\n        type: 'r',\n        start,\n        length\n      })\n      applyShift(cg, start, -length, true)\n    }\n    const insert = (\n      cg: ConflictGroup,\n      start: number,\n      offset: number,\n      length: number\n    ): void => {\n      if (length === 0) {\n        return\n      }\n      operations.push({\n        type: 'i',\n        start,\n        offset,\n        length\n      })\n      applyShift(cg, start, length, true)\n    }\n    const translate = (source: number, length: number, dest: number): void => {\n      if (length === 0) {\n        return\n      }\n      if (source === dest) {\n        return\n      }\n      operations.push({ type: 't', source, length, dest })\n    }\n    const mark = (\n      start: number,\n      length: number,\n      conflicting: boolean\n    ): void => {\n      if (length === 0) {\n        return\n      }\n      operations.push({ type: 'm', start, length, conflicting })\n    }\n\n    // Split a conflict group and translate the child nodes\n    const splitCg = (cg: ConflictGroup, ng: LogootNodeGroup): ConflictGroup => {\n      if (!cg.groups.includes(ng)) {\n        throw new FatalError('Node group not in conflict group.')\n      }\n      if (!conflict_order.includes(cg)) {\n        throw new FatalError('Conflict group not in conflict_order')\n      }\n\n      // New Conflict Group -- Ok, my naming is bad here lol\n      const ncg = new ConflictGroup(cg.ldoc_end)\n\n      let known_position = cg.known_position\n      const known_end = ncg.known_position\n      cg.branch_order.forEach((br) => {\n        // Calculate the area ahead of the known_position that isn't moved\n        const excerpt_length = ((): number => {\n          let origin = 0\n          for (let i = 0; i < cg.groups.length; i++) {\n            origin += cg.groups[i].branchLength([br])\n            if (cg.groups[i] === ng) {\n              return origin\n            }\n          }\n          // This should never happen\n          throw new FatalError()\n        })()\n\n        ncg.branch_order.push(br)\n\n        const moved_length = cg.branchLength([br]) - excerpt_length\n\n        ncg.known_position -= moved_length\n        known_position += excerpt_length\n        translate(known_position, moved_length, known_end - moved_length)\n      })\n\n      ncg.groups = cg.groups.splice(cg.groups.indexOf(ng) + 1, cg.groups.length)\n      ncg.groups.forEach((group) => (group.group = ncg))\n\n      this.ldoc_bst.add(ncg)\n      conflict_order.splice(conflict_order.indexOf(cg) + 1, 0, ncg)\n\n      return ncg\n    }\n    // Join a conflict group and translate the child nodes\n    const joinCg = (lcg: ConflictGroup, ncg: ConflictGroup): void => {\n      ncg.branch_order.forEach((br) => {\n        if (!lcg.branch_order.includes(br)) {\n          lcg.branch_order.push(br)\n        }\n      })\n\n      ncg.groups.forEach((group) => (group.group = lcg))\n      lcg.groups.splice(lcg.groups.length, 0, ...ncg.groups)\n\n      let fetch_position = ncg.known_position\n      let known_position = lcg.known_position\n      ncg.branch_order.forEach((br) => {\n        known_position += lcg.branchLength([br])\n        const next_length = ncg.branchLength([br])\n        translate(fetch_position, next_length, known_position - next_length)\n        fetch_position += next_length\n      })\n\n      ncg.branch_order.length = 0\n      ncg.groups = []\n      // Ensure that we remove **only** this node from the BST\n      this.ldoc_bst.remove(ncg, (other) => other === ncg)\n      conflict_order.splice(conflict_order.indexOf(ncg), 1)\n    }\n\n    let last_start = nstart.level(level)\n    let last_group = lesser\n    skip_ranges.forEach((group, i) => {\n      // Can be reassigned when nodes are split\n      let next_group = skip_ranges[i + 1]\n\n      const group_level_start = group.start.clamp(nstart, nend, level).l(level)\n      const group_level_end = group.end.clamp(nstart, nend, level).l(level)\n\n      const empty_length = group_level_start.copy().sub(last_start).js_int\n      const empty_offset = last_start.copy().sub(nstart.l(level)).js_int\n\n      if (\n        empty_length > 0 ||\n        // If the next node has fewer levels, the empty space is *technically*\n        // infinite, but empty_length won't show this\n        (group.start.levels < level && length - empty_offset > 0)\n      ) {\n        const newgroup = new LogootNodeGroup()\n        newgroup.start = nstart.copy()\n        newgroup.start.l(level).assign(last_start)\n        newgroup.length = empty_length || length - empty_offset\n        newgroup.br(br, { type, rclk: nrclk })\n\n        // Now, we actually insert the node where it should be according to the\n        // node canJoin function\n        // First, check if we can join with the two nodes flanking this one\n        // Remember, we're operating BEFORE `group`\n        const last_join = last_group && canJoin(last_group, newgroup)\n        const next_join = group && canJoin(newgroup, group)\n        const already_joined =\n          last_group && group && last_group.group === group.group\n\n        if (!already_joined && last_join && next_join) {\n          // Join last and next\n          joinCg(last_group.group, group.group)\n        } else if (already_joined && !(last_join && next_join)) {\n          // Split last and next\n          splitCg(last_group.group, last_group)\n        }\n\n        if (!last_join && !next_join) {\n          // Ok, so now we need to create a new conflict group\n          newgroup.group = new ConflictGroup(\n            last_group ? last_group.group.ldoc_end : 0\n          )\n          newgroup.group.branch_order.push(br)\n          this.ldoc_bst.add(newgroup.group)\n          conflict_order.splice(\n            last_group ? conflict_order.indexOf(last_group.group) + 1 : 0,\n            0,\n            newgroup.group\n          )\n        } else {\n          // Now, make sure we have a target group\n          newgroup.group = last_join ? last_group.group : group.group\n        }\n\n        if (type === NodeType.DATA) {\n          insert(\n            newgroup.group,\n            newgroup.group.insertSingleBranchGroup(newgroup),\n            empty_offset,\n            newgroup.length\n          )\n        } else {\n          newgroup.group.insertSingleBranchGroup(newgroup)\n        }\n\n        last_group = newgroup\n        this.logoot_bst.add(newgroup)\n      }\n\n      const group_length = group_level_end.copy().sub(group_level_start).js_int\n      const group_offset = group_level_start.copy().sub(nstart.l(level)).js_int\n      if (\n        group.start.levels === level &&\n        group_length > 0 &&\n        (!group.br(br) ||\n          // Data nodes have the lowest priority\n          nrclk.cmp(group.br(br).rclk) > (type === NodeType.DATA ? 0 : -1))\n      ) {\n        // Split off the trailing start\n        if (group.start.cmp(nstart) < 0) {\n          last_group = group\n          group = group.splitAround(\n            nstart.l(level).sub(group.start.l(level)).js_int\n          )\n          this.logoot_bst.add(group)\n        }\n        // Split off the trailing end\n        if (group.end.cmp(nend) > 0) {\n          const newgroup = group.splitAround(\n            group.end.l(level).sub(nend.l(level)).js_int\n          )\n          this.logoot_bst.add(newgroup)\n          next_group = newgroup\n        }\n\n        // Ensure that this group is in the branch order\n        if (!group.group.branch_order.includes(br)) {\n          group.group.branch_order.push(br)\n        }\n\n        // Now, capture this node's target position\n        const known_position = group.group.insertPos(br, group)\n        // Remove old conflicts\n        if (group.br(br) && group.br(br).type === NodeType.DATA) {\n          remove(group.group, known_position, group.length)\n        }\n        // Ensure the new data is correct\n        group.br(br, { type, rclk: nrclk })\n        // Add new data\n        if (type === NodeType.DATA) {\n          insert(group.group, known_position, group_offset, group.length)\n        }\n\n        const fixJoined = (a: LogootNodeGroup, b: LogootNodeGroup): void => {\n          if (!a || !b) {\n            return\n          }\n          const joined = a.group === b.group\n          const should_join = canJoin(a, b)\n          if (!joined && should_join) {\n            joinCg(a.group, b.group)\n          } else if (joined && !should_join) {\n            splitCg(a.group, a)\n          }\n        }\n\n        // Double check that these nodes still should be joined\n        fixJoined(last_group, group)\n        fixJoined(group, next_group)\n      }\n\n      last_start = group.end.clamp(nstart, nend, level).level(level)\n      last_group = group\n    })\n\n    conflict_order.forEach(({ known_position, ldoc_length, conflicted }) => {\n      mark(known_position, ldoc_length, conflicted)\n    })\n\n    // Now, update all nodes after the ones in conflict_order\n    this.ldoc_bst.operateOnAllGteq(\n      { known_position: original_known_end },\n      ({ data }) => {\n        if (!data.groups.length) {\n          throw new FatalError('An empty conflict group was found in the BST')\n        }\n        if (data.logoot_start.cmp(nend) < 0) {\n          return\n        }\n        if (!conflict_order.includes(data)) {\n          data.known_position += known_position_shift\n        }\n      }\n    )\n\n    return operations\n  }\n\n  insertLogoot(\n    br: BranchKey,\n    start: LogootPosition,\n    length: number,\n    rclk: LogootInt\n  ): Operation[] {\n    return this._mergeNode(br, start, length, rclk, NodeType.DATA, this.canJoin)\n  }\n\n  removeLogoot(\n    br: BranchKey,\n    start: LogootPosition,\n    length: number,\n    rclk: LogootInt\n  ): Operation[] {\n    return this._mergeNode(\n      br,\n      start,\n      length,\n      rclk,\n      NodeType.REMOVAL,\n      this.canJoin\n    )\n  }\n}\n\nexport {\n  LogootInt,\n  LogootPosition,\n  KnownPositionBst,\n  LogootBst,\n  Removal,\n  ListDocumentModel,\n  NodeType\n}\n","/**\n * @file A binary search tree implementation for finding ranges within the tree\n * and finding neighboring nodes. The documentation for this is, erm, not super\n * amazing.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { DualCompareFunction, MemberPtr } from './utils'\n\n/**\n * The node type used by the binary search tree\n */\nclass BstNode<T> {\n  /**\n   * The data contained in the node.\n   */\n  data: T\n  left: BstNode<T> | undefined\n  right: BstNode<T> | undefined\n  constructor(data: T) {\n    this.data = data\n  }\n}\n\n/**\n * The pointer type either to a leaf of the BST or the root. By using\n * `MemberPtr`, methods in the BST can re-assign the node value simply through\n * this 'pointer' object.\n */\ntype BstNodePtr<T> =\n  | MemberPtr<BstNode<T>, 'left'>\n  | MemberPtr<BstNode<T>, 'right'>\n  // eslint-disable-next-line\n  | MemberPtr<Bst<T, any>, 'bst_root'>\n/**\n * The type of a function that operates on nodes of the BST.\n */\ntype NodeOp<T> = (node: BstNode<T>) => void\n\n/**\n * A single point in a `RangeSearch`. The first element is the point value, the\n * second element is a boolean that is true if the point is inclusive, and the\n * third element the bucket string, or `undefined` to drop elements.\n */\ntype Point<T> = [T, boolean, string?]\n\n/**\n * A representation of an inequality that can be used to search and sort the\n * elements of an array into `bucket`s. It is a collection of `Point`s. Each\n * `Point` will include any values less that its own and, if the point is\n * inclusive, equal to its own.\n */\nclass RangeSearch<T> {\n  /**\n   * True if only **one** value is kept for elements before the first point.\n   * Used to find the inorder predecessor.\n   */\n  lesser_find_greatest = false\n  /**\n   * True if only **one** value is kept for elements after the last point. Used\n   * to find the inorder successor.\n   */\n  greater_find_least = false\n  private points: Point<T>[] = []\n  private last_bucket?: string\n  private cf: DualCompareFunction<T>\n\n  constructor(cf: DualCompareFunction<T>) {\n    this.cf = cf\n  }\n\n  static lteq<T>(\n    cf: DualCompareFunction<T>,\n    pd: T,\n    bucket: string\n  ): RangeSearch<T> {\n    const search = new RangeSearch<T>(cf)\n    search.points.push([pd, true, bucket])\n    search.last_bucket = undefined\n    return search\n  }\n  static lt<T>(\n    cf: DualCompareFunction<T>,\n    pd: T,\n    bucket: string\n  ): RangeSearch<T> {\n    const search = new RangeSearch<T>(cf)\n    search.points.push([pd, false, bucket])\n    search.last_bucket = undefined\n    return search\n  }\n  static gteq<T>(\n    cf: DualCompareFunction<T>,\n    pd: T,\n    bucket: string\n  ): RangeSearch<T> {\n    const search = new RangeSearch<T>(cf)\n    search.points.push([pd, false, undefined])\n    search.last_bucket = bucket\n    return search\n  }\n  static gt<T>(\n    cf: DualCompareFunction<T>,\n    pd: T,\n    bucket: string\n  ): RangeSearch<T> {\n    const search = new RangeSearch<T>(cf)\n    search.points.push([pd, true, undefined])\n    search.last_bucket = bucket\n    return search\n  }\n\n  /**\n   * Add a point to the collection.\n   * @param data - The value for comparison.\n   * @param bucket - The `bucket` to sort values into, or undefined to discard.\n   * @param inclusive - Determines if the point includes `data`.\n   */\n  push_point(data: T, bucket: string, inclusive = false): void {\n    const point: Point<T> = [data, inclusive, bucket]\n    for (let i = 0; i < this.points.length; i++) {\n      if (this.cf(data, this.points[i][0]) < 0) {\n        this.points.splice(i, 0, point)\n        return\n      }\n    }\n    this.points.push(point)\n  }\n  /**\n   * Set the default bucket for any values greater than the last point.\n   */\n  all_greater(bucket?: string): void {\n    this.last_bucket = bucket\n  }\n\n  /**\n   * A function used by Binary Search Trees to determine traversal.\n   * @param data - The value to compare.\n   * @param current - The current values that are stored.\n   * @param clear_buckets - If true, elements from `current` will be eliminated\n   * if they are affected by `lesser_find_greatest` or `greater_find_least` and\n   * an alternative closer to `data` is found.\n   * @param traverse_left - Will be called when there is the possibility that\n   * there are elements smaller than this one that will satisfy\n   * `greater_find_least`, thereby reducing the number of necessary traversals.\n   * @returns An object containing `left` and `right`, which are booleans that\n   * tell whether more data could be found to the left and right of `data`,\n   * respectively, as well as an optional `bucket` string to tell where `data`\n   * should be sorted.\n   */\n  getBucketInfo(\n    data: T,\n    current?: { [key: string]: T[] },\n    clear_buckets = false,\n    traverse_left?: () => void\n  ): {\n    left: boolean\n    right: boolean\n    bucket?: string\n  } {\n    let left = false\n    let passed_bucket = false\n    let bucket = this.last_bucket\n    let right = Boolean(this.last_bucket)\n\n    // Account for empty searches\n    if (!this.points.length && this.last_bucket) {\n      if (!left && traverse_left) {\n        traverse_left()\n      }\n      left = true\n    }\n\n    // Calculate the membership of each range before the point\n    for (let i = 0; i < this.points.length; i++) {\n      const [other, inclusive, b] = this.points[i]\n\n      if (b && !passed_bucket) {\n        if (!left && traverse_left) {\n          traverse_left()\n        }\n        left = true\n      }\n\n      // Should we add to this current bucket?\n      if (this.cf(data, other) < (inclusive ? 1 : 0)) {\n        if (!passed_bucket) {\n          passed_bucket = true\n          bucket = b\n        }\n        if (\n          i == 0 &&\n          this.lesser_find_greatest &&\n          clear_buckets &&\n          current[b] &&\n          current[b].length\n        ) {\n          if (this.cf(current[b][0], data) < 0) {\n            current[b] = []\n          } else if (this.cf(current[b][0], data) > 0) {\n            bucket = undefined\n          }\n        }\n      }\n\n      if (b && passed_bucket && this.cf(other, data) !== 0) {\n        right = true\n      }\n    }\n\n    // Ensure we account for the area after the last point\n    if (!passed_bucket && this.last_bucket) {\n      const b = this.last_bucket\n      // Traverse the left side assuming we haven't already\n      if (bucket && !left) {\n        left = true\n        traverse_left()\n      }\n      if (\n        this.greater_find_least &&\n        clear_buckets &&\n        current[b] &&\n        current[b].length\n      ) {\n        if (this.cf(current[b][0], data) > 0) {\n          current[b] = []\n        } else if (this.cf(current[b][0], data) < 0) {\n          bucket = undefined\n        }\n      }\n      right = true\n    }\n\n    // Don't traverse if unnecessary\n    left =\n      left &&\n      (!this.lesser_find_greatest ||\n        !this.points.length ||\n        !current[this.points[0][2]] ||\n        !current[this.points[0][2]].length ||\n        this.cf(current[this.points[0][2]][0], data) <= 0)\n    right =\n      right &&\n      (!this.greater_find_least ||\n        !current[this.last_bucket] ||\n        !current[this.last_bucket].length ||\n        this.cf(current[this.last_bucket][0], data) >= 0)\n\n    return { left, bucket, right }\n  }\n\n  /*\n   * Place `data` into a bucket defined by `range_buckets` based on the points\n   * that have been added to this search\n   * @param data - The value to sort.\n   * @param range_buckets - Sort `data` into one of the buckets defined as\n   * properties on this object. An array will be assigned at the bucket name if\n   * the target bucket is not already defined.\n   * @returns `range_buckets`\n   */\n  sort(\n    data: T,\n    range_buckets: { [key: string]: T[] } = {}\n  ): { [key: string]: T[] } {\n    let i\n    for (i = 0; i < this.points.length; i++) {\n      const [other, inclusive, b] = this.points[i]\n\n      if (this.cf(data, other) < (inclusive ? 1 : 0)) {\n        if (!b) {\n          return range_buckets\n        }\n        if (\n          !range_buckets[b] ||\n          (i === 0 &&\n            this.lesser_find_greatest &&\n            range_buckets[b].length &&\n            this.cf(range_buckets[b][0], data) < 0)\n        ) {\n          range_buckets[b] = []\n        }\n        range_buckets[b].push(data)\n        return range_buckets\n      }\n    }\n    i = this.points.length\n\n    const b = this.last_bucket\n    if (!b) {\n      return range_buckets\n    }\n    if (\n      !range_buckets[b] ||\n      (this.greater_find_least &&\n        range_buckets[b].length &&\n        this.cf(range_buckets[b][0], data) > 0)\n    ) {\n      range_buckets[b] = []\n    }\n    range_buckets[b].push(data)\n    return range_buckets\n  }\n\n  /*\n   * Sort the elements of `array` into buckets and return the result.\n   * @param array - The array to sort.\n   * @returns The populated buckets.\n   */\n  search_array(array: T[]): { [key: string]: T[] } {\n    const range_buckets: { [key: string]: T[] } = {}\n    array.forEach((el) => this.sort(el, range_buckets))\n    return range_buckets\n  }\n}\n\n/**\n * A binary search tree implementation for finding ranges within the tree and\n * finding neighboring nodes.\n * @template T - The type stored in the tree.\n * @template S - The type used by search functions, but that cannot be added to\n * the tree. It defaults to `T`.\n */\nclass Bst<T extends S, S = T> {\n  bst_root: BstNode<T> | undefined = undefined\n  readonly cmp: DualCompareFunction<S>\n\n  /**\n   * @param cmp - The compare function to use to sort the tree.\n   */\n  constructor(cmp: DualCompareFunction<S>) {\n    this.cmp = cmp\n  }\n\n  gteqcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) >= 0\n  }\n  gtcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) > 0\n  }\n  eqcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) === 0\n  }\n\n  /**\n   * Add an element to the tree.\n   * @param object - The object to add to the tree.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  add(object: T, node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')): void {\n    if (!node.value) {\n      node.value = new BstNode(object)\n    } else if (this.gteqcmp(node.value.data, object)) {\n      this.add(object, new MemberPtr(node.value, 'left'))\n    } else {\n      this.add(object, new MemberPtr(node.value, 'right'))\n    }\n  }\n\n  /*\n   * Creates a range search from the local compare function.\n   * @returns A new range search.\n   */\n  create_range_search(): RangeSearch<S> {\n    return new RangeSearch<S>(this.cmp)\n  }\n\n  /*\n   * Efficiently search the BST and sort the applicable nodes into buckets.\n   * @param search - The `RangeSearch` to do\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   * @param map - The object to assign buckets to. It is returned.\n   * @returns An object with type `T` sorted into buckets.\n   */\n  search(\n    search: RangeSearch<S>,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root'),\n    map: { [key: string]: T[] } = {}\n  ): { [key: string]: T[] } {\n    if (!node.value) {\n      return map\n    }\n    const { bucket, right } = search.getBucketInfo(\n      node.value.data,\n      map,\n      true,\n      () => {\n        // Interrupting the sorting into buckets to search the left side of the\n        // tree allows us to look for elements that *might* be smaller, so we\n        // can avoid needlessly searching the right side of the tree\n        this.search(search, new MemberPtr(node.value, 'left'), map)\n      }\n    )\n    if (bucket) {\n      if (!map[bucket]) {\n        map[bucket] = []\n      }\n      map[bucket].push(node.value.data)\n    }\n    if (right) {\n      this.search(search, new MemberPtr(node.value, 'right'), map)\n    }\n    return map\n  }\n\n  /**\n   * A method designed mostly for internal use that finds the next element in\n   * the tree if all of the elements were placed in order.\n   * @param object - The object or search type to find the successor of\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  _getInorderSuccessor(\n    object: S,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): { ptr: BstNodePtr<T>; data: T } | undefined {\n    type SuccessorType = { ptr: BstNodePtr<T>; data: T } | undefined\n    let successor: SuccessorType\n    const setSuccessor = (s: SuccessorType): void => {\n      if (!successor || (s && this.gtcmp(successor.data, s.data))) {\n        successor = s\n      }\n    }\n    if (node.value) {\n      if (this.gteqcmp(node.value.data, object)) {\n        if (!this.eqcmp(node.value.data, object)) {\n          setSuccessor({ ptr: node, data: node.value.data })\n        }\n        setSuccessor(\n          this._getInorderSuccessor(object, new MemberPtr(node.value, 'left'))\n        )\n      }\n      setSuccessor(\n        this._getInorderSuccessor(object, new MemberPtr(node.value, 'right'))\n      )\n    }\n    return successor\n  }\n  /**\n   * Remove an element from the tree.\n   * @param object - The object to remove or a search type that is evaluated\n   * to the same value as an object in the tree. Equivalence is determined\n   * exclusively using the compare function.\n   * @param filter - An optional function that has the final say in whether a\n   * node is removed. While an `object` is provided for quick tree traversal, it\n   * is not always desirable to remove *every* node with that particular value.\n   * This function allows the user to override that behavior.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  remove(\n    object: S,\n    filter: (data: T) => boolean = (): boolean => true,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      const result = this.cmp(node.value.data, object)\n      const should_remove = filter(node.value.data)\n      if (result > 0) {\n        this.remove(object, filter, new MemberPtr(node.value, 'left'))\n      } else if (result < 0) {\n        this.remove(object, filter, new MemberPtr(node.value, 'right'))\n      } else if (node.value.left && node.value.right && should_remove) {\n        const successor = this._getInorderSuccessor(node.value.data, node)\n\n        this.remove(successor.data, undefined, successor.ptr)\n        node.value.data = successor.data\n      } else if (should_remove) {\n        node.value = node.value.left || node.value.right\n      }\n    }\n  }\n\n  /**\n   * Perform an operation on all of the elements in a range.\n   * @param start - The search type or object at which to start a search.\n   * @param endm1 - The search type or object at which to end a search\n   * inclusively. The name is `endm1` to stand for `END Minus 1` since the\n   * search is performed inclusively.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   * @param undef - TODO: Fix\n   */\n  operateOnAllRange(\n    start: S,\n    endm1: S,\n    operation: NodeOp<T>,\n    node = this.bst_root,\n    undef = false\n  ): void {\n    if (node && !undef) {\n      if (this.gteqcmp(node.data, start)) {\n        if (this.gteqcmp(endm1, node.data)) {\n          this.operateOnAllRange(start, endm1, operation, node.left, !node.left)\n          this.operateOnAllRange(\n            start,\n            endm1,\n            operation,\n            node.right,\n            !node.right\n          )\n          operation(node)\n        } else {\n          this.operateOnAllRange(start, endm1, operation, node.left, !node.left)\n        }\n      } else {\n        this.operateOnAllRange(start, endm1, operation, node.right, !node.right)\n      }\n    }\n  }\n  /**\n   * Perform an operation on all of the elements greater than or equal to a\n   * search type or object.\n   * @param value - The search type or object at which to start a search.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAllGteq(\n    value: S,\n    operation: NodeOp<T>,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      if (this.gteqcmp(node.value.data, value)) {\n        operation(node.value)\n        this.operateOnAllGteq(\n          value,\n          operation,\n          new MemberPtr(node.value, 'left')\n        )\n      }\n      this.operateOnAllGteq(\n        value,\n        operation,\n        new MemberPtr(node.value, 'right')\n      )\n    }\n  }\n  /**\n   * Perform an operation on all of the elements less than or equal to a\n   * search type or object.\n   * @param value - The search type or object at which to end a search.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAllLteq(\n    value: S,\n    operation: NodeOp<T>,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      if (this.gteqcmp(value, node.value.data)) {\n        operation(node.value)\n        this.operateOnAllLteq(\n          value,\n          operation,\n          new MemberPtr(node.value, 'right')\n        )\n      }\n      this.operateOnAllLteq(value, operation, new MemberPtr(node.value, 'left'))\n    }\n  }\n\n  /**\n   * Perform an operation on all nodes.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAll(\n    operation: NodeOp<T>,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      this.operateOnAll(operation, new MemberPtr(node.value, 'left'))\n      operation(node.value)\n      this.operateOnAll(operation, new MemberPtr(node.value, 'right'))\n    }\n  }\n\n  /**\n   * Get all the objects in a range.\n   * @param start - The search type or object at which to start a search.\n   * @param endm1 - The search type or object at which to end a search\n   * inclusively. The name is `endm1` to stand for `END Minus 1` since the\n   * search is performed inclusively.\n   */\n  getRange(start: S, endm1: S): (BstNode<T> | undefined)[] {\n    const nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllRange(start, endm1, (n) => nodes.push(n))\n\n    return nodes\n  }\n  /**\n   * Get all the objects greater than or equal to an object or search type.\n   * @param value - The search type or object at which to start a search.\n   */\n  getGteq(value: S): (BstNode<T> | undefined)[] {\n    let nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllGteq(value, (n) => {\n      if (!nodes[0] || this.gtcmp(nodes[0].data, n.data)) {\n        nodes = [n]\n      } else if (this.eqcmp(nodes[0].data, n.data)) {\n        nodes.push(n)\n      }\n    })\n\n    return nodes\n  }\n  /**\n   * Get all the objects less than or equal to an object or search type.\n   * @param value - The search type or object at which to end a search.\n   */\n  getLteq(value: S): (BstNode<T> | undefined)[] {\n    let nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllLteq(value, (n) => {\n      if (!nodes[0] || this.gtcmp(n.data, nodes[0].data)) {\n        nodes = [n]\n      } else if (this.eqcmp(nodes[0].data, n.data)) {\n        nodes.push(n)\n      }\n    })\n\n    return nodes\n  }\n\n  toString(): string {\n    let str = 'BST [\\n'\n    this.operateOnAll(({ data }) => {\n      str +=\n        '  ' +\n        data\n          .toString()\n          .split('\\n')\n          .join('\\n  ') +\n        '\\n'\n    })\n    str += ']'\n    return str\n  }\n}\n\nexport { Bst, RangeSearch, BstNode }\n","/**\n * @file This contains most of the data types used by the `ListDocumentModel`.\n * While `index.ts` does most of the heavy lifting, this file is the source of\n * most definitions used there. The files were split to make it easier for me to\n * switch since I can switch using tabs in my text editor.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { Int32 } from '../ints'\nimport { CompareResult, FatalError, allKeys } from '../utils'\n\n// What a C++ typedef would do\n// This makes it possible to completely swap out the type of the int used in the\n// algorithm w/o actually replacing each instance (which would be a real pain)\nimport LogootInt = Int32\n\n/**\n * A position in Logoot. This is just an array of numbers with some utility\n * functions. In Logoot, it must always be possible to allocate a position\n * between any possible two positions. In this algorithm, a position with more\n * `levels` (or elements in the array) comes first. So, if it is necessary to\n * create a position between `A` and `B`, then another level can be added to the\n * position to make it come after `A` and before `B`. Positions are represented\n * in writing the same as arrays: `[1,2,3]`\n * @example ```typescript\n * const a = new LogootPosition()\n * console.log(a.toString()) // [0]\n *\n * const b = a.offsetLowest(1)\n * console.log(b.toString()) // [1]\n *\n * console.log(new LogootPosition(1, a, b).toString()) // [0]\n * console.log(new LogootPosition(2, a, b).toString()) // [0,0]\n * ```\n */\nclass LogootPosition {\n  protected array: LogootInt[] = [new LogootInt(0)]\n\n  /**\n   * This constructor constructs a new position that is in the range specified\n   * by `start` and `end`. By using `len`, it is possible to enforce that a\n   * certain number of additional positions are available in the selected range.\n   * This guarantees that there's space for a LogootNode of length `len` at this\n   * position between `start` and `end`.\n   *\n   * @param len - The length of the allocation to make. The length is never\n   * actually stored in the Logoot position, but is used when finding space for\n   * the position to be created and `len` position(s) after it.\n   * @param start - This will cause the new position to have a value greater\n   * than or equal to this. This value is tricky: It must be the end of the last\n   * node. So if `A` is at `[1]` and an allocation *after* it is desired, then\n   * `[2]` would need to be passed to `start`.\n   * @param end - This will cause the new position to have a value less than or\n   * equal to this, subject to the value of `len`.\n   */\n  constructor(\n    len = 0,\n    readonly start?: LogootPosition,\n    readonly end?: LogootPosition\n  ) {\n    if (!start && end) {\n      this.array = end.inverseOffsetLowest(len).array\n    } else if (!end && start) {\n      this.array = start.copy().array\n    } else if (start && end) {\n      let done = false\n      const itstart = start.array.values()\n      const itend = end.array.values()\n      let nstart\n      let nend\n\n      this.array.length = 0\n\n      while (!done) {\n        if (!nstart || !nstart.done) {\n          nstart = itstart.next()\n        }\n        if (!nend || !nend.done) {\n          nend = itend.next()\n        }\n\n        if (!nstart.done && !nend.done) {\n          // See if we have enough space to insert 'len' between the nodes\n          if (nend.value.gteq(new LogootInt(nstart.value).add(len))) {\n            // There's space. We're done now: At the shallowest possible level\n            done = true\n          }\n          // Regardless, the start ID is the new ID for this level of our node\n          this.array.push(new LogootInt(nstart.value))\n        } else if (!nstart.done) {\n          // So there's no end restriction, that means we can just add right on\n          // top of the old end (the start of the new node)\n          this.array.push(new LogootInt(nstart.value))\n          done = true\n        } else if (!nend.done) {\n          // We have an end restriction, but no start restriction, so we just\n          // put the new node's start behind the old end\n          this.array.push(new LogootInt(nend.value).sub(len))\n          done = true\n        } else {\n          // So both other IDs have nothing else. It must be time to make a new\n          // level and be done\n          this.array.push(new LogootInt())\n          done = true\n        }\n      }\n    }\n  }\n\n  static fromJSON(eventnode: LogootPosition.JSON): LogootPosition {\n    const pos = new LogootPosition()\n    pos.array.length = 0\n    eventnode.forEach((n) => {\n      pos.array.push(LogootInt.fromJSON(n))\n    })\n    return pos\n  }\n  static fromInts(...ints: (LogootInt | number)[]): LogootPosition {\n    const pos = new LogootPosition()\n    pos.array.length = 0\n    ints.forEach((n) => {\n      pos.array.push(new LogootInt(n))\n    })\n    return pos\n  }\n  toJSON(): LogootPosition.JSON {\n    return this.array.map((n) => n.toJSON())\n  }\n\n  /**\n   * @returns Internal array length\n   */\n  get length(): number {\n    // A zero-length position is NOT valid\n    // Through some sneakiness, you COULD directly assign the array to make it\n    // have a length of zero. Don't do it.\n    return this.array.length\n  }\n  /**\n   * Returns the last index of the array. This is useful because before this,\n   * the algorithm code often contained many occurences of `length - 1`. This\n   * is used to cut down redundancy.\n   */\n  get levels(): number {\n    // A zero-length position is NOT valid\n    // Through some sneakiness, you COULD directly assign the array to make it\n    // have a length of zero. Don't do it.\n    return this.length - 1\n  }\n  /**\n   * An array accessor\n   */\n  level(n: number): LogootInt {\n    return this.array[n]\n  }\n  /**\n   * An array accessor\n   * @alias level\n   */\n  l(n: number): LogootInt {\n    return this.level(n)\n  }\n\n  /**\n   * Returns a new position with `offset` added to the lowest level of the\n   * position.\n   */\n  offsetLowest(offset: number | LogootInt): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((current, i, array) => {\n        return i < array.length - 1\n          ? current\n          : new LogootInt(current).add(offset)\n      })\n    })\n  }\n  /**\n   * Returns a new position with `offset` subtracted from the lowest level of\n   * the position.\n   */\n  inverseOffsetLowest(offset: number | LogootInt): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((current, i, array) => {\n        return i < array.length - 1\n          ? current\n          : new LogootInt(current).sub(offset)\n      })\n    })\n  }\n\n  /**\n   * Duplicates this position.\n   */\n  copy(): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((e) => new LogootInt(e))\n    })\n  }\n\n  /**\n   * Return a copy of this position, but with the number of levels specified by\n   * `level`. If this position has fewer levels, zeroes will be added in place.\n   */\n  equivalentPositionAtLevel(level: number): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: new Array(level + 1).fill(0, 0, level + 1).map((el, i) => {\n        return new LogootInt(this.array[i])\n      })\n    })\n  }\n\n  cmp(pos: LogootPosition, level = 0): CompareResult {\n    if (level >= this.length) {\n      if (this.length === pos.length) {\n        return 0\n      }\n      return 1\n    }\n    if (level >= pos.length) {\n      return -1\n    }\n    switch (this.level(level).cmp(pos.level(level))) {\n      case 1:\n        return 1\n      case -1:\n        return -1\n      case 0:\n        return this.cmp(pos, level + 1)\n      default:\n        return 0\n    }\n  }\n\n  /**\n   * Return this position if it is between `min` or `max`, otherwise return\n   * `min` if this is less and `max` if this is greater.\n   * @param min - The minimum output.\n   * @param max - The maximum output.\n   * @param preserve_levels - If defined, the output number of levels will be\n   * equal to `preserve_levels`.\n   * @returns Either this position, min, or max. It is **not** copied, so if you\n   * want to modify it, you should copy it.\n   */\n  clamp(\n    min: LogootPosition,\n    max: LogootPosition,\n    preserve_levels?: undefined | number\n  ): LogootPosition {\n    const clamped = this.cmp(min) < 0 ? min : this.cmp(max) > 0 ? max : this\n    if (preserve_levels !== undefined) {\n      return clamped.equivalentPositionAtLevel(preserve_levels)\n    } else {\n      return clamped.copy()\n    }\n  }\n\n  toString(): string {\n    let str = '['\n    this.array.forEach((el, i, a) => {\n      str += el.toString() + (i >= a.length - 1 ? '' : ',')\n    })\n    str += ']'\n    return str\n  }\n}\nnamespace LogootPosition {\n  export type JSON = LogootInt.JSON[]\n  export namespace JSON {\n    export const Schema = { type: 'array', items: LogootInt.JSON.Schema }\n  }\n}\n\n/**\n * A type used to identify a branch. This value should be used to look up a\n * user-presentable name in another map stored outside of `logootish-js`. This\n * is implementation-defined and allows for the broadest possible definition of\n * a branch.\n */\ntype BranchKey = symbol | string | number\n\n/**\n * The type of node stored in a `LogootNodeGroup`.\n */\nenum NodeType {\n  DATA,\n  REMOVAL\n}\n/**\n * Names for NodeType that are printed in debug information.\n */\nconst nt_string = {\n  [NodeType.DATA]: 'DATA',\n  [NodeType.REMOVAL]: 'REMOVAL'\n}\n\n/**\n * A group of `LogootNodeGroup`s that are considered by the `JoinFunction` (see\n * the list document model `index.ts` file) to be related. Each Logoot node is\n * not displayed in the order specified in `groups`. Rather, all of the nodes on\n * a particular branch are displayed together and in the order defined by\n * `branch_order`.\n * @TODO Move `branch_order` into the ListDocumentModel. No reason not to have\n * a whole-document branch order.\n */\nclass ConflictGroup {\n  known_position = 0\n  /**\n   * The order in which branches are displayed. All of the nodes that make up\n   * a single branch are placed together.\n   */\n  readonly branch_order: BranchKey[] = []\n  /**\n   * A list of `LogootNodeGroups` that make up the Logoot side of the local\n   * document. A group's nodes will be split up and placed into one of the\n   * branch sections as defined in `branch_order`. These **absolutely must** be\n   * in order based on their Logoot positions.\n   */\n  groups: LogootNodeGroup[] = []\n\n  constructor(position: number) {\n    this.known_position = position\n  }\n\n  /**\n   * Get the equivalent length of all data nodes.\n   */\n  get ldoc_length(): number {\n    return this.groups.reduce((n, group) => {\n      return n + group.ldoc_length\n    }, 0)\n  }\n  /**\n   * Find the end in the local document,\n   */\n  get ldoc_end(): number {\n    return this.known_position + this.ldoc_length\n  }\n\n  /**\n   * Get the first group's Logoot position\n   */\n  get logoot_start(): LogootPosition {\n    return this.groups[0] ? this.groups[0].start : undefined\n  }\n  /**\n   * Get the last group's Logoot position\n   */\n  get logoot_end(): LogootPosition {\n    return this.groups.length\n      ? this.groups[this.groups.length - 1].end\n      : undefined\n  }\n\n  /**\n   * Get the first branch in this group.\n   */\n  get first_branch(): BranchKey {\n    return this.branch_order[0]\n  }\n  /**\n   * Get the last branch in this group.\n   */\n  get last_branch(): BranchKey {\n    return this.branch_order.length\n      ? this.branch_order[this.branch_order.length - 1]\n      : undefined\n  }\n\n  /**\n   * True if any groups are conflicted.\n   */\n  get conflicted(): boolean {\n    return this.groups.some((g) => g.conflicted)\n  }\n  /**\n   * The length in the local document (only `DATA` nodes) of only `branches`.\n   * @param branches - A list of branches to count.\n   */\n  branchLength(branches: BranchKey[]): number {\n    return this.groups.reduce((n, group) => {\n      return n + group.branchLength(branches)\n    }, 0)\n  }\n\n  /**\n   * Find the position in the local document of a group that **is already** in\n   * this `ConflictGroup`. This is named `insertPos` because it is used to find\n   * the insertion position of a new group, but the naming is a bit confusing.\n   * @param br - The branch on which to determine the position.\n   * @param at - The LogootNodeGroup to determine the position of.\n   * @returns The position of `at`.\n   * @throws {FatalError} Will throw if `after` is not in this CG.\n   */\n  insertPos(br: BranchKey, at: LogootNodeGroup): number {\n    // First, compute the offset for all of the previous branches (ex, A and B)\n    // AAAAAAABBBBccccccdddddeeee\n    let offset =\n      this.known_position +\n      this.branchLength(\n        this.branch_order.slice(0, this.branch_order.indexOf(br) + (at ? 0 : 1))\n      )\n\n    if (!at) {\n      return offset\n    }\n\n    // Sum up all of the prior groups on our branch\n    for (let i = 0; i < this.groups.length; i++) {\n      // Once we've found our group, bail out\n      if (this.groups[i] === at) {\n        return offset\n      }\n      offset += this.groups[i].branchLength([br])\n    }\n    throw new FatalError(\n      'Tried to insert after a LogootNodeGroup that is not in this conflict group'\n    )\n  }\n\n  /**\n   * Get the nodes to the left and right of `start`. If there is already a\n   * `LogootNodeGroup` with the same position, behavior is undefined.\n   * @param start - The position for which to find neighbors of.\n   * @returns An object containing `left` and `right` `LogootNodeGroup`s, as\n   * well as a `pos` number, which is the position of `right` in `this.groups`.\n   */\n  getNeighbors({\n    start\n  }: LogootNodeGroup): {\n    left: LogootNodeGroup\n    right: LogootNodeGroup\n    pos: number\n  } {\n    let left\n    for (let i = 0; i < this.groups.length; i++) {\n      if (this.groups[i].start.cmp(start) <= 0) {\n        left = this.groups[i]\n      }\n      if (this.groups[i].start.cmp(start) > 0) {\n        return { left, right: this.groups[i], pos: i }\n      }\n    }\n    return { left, right: undefined, pos: this.groups.length }\n  }\n\n  /**\n   * Adds a group with only one branch to this CG and returns its position.\n   * @param group - The group to add.\n   * @returns The position in the local document of the insertion.\n   * @throws {TypeError} If the group has more than one branch or if the group's\n   * `ConflictGroup` is not set to `this`. Set `group.group` to this before\n   * calling to avoid this error.\n   */\n  insertSingleBranchGroup(group: LogootNodeGroup): number {\n    if (group.n_branches !== 1) {\n      throw new TypeError('Passed group with no or more than one branch')\n    }\n    if (group.group !== this) {\n      throw new TypeError('Conflict group not assigned to node group')\n    }\n\n    const br = group.branches[0]\n    if (!this.branch_order.includes(br)) {\n      this.branch_order.push(br)\n    }\n\n    const { right, pos } = this.getNeighbors(group)\n\n    const known_position = this.insertPos(br, right)\n    this.groups.splice(pos, 0, group)\n    return known_position\n  }\n\n  toString(): string {\n    let str = `Conflict @ ${this.known_position} (`\n    str += this.branch_order.map((br) => br.toString()).join(' ')\n    str += `) {`\n    str += this.groups.map((gr) => {\n      return (\n        '\\n  ' +\n        gr\n          .toString()\n          .split('\\n')\n          .join('\\n  ')\n      )\n    })\n    str += '\\n}'\n    return str\n  }\n}\n\ntype LogootNode = { type: NodeType; rclk: LogootInt }\n/**\n * A group of nodes that are all on different branches and have different vector\n * clock values, but share the same **Logoot** start, end, and length.\n */\nclass LogootNodeGroup {\n  length = 0\n  start: LogootPosition = new LogootPosition()\n  group: ConflictGroup\n  /**\n   * The `LogootNode`s in this group. Despite what TypeScript thinks, they key\n   * is **not** a string. It is a BranchKey. Problem is, TS doesn't support\n   * using symbols to index a type, which will hopefully fixed when\n   * [TypeScript PR #26797](https://github.com/microsoft/TypeScript/pull/26797) lands.\n   * In the mean time, using `as` to turn the BranchKey into a string is used as\n   * a hacky workaround.\n   */\n  nodes: { [key: string]: LogootNode } = {}\n\n  constructor(old?: LogootNodeGroup) {\n    if (old) {\n      Object.assign(this, {\n        length: old.length,\n        start: old.start.copy(),\n        group: old.group\n      })\n      old.eachNode(({ type, rclk }, k) => {\n        this.br(k, { type, rclk: new LogootInt(rclk) })\n      })\n    }\n  }\n\n  /**\n   * Gets the length of all `DATA` nodes.\n   */\n  get ldoc_length(): number {\n    // For some reason, TS thinks that this will produce a BranchKey. Obviously,\n    // it doesn't, so I have to do the awkward \"as unknown as number\" cast :(\n    return (this.branches.reduce((n: number, br: number) => {\n      return this.br(br).type === NodeType.DATA ? n + this.length : n\n    }, 0) as unknown) as number\n  }\n\n  /**\n   * Gets the length of all `DATA` nodes on `branches`.\n   * @param branches - The branches to search.\n   * @returns The length of all `DATA` nodes\n   */\n  branchLength(branches: BranchKey[]): number {\n    return (this.branches\n      .filter((k) => branches.includes(k))\n      .reduce((n: number, br: number) => {\n        return this.br(br).type === NodeType.DATA ? n + this.length : n\n      }, 0) as unknown) as number\n  }\n\n  /**\n   * The end of the node. Note that technically there is not an atom at this\n   * position, so it's fair game to have another node placed at this position.\n   */\n  get end(): LogootPosition {\n    return this.start.offsetLowest(this.length)\n  }\n\n  get branches(): BranchKey[] {\n    return allKeys(this.nodes)\n  }\n  get n_branches(): number {\n    return this.branches.length\n  }\n  /**\n   * Returns true if there are multiple branches\n   */\n  get conflicted(): boolean {\n    return this.n_branches > 1\n    /* return ( // TODO: Fix\n      this.branches.filter((k) => {\n        return this.br(k).type !== NodeType.MERGE_INTO\n      }).length > 1\n    ) */\n  }\n\n  eachNode(cb: (n: LogootNode, k: BranchKey) => void): void {\n    this.branches.forEach((k) => {\n      cb(this.br(k), k)\n    })\n  }\n  mapNodes(\n    cb: (n: LogootNode, k: BranchKey) => LogootNode\n  ): {\n    [key: string]: LogootNode\n  } {\n    const rval: { [key: string]: LogootNode } = {}\n    this.branches.forEach((k) => {\n      rval[(k as unknown) as string] = cb(this.br(k), k)\n    })\n    return rval\n  }\n\n  /**\n   * This is a method to access and (possibly) assign a `LogootNode` to the\n   * particular branch. This is a thing because TypeScript does not yet support\n   * using symbols as keys and I don't feel like typing\n   * `(key as unknown) as string` a billion times. See\n   * [TypeScript PR #26797](https://github.com/microsoft/TypeScript/pull/26797).\n   */\n  br(key: BranchKey, node?: LogootNode): LogootNode {\n    if (node) {\n      this.nodes[(key as unknown) as string] = node\n    }\n    return this.nodes[(key as unknown) as string]\n  }\n  delBr(key: BranchKey): void {\n    delete this.nodes[(key as unknown) as string]\n  }\n\n  /**\n   * Split this LogootNodeGroup around a position `pos` units after the current\n   * start on the lowest level.\n   * @param pos - The location of where to split this group.\n   * @returns A new LogootNodeGroup. This is spliced into this conflict group,\n   * so no cleanup is necessary after this is run.\n   */\n  splitAround(pos: number): LogootNodeGroup {\n    const newgroup = new LogootNodeGroup(this)\n    newgroup.start = this.start.offsetLowest(pos)\n    newgroup.length = this.length - pos\n\n    // Ensure that we're in the right order in the ConflictGroup\n    const groups = newgroup.group.groups\n    groups.splice(groups.indexOf(this) + 1, 0, newgroup)\n\n    this.length = pos\n    return newgroup\n  }\n\n  toString(): string {\n    let str = `Group ${this.start.toString()} + ${this.length} {`\n    str += this.branches.map((k) => {\n      const br = this.br(k)\n      return `\\n  ${String(k)}: ${nt_string[br.type]} @ ${br.rclk.toString()}`\n    })\n    str += '\\n}'\n    return str\n  }\n}\n\nexport {\n  LogootInt,\n  LogootPosition,\n  NodeType,\n  ConflictGroup,\n  LogootNodeGroup,\n  BranchKey\n}\n","/**\n * @file Definition of various integers.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { CompareResult, Comparable } from './utils'\n\n/**\n * An abstract subclass of `Comparable` to provide a generic interface for\n * integer types that may not be supported by JavaScript\n * @template FutureType - The type of the subclass with which to restrict all\n * operations to the int class.\n * @inheritdoc\n */\nabstract class IntType<FutureType> extends Comparable<FutureType | number> {\n  // eslint-disable-next-line\n  abstract toJSON(): any\n  abstract toString(): string\n\n  /**\n   * Add another integer to the value of this one\n   * @param n - The number to add\n   */\n  abstract add(n: FutureType | number): FutureType\n  /**\n   * Add another integer to the value of this one\n   * @param n - The number to subtract\n   */\n  abstract sub(n: FutureType | number): FutureType\n\n  /**\n   * Assign another integer to this object\n   * @param n - The number to assign\n   */\n  abstract sub(n: FutureType | number): FutureType\n\n  /**\n   * The JavaScript int type for this integer (with an exception thrown if the\n   * value cannot be represented in 32 bits)\n   */\n  abstract js_int: number\n}\n\n/**\n * An `IntType` that restricts the number to 32 bits by using an `Int32Array`.\n * @inheritdoc\n * @example ```typescript\n * const a = new Int32(5)\n * console.log(a.toString()) // 5\n * a.add(10).sub(8)\n * console.log(a.toString()) // 7\n * const b = new Int32(3)\n * console.log(a.cmp(b)) // 1\n * ```\n */\nclass Int32 extends IntType<Int32> {\n  // Size limit the int, enforce signing, and remove decimals\n  private int32 = new Int32Array([0])\n\n  constructor(n: Int32 | number = 0) {\n    super()\n    if (n instanceof Int32) {\n      this.int32[0] = n.int32[0]\n    } else {\n      this.int32[0] = n\n    }\n  }\n\n  static fromJSON(obj: Int32.JSON): Int32 {\n    return new Int32(obj)\n  }\n\n  toJSON(): Int32.JSON {\n    return this.int32[0]\n  }\n\n  add(n: Int32 | number): Int32 {\n    if (n instanceof Int32) {\n      this.int32[0] += n.int32[0]\n    } else {\n      this.int32[0] += n\n    }\n    return this\n  }\n  sub(n: Int32 | number): Int32 {\n    if (n instanceof Int32) {\n      this.int32[0] -= n.int32[0]\n    } else {\n      this.int32[0] -= n\n    }\n    return this\n  }\n\n  assign(n: Int32 | number): Int32 {\n    if (n instanceof Int32) {\n      this.int32[0] = n.int32[0]\n    } else {\n      this.int32[0] = n\n    }\n    return this\n  }\n\n  cmp(n: Int32 | number): CompareResult {\n    if (n instanceof Int32) {\n      return ((this.int32[0] >= n.int32[0] ? 1 : 0) +\n        (this.int32[0] <= n.int32[0] ? -1 : 0)) as CompareResult\n    } else {\n      return ((this.int32[0] >= n ? 1 : 0) +\n        (this.int32[0] <= n ? -1 : 0)) as CompareResult\n    }\n  }\n\n  copy(): Int32 {\n    return new Int32(this)\n  }\n\n  get js_int(): number {\n    return this.int32[0]\n  }\n\n  toString(): string {\n    return this.int32[0].toString()\n  }\n}\nnamespace Int32 {\n  export type JSON = number\n  export namespace JSON {\n    export const Schema = { type: 'number' }\n  }\n}\n\nexport { IntType, Int32 }\n"],"sourceRoot":""}