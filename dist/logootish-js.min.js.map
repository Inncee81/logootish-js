{"version":3,"sources":["webpack://logootish-js/webpack/universalModuleDefinition","webpack://logootish-js/webpack/bootstrap","webpack://logootish-js/./src/utils.ts","webpack://logootish-js/./src/debug.ts","webpack://logootish-js/./src/index.ts","webpack://logootish-js/./node_modules/loglevel/lib/loglevel.js","webpack://logootish-js/./src/listmodel/index.ts","webpack://logootish-js/./src/bst.ts","webpack://logootish-js/./src/listmodel/logoot.ts","webpack://logootish-js/./src/ints.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","arraymap","array","fn","length","newarray","splice","FatalError","Error","fatal","Comparable","cmp","MemberPtr","obj","val","debug","getLogger","EventState","EventType","ListDocumentModel","LogootInt","LogootPosition","InsertionEvent","body","start","rclk","type","INSERTION","undefined","last","next","state","PENDING","assign","eventnode","fromJSON","toJSON","offsetLowest","JSON","Schema","properties","RemovalEvent","removals","REMOVAL","map","items","Document","send","insertLocal","removeLocal","pending_events","_active_listeners","last_insertion_event","doc","event","index","indexOf","oldevent","_removePendingEvent","_tryMergeEvents","push","queue_send","SENDING","then","COMPLETE","catch","e","flagCancelled","data","retry_after_ms","warn","setTimeout","error","ldoc_bst","logoot_bst","removal_bst","position","text","ins","_pushEvent","event_contents","insertions","insertLogoot","forEach","offset","known_position","substr","removeLogoot","definition","noop","undefinedType","isIE","window","test","navigator","userAgent","logMethods","bindMethod","methodName","method","Function","apply","arguments","traceForIE","console","log","trace","replaceLoggingMethods","level","loggerName","methodFactory","enableLoggingWhenConsoleArrives","defaultMethodFactory","realMethod","Logger","defaultLevel","currentLevel","storageKey","getPersistedLevel","storedLevel","localStorage","ignore","cookie","document","location","encodeURIComponent","exec","slice","levels","getLevel","setLevel","persist","toUpperCase","SILENT","levelNum","levelName","persistLevelIfPossible","setDefaultLevel","enableAll","TRACE","disableAll","initialLevel","defaultLogger","_loggersByName","TypeError","logger","_log","noConflict","getLoggers","_mergeNode","bst","nstart","resolveConflict","addNode","informRemoval","nend","skip_ranges","getRange","sort","a","b","nodes_lesser","getLteq","lesser","includes","unshift","end","known_end_position","filter","clip_nstart","clip_nend","conflict","whole_node","result","sub","js_int","endnode","LogootNode","n_end_old","known_start","positions","lesser_pos","Math","min","node","newnodes","last_end","last_known_position","skip_range","cstart","equivalentPositionAtLevel","clamp","cend","Bst","vector_clock","len","nodes_greater","getGteq","greater","left_position","right_position","add","operateOnAllGteq","nodes","concat","cumulative_offset","newlen","newstart","remove","target_rclk","this_rclk","toString","info","pos","whole","newnode","insertion","new_rclk","stringify","BstNode","bst_root","gteqcmp","successor","setSuccessor","gtcmp","eqcmp","ptr","_getInorderSuccessor","left","right","endm1","operation","undef","operateOnAllRange","operateOnAllLteq","operateOnAll","str","Int32","inverseOffsetLowest","copy","done","itstart","values","itend","gteq","current","Array","fill","el","max","preserve_levels","clamped","IntType","super","int32","Int32Array","is_rclk"],"mappings":"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","file":"logootish-js.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"logootish-js\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"logootish-js\"] = factory();\n\telse\n\t\troot[\"logootish-js\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/**\n * @file Various utilities that don't belong anywhere else.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n\n/**\n * Like the built-in map function, but it replaces the element with an arbitrary\n * number of elements, making it a combination of map, push, and filter.\n * @template T - The type of the array elements.\n * @param array - The array to map. It will be modified.\n * @param fn - The element mapper function. It takes the current element as an\n * argument and returns the element(s) take its place.\n * @return The same array that was passed as an argument.\n */\nfunction arraymap<T>(array: T[], fn: (el: T) => T[]): T[] {\n  for (let i = 0; i < array.length; ) {\n    const newarray = fn(array[i])\n    array.splice(i, 1, ...newarray)\n    i += newarray.length ? newarray.length : 1\n  }\n  return array\n}\n\n/**\n * A class created with a variable `fatal` added and set to true. This is used\n * for ensuring that a client knows to shut down a document if an error has\n * indicated that the document is corrupt.\n */\nclass FatalError extends Error {\n  fatal = true\n}\n\n/**\n * One of zero, one, or negative one.\n */\ntype CompareResult = -1 | 0 | 1\n/**\n * A function type that takes `T` and returns a CompareResult.\n */\ntype CompareFunction<T> = (other: T) => CompareResult\n/**\n * A function type that takes two of a type `T` and returns a CompareResult.\n */\ntype DualCompareFunction<T> = (a: T, b: T) => CompareResult\n\n/**\n * A utility abstract class with no implementation for the function `cmp` and\n * implementations for `gt`, `gteq`, `eq`, `lteq`, and `lt` functions.\n * @template T The other type that can be compared.\n */\nabstract class Comparable<T> {\n  /**\n   * Compare this object to another one.\n   */\n  abstract cmp(other: T): CompareResult\n  /**\n   * @return True if this object is greater than the one provided.\n   */\n  gt(n: T): boolean {\n    return this.cmp(n) === 1\n  }\n  /**\n   * @return True if this object is greater than or equal to the one provided.\n   */\n  gteq(n: T): boolean {\n    return this.cmp(n) >= 0\n  }\n  /**\n   * @return True if this object is equal to the one provided.\n   */\n  eq(n: T): boolean {\n    return this.cmp(n) === 0\n  }\n  /**\n   * @return True if this object is less than or equal to the one provided.\n   */\n  lteq(n: T): boolean {\n    return this.cmp(n) <= 0\n  }\n  /**\n   * @return True if this object is less than the one provided.\n   */\n  lt(n: T): boolean {\n    return this.cmp(n) === -1\n  }\n}\n\n/**\n * Designed to emulate pointers to members of an object. This is useful inside\n * the B-trees. This should not be used like a C pointer: If the value in the\n * destination object changes, so does the value reported by this object.\n * @template T - The container object type.\n * @template K - The key inside the object.\n */\nclass MemberPtr<T, K extends keyof T> {\n  private obj: T\n  private key: K\n  /**\n   * @param obj - The object with the member to reference.\n   * @param key - The key of the reference inside the object.\n   */\n  constructor(obj: T, key: K) {\n    this.obj = obj\n    this.key = key\n  }\n  /**\n   * The value of the 'pointer.'\n   */\n  get value(): T[K] {\n    return this.obj[this.key]\n  }\n  set value(val: T[K]) {\n    this.obj[this.key] = val\n  }\n}\n\nexport {\n  arraymap,\n  FatalError,\n  CompareResult,\n  CompareFunction,\n  DualCompareFunction,\n  Comparable,\n  MemberPtr\n}\n","/**\n * @file Definition of the `debug` constant from `loglevel`.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport loglevel from 'loglevel'\n\nconst debug = loglevel.getLogger('logootish-js')\n\nexport { debug }\n","/**\n * @file This is the core of the Logootish algorithm. It contains all position\n * manipulation code.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { debug } from './debug'\nimport {\n  ListDocumentModel,\n  Removal,\n  LogootInt,\n  LogootPosition,\n  KnownPositionBst,\n  LogootBst\n} from './listmodel'\n\nenum EventState {\n  /**\n   * Not being actively sent and can be modified.\n   */\n  PENDING,\n  /**\n   * In transit. Cannot be modified.\n   */\n  SENDING,\n  /**\n   * Already sent. Also cannot be modified.\n   */\n  COMPLETE\n}\n/**\n * @deprecated in favor of typeof statements, but I've been meaning to remove\n * code dependent on this for a few versions now.\n * @TODO Fix me\n */\nenum EventType {\n  INSERTION,\n  REMOVAL\n}\n\n/**\n * Generic event interface.\n */\ninterface LogootEvent {\n  type: EventType\n  state: EventState\n  // eslint-disable-next-line\n  toJSON(): any\n  rclk: LogootInt\n}\n\n/**\n * An event sent when text is added, which contains a body and start position.\n */\nclass InsertionEvent implements LogootEvent {\n  type = EventType.INSERTION\n  body = ''\n  start?: LogootPosition = undefined\n  rclk = new LogootInt()\n\n  // Previous & next insertion event\n  last: InsertionEvent = undefined\n  next: InsertionEvent = undefined\n\n  state = EventState.PENDING\n\n  constructor(body: string, start = new LogootPosition(), rclk?: LogootInt) {\n    Object.assign(this, {\n      body,\n      start,\n      rclk: new LogootInt(rclk)\n    })\n  }\n\n  static fromJSON(eventnode: InsertionEvent.JSON): InsertionEvent {\n    return new InsertionEvent(\n      eventnode.body,\n      LogootPosition.fromJSON(eventnode.start),\n      LogootInt.fromJSON(eventnode.rclk)\n    )\n  }\n  toJSON(): InsertionEvent.JSON {\n    return {\n      body: this.body,\n      start: this.start.toJSON(),\n      rclk: this.rclk.toJSON()\n    }\n  }\n\n  get length(): number {\n    return this.body.length\n  }\n  get end(): LogootPosition {\n    return this.start.offsetLowest(this.length)\n  }\n}\nnamespace InsertionEvent {\n  export type JSON = {\n    body: string\n    start: LogootPosition.JSON\n    rclk: LogootInt.JSON\n  }\n  export namespace JSON {\n    export const Schema = {\n      type: 'object',\n      properties: {\n        body: { type: 'string' },\n        start: LogootPosition.JSON.Schema,\n        rclk: LogootInt.JSON.Schema\n      }\n    }\n  }\n}\n\ntype RemovalJSON = { start: LogootPosition.JSON; length: number }\n/**\n * An event sent when text is removed, which contains an array of start\n * positions and lengths. An array was chosen since it is preferred for one\n * operation to translate to one event. In an insertion, this is easy since\n * there is just a start and body. However, a removal might remove areas of text\n * that are on different levels and could generate many events.\n */\nclass RemovalEvent implements LogootEvent {\n  type = EventType.REMOVAL\n  removals: Removal[] = []\n  rclk: LogootInt\n\n  state = EventState.PENDING\n\n  constructor(removals: Removal[], rclk?: LogootInt) {\n    this.removals = removals\n    this.rclk = new LogootInt(rclk)\n  }\n\n  static fromJSON(eventnode: RemovalEvent.JSON): RemovalEvent {\n    return new RemovalEvent(\n      eventnode.removals.map((r) => ({\n        start: LogootPosition.fromJSON(r.start),\n        length: r.length\n      })),\n      LogootInt.fromJSON(eventnode.rclk)\n    )\n  }\n  toJSON(): RemovalEvent.JSON {\n    return {\n      removals: this.removals.map((r) => ({\n        start: r.start.toJSON(),\n        length: r.length\n      })),\n      rclk: this.rclk.toJSON()\n    }\n  }\n}\nnamespace RemovalEvent {\n  export type JSON = { removals: RemovalJSON[]; rclk: LogootInt.JSON }\n  export namespace JSON {\n    export const Schema = {\n      type: 'object',\n      properties: {\n        removals: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              start: LogootPosition.JSON.Schema,\n              length: { type: 'number' }\n            }\n          }\n        },\n        rclk: LogootInt.JSON.Schema\n      }\n    }\n  }\n}\n\n/**\n * Exists only for backwards compatability.\n * @deprecated Will be removed in next minor version bump. Semver allows this\n * when the major version is 0.\n * @TODO Remove this class. Create an event bus system.\n */\nclass Document {\n  /** Events that need to get sent over Matrix */\n  pending_events: LogootEvent[] = []\n\n  /**\n   * Used to keep track of active EventEmitter listeners having anything to do\n   * with this document\n   * @deprecated it shouldn't be here and is temporary\n   * @todo Move this to matrix-notepad\n   */\n  _active_listeners: any[] = []\n\n  private send: (e: LogootEvent) => Promise<any>\n\n  private insertLocal: (position: number, body: string) => void\n  private removeLocal: (position: number, length: number) => void\n\n  last_insertion_event: InsertionEvent = undefined\n\n  doc: ListDocumentModel = new ListDocumentModel()\n\n  /**\n   * @param send - A callback function to send a LogootEvent\n   * @param insertLocal - A callback function to insert text\n   * @param removeLocal - A callback function to remove text\n   */\n  constructor(\n    send: (e: LogootEvent) => Promise<any>,\n    insertLocal: (position: number, body: string) => void,\n    removeLocal: (position: number, length: number) => void\n  ) {\n    this.send = send\n    this.insertLocal = insertLocal\n    this.removeLocal = removeLocal\n  }\n\n  /**\n   * Remove an event from the pending event array\n   */\n  private _removePendingEvent(event: LogootEvent): boolean {\n    const index = this.pending_events.indexOf(event)\n    if (index >= 0) {\n      this.pending_events.splice(index, 1)\n      return true\n    }\n    return false\n  }\n  /**\n   * Merge an event with other neighboring ones\n   */\n  private _tryMergeEvents(event: InsertionEvent): boolean {\n    if (event.state !== EventState.PENDING) {\n      return false\n    }\n    // TODO: Maybe do a tree lookup instead. But this is complicated since then\n    // each node has to store its associated event\n    if (event.last && event.last.state === EventState.PENDING) {\n      let oldevent = event\n      while (oldevent.last && oldevent.last.state === EventState.PENDING) {\n        oldevent.last.body += oldevent.body\n\n        oldevent.last.next = oldevent.next\n        if (oldevent.next) {\n          oldevent.next.last = oldevent.last\n        }\n\n        this._removePendingEvent(oldevent)\n\n        if (this.last_insertion_event === oldevent) {\n          this.last_insertion_event = oldevent.last\n        }\n        oldevent = oldevent.last\n      }\n      // Now try the other direction...\n      this._tryMergeEvents(oldevent)\n      return true\n    } else if (event.next && event.next.state === EventState.PENDING) {\n      let oldevent = event\n      while (oldevent.next && oldevent.next.state === EventState.PENDING) {\n        oldevent.next.body = oldevent.body + oldevent.next.body\n        oldevent.next.start = oldevent.start\n\n        oldevent.next.last = oldevent.last\n        if (oldevent.last) {\n          oldevent.last.next = oldevent.next\n        }\n\n        this._removePendingEvent(oldevent)\n\n        if (this.last_insertion_event === oldevent) {\n          this.last_insertion_event = oldevent.next\n        }\n        oldevent = oldevent.next\n      }\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Send a `LogootEvent` using the document-specific logic.\n   */\n  private _pushEvent(event: LogootEvent): void {\n    this.pending_events.push(event)\n\n    const queue_send = (): void => {\n      event.state = EventState.SENDING\n      this.send(event)\n        .then(() => {\n          this._removePendingEvent(event)\n          event.state = EventState.COMPLETE\n        })\n        .catch((e) => {\n          event.state = EventState.PENDING\n          // TODO: Nothing is here *should* be Matrix specific\n          if (e.event) {\n            e.event.flagCancelled()\n          }\n          if (e && e.data && e.data.retry_after_ms) {\n            if (\n              event.type === EventType.INSERTION &&\n              this._tryMergeEvents(event as InsertionEvent)\n            ) {\n              debug.warn(\n                `Hitting the rate limit: Will resend in ${e.data.retry_after_ms} ms with multiple messages merged together`\n              )\n              return {}\n            }\n            debug.warn(\n              `Hitting the rate limit: Will resend in ${e.data.retry_after_ms} ms`\n            )\n            setTimeout(queue_send, e.data.retry_after_ms)\n          } else {\n            debug.error('Error sending event', e)\n            return e\n          }\n        })\n    }\n    queue_send()\n  }\n\n  get ldoc_bst(): KnownPositionBst {\n    return this.ldoc_bst\n  }\n  get logoot_bst(): LogootBst {\n    return this.logoot_bst\n  }\n  get removal_bst(): LogootBst {\n    return this.removal_bst\n  }\n\n  /**\n   * Inform the document of new text in the local text copy. This will call the\n   * `send` function with the resulting event.\n   * @param position - The index of new text\n   * @param text - The text that will be inserted\n   */\n  insert(position: number, text: string): void {\n    const ins = this.doc.insertLocal(position, text.length)\n    this._pushEvent(new InsertionEvent(text, ins.position, ins.rclk))\n  }\n  /**\n   * Inform the document of removed text in the local text copy. This will call\n   * the `send` function with the resulting event.\n   * @param position - The index of old text\n   * @param length - The length text that will be removed\n   */\n  remove(position: number, length: number): void {\n    const { removals, rclk } = this.doc.removeLocal(position, length)\n    this._pushEvent(new RemovalEvent(removals, rclk))\n  }\n  /**\n   * Inform the document of an incoming event from remote documents. The\n   * function `insertLocal` will be called based on the results of this.\n   * @param event_contents - The raw incoming JSON\n   */\n  remoteInsert(event_contents: InsertionEvent.JSON): void {\n    const { body, start, rclk } = InsertionEvent.fromJSON(event_contents)\n    const { insertions } = this.doc.insertLogoot(start, body.length, rclk)\n    insertions.forEach(({ offset, length, known_position }) =>\n      this.insertLocal(known_position, body.substr(offset, length))\n    )\n  }\n  /**\n   * Inform the document of an incoming event from remote documents. The\n   * function `removeLocal` will be called based on the results of this.\n   * @param event_contents - The raw incoming JSON\n   */\n  remoteRemove(event_contents: RemovalEvent.JSON): void {\n    const { rclk, removals } = RemovalEvent.fromJSON(event_contents)\n    removals.forEach(({ start, length }) => {\n      const { removals } = this.doc.removeLogoot(start, length, rclk)\n      removals.forEach(({ known_position, length }) =>\n        this.removeLocal(known_position, length)\n      )\n    })\n  }\n}\n\nexport {\n  EventType,\n  EventState,\n  ListDocumentModel,\n  InsertionEvent,\n  RemovalEvent,\n  LogootInt,\n  LogootPosition,\n  Document\n}\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n","import { arraymap, FatalError, CompareResult } from '../utils'\nimport { debug } from '../debug'\nimport { Bst } from '../bst'\n\nimport {\n  LogootInt,\n  LogootPosition,\n  LogootNode,\n  LogootNodeWithMeta\n} from './logoot'\n\ntype Removal = { start: LogootPosition; length: number }\n\ntype KnownPositionBst = Bst<LogootNode, { known_position: number }>\ntype LogootBst = Bst<LogootNode, { start: LogootPosition }>\n\ntype Conflict = {\n  start: LogootPosition\n  end: LogootPosition\n  clip_nstart: boolean\n  clip_nend: boolean\n  whole_node: boolean\n  level: number\n}\n\n/**\n * This is possibly the most important function in this entire program. The\n * role of this function is to determine which parts of a node will have\n * precedence over nodes currently in a Logoot binary search tree. Any new\n * node must be filtered to determine which parts can actually make it into\n * the document. For example, if there is a node with a higher `rclk`\n * currently in the BST, that portion that overlaps with the node must be cut\n * out. If the reverse is true, the node must be removed. This is done by\n * first filtering the nodes in the region in question using a user-defined\n * priority function. Nodes are either kept, ignored, or removed. These nodes\n * are then used as regions of the input to skip over (variable named\n * `skip_ranges`) and the resulting node(s) are returned.\n *\n * @param bst - The binary search tree containing current nodes to consider\n * @param nstart - The start of the region in question\n * @param length - The length of the region in question\n * @param resolveConflict - A callback function determining what happens to a\n * node currently in the BST in the region in question. If it returns 1, the\n * node is kept. If it is 0, the node is ignored and is not skipped over. If\n * it is -1, the section in question of the node is removed and the\n * `informRemoval` function is called so further removals can be performed.\n * @param addNode - A function only called when a node is split into pieces\n * and additional nodes must be added as side-effects of the operation.\n * @param informRemoval - A function to be called when a section or all of a\n * node is removed so that the caller can modify the document as necessary.\n */\nfunction _mergeNode(\n  bst: LogootBst,\n  nstart: LogootPosition,\n  length: number,\n  resolveConflict: (\n    node: LogootNode,\n    conflict: Conflict,\n    lesser: LogootNode\n  ) => CompareResult,\n  addNode: (node: LogootNode) => void,\n  informRemoval: (\n    node: LogootNode,\n    pos: number,\n    length: number,\n    whole: boolean\n  ) => void\n): LogootNodeWithMeta[] {\n  const level = nstart.levels\n  const nend = nstart.offsetLowest(length)\n\n  // These ranges are areas of the document that are already populated in the\n  // region where the insert is happening. If there are conflicts, they will be\n  // skipped. The end of this new insert must be added to the end as a fake\n  // zero-length node so that the for each loop triggers for the end.\n  let skip_ranges = bst\n    .getRange({ start: nstart }, { start: nend })\n    .map(({ data }) => data)\n    .sort((a, b) => a.start.cmp(b.start))\n\n  const nodes_lesser = bst.getLteq({ start: nstart })\n  let lesser: LogootNode\n  if (nodes_lesser.length > 1) {\n    throw new FatalError('Corrupt BST. There are multiple nodes at a position.')\n  } else if (nodes_lesser.length) {\n    lesser = nodes_lesser[0].data\n  }\n\n  // Ensure that lesser is initially defined as a skip_range (this is useful for\n  // some removals that may want to use conflicts with lesser\n  if (lesser && !skip_ranges.includes(lesser)) {\n    skip_ranges.unshift(lesser)\n  }\n  // It's fine that known_position is invalid because that would only impact\n  // nodes AFTER this one (whose calculations depend upon it)\n  skip_ranges.push({\n    start: nend,\n    end: nend,\n    length: 0,\n    known_position: 0,\n    known_end_position: 0,\n    rclk: new LogootInt(0)\n  })\n\n  skip_ranges = skip_ranges.filter((n) => {\n    if (n.length && n.start.levels === level) {\n      const clip_nstart = nstart.cmp(n.start) > 0\n      const clip_nend = nend.cmp(n.end) < 0\n      const start = clip_nstart ? nstart : n.start\n      const end = clip_nend ? nend : n.end\n      if (start.cmp(end) === 0) {\n        return true\n      }\n      const conflict = {\n        start,\n        end,\n        clip_nstart,\n        clip_nend,\n        whole_node: !(clip_nstart || clip_nend),\n        level\n      }\n\n      // Get the externally defined result for this conflict\n      const result = resolveConflict(n, conflict, lesser)\n\n      // Actually remove the node or part of it if it looses\n      if (result < 1) {\n        if (result < 0) {\n          // Shortcut to remove the whole node\n          if (conflict.whole_node) {\n            informRemoval(n, n.known_position, n.length, true)\n            n.length = 0\n          } else {\n            // Find the length of the middle region of the node\n            // nnnnnRRRRnnnn <- Where the 'R' is (l=4 in this case)\n            const l = new LogootInt(end.l(level)).sub(start.l(level)).js_int\n\n            // Make a copy because we will need to modify the original\n            const endnode = new LogootNode(n)\n            endnode.start = end\n            const n_end_old = n.end.offsetLowest(0)\n\n            if (clip_nstart) {\n              // This means we're dealing with an area ahead of the node with a\n              // length > 0:\n              // NNNNrrrrrnnnnn (As above, 'r' is the section of the node being\n              // removed)\n              n.length = new LogootInt(start.l(level)).sub(\n                n.start.l(level)\n              ).js_int\n\n              endnode.known_position += n.length\n              endnode.start.offsetLowest(n.known_position + n.length + l)\n              informRemoval(n, n.known_position + n.length, l, n.length <= 0)\n            } else {\n              // The removal must be right up against the edge of the node,\n              // so we can take an easy shortcut:\n              // RRRRnnnnnn\n              informRemoval(n, n.known_position, l, true)\n              endnode.start.offsetLowest(n.known_position + l)\n            }\n            if (clip_nend) {\n              // Ok, so now we have to add a new node to account for the\n              // trailing end portion: [nnnn]rrrrNNNNN <- that\n              // We also have to re-add it to the BSTs because they are sorted\n              // by start position, so if we modify the start, we could break\n              // the sorting\n              endnode.length = new LogootInt(n_end_old.l(level)).sub(\n                end.l(level)\n              ).js_int\n              if (endnode.length > 0) {\n                addNode(endnode)\n              }\n            }\n          }\n        }\n        return false\n      }\n    }\n    return true\n  })\n\n  let known_start = 0\n  if (lesser) {\n    const positions = [lesser.length]\n    // Find where we are inside lesser. If we're outside of lesser, this will be\n    // greater than lesser's length and will be ignored\n    if (lesser.start.levels < nstart.levels) {\n      positions.push(\n        new LogootInt(nstart.l(lesser.start.levels)).sub(\n          lesser.start.l(lesser.start.levels)\n        ).js_int\n      )\n    }\n\n    // Figure out which endpoint to use, the end of lesser or where our position\n    // is if its inside lesser\n    const lesser_pos = Math.min(...positions)\n    known_start = lesser.known_position + lesser_pos\n\n    // Split lesser in two if necessary\n    if (lesser.length - lesser_pos) {\n      const node = new LogootNode(lesser)\n      node.start = node.start.offsetLowest(lesser_pos)\n      node.length -= lesser_pos\n      node.known_position += lesser_pos\n      addNode(node)\n\n      lesser.length = lesser_pos\n    }\n  }\n\n  const newnodes: LogootNodeWithMeta[] = []\n  // We fake the last node end to be the start of the new node because the\n  // inserted text always needs to 'snap' to the end of the last node,\n  // regardless of discontinuities in Logoot positions\n  let last_end = nstart\n  let last_known_position = known_start\n  skip_ranges.forEach((skip_range) => {\n    const { start, end, length } = skip_range\n    // Clamped regions to consider. Anything outside of the node to be inserted\n    // doesn't matter, so we clamp it out\n    // Of course, that means we have to recalculate EVERYTHING *sigh*\n    const cstart = start.equivalentPositionAtLevel(level).clamp(nstart, nend)\n    const cend = end.equivalentPositionAtLevel(level).clamp(nstart, nend)\n\n    // Now, find the offset in our body string\n    const offset = new LogootInt(last_end.l(level)).sub(nstart.l(level)).js_int\n\n    const node: LogootNodeWithMeta = Object.assign(new LogootNode(), {\n      offset\n    })\n    // Find the new node length by finding the distance between the last end\n    // and the next one\n    node.length = new LogootInt(cstart.l(level)).sub(last_end.l(level)).js_int\n\n    if (node.length <= 0) {\n      last_end = cend\n      if (skip_range !== lesser) {\n        last_known_position += length\n      }\n      return\n    }\n\n    node.start = nstart.offsetLowest(offset)\n    node.known_position = last_known_position\n\n    newnodes.push(node)\n\n    last_end = cend\n    last_known_position += node.length\n    if (skip_range !== lesser) {\n      // When incrementing the known_position, we ALWAYS use the length of the\n      // whole node since we will have to skip over the node regardless of how\n      // much of it actually concerns the node being added\n      // For example, if we're adding a node around an existing node with a\n      // greater number of levels, it will have the length of zero on our\n      // current level (because it is between two positions), but we still\n      // MUST skip over its entire non-zero length\n      last_known_position += length\n    }\n  })\n  return newnodes\n}\n\n/**\n * A representation of the Logootish Document Model for mapping \"real,\"\n * continuous `known_position`s to Logoot positions. This is useful when working\n * with strings, arrays, or, just in general, anything that needs a fixed order.\n * This does not actually store the data in question, but stores a mapping of\n * real indices in the data to the Logoot positions of that element. This is\n * used to transform edits between ones in the Logoot and local position spaces.\n * One important thing to note: Logoot edits (insertions/removals) can be\n * applied in any order. Local edits **must** be applied in a consistent order.\n * @TODO Conflict resolution does not exist. **This will create significant\n * changes to this API**\n */\nclass ListDocumentModel {\n  /**\n   * The BST maps out where all insertion nodes are in the local document's\n   * memory. It is used to go from position -> node\n   */\n  ldoc_bst: KnownPositionBst = new Bst(\n    (a, b) => (a.known_position - b.known_position) as CompareResult\n  )\n  /**\n   * This BST maps Logoot position identifiers to their text node to allow\n   * lookup of text position from Logoot ID\n   */\n  logoot_bst: LogootBst = new Bst((a, b) => a.start.cmp(b.start))\n  /** A map of removals that do not yet have text to remove */\n  removal_bst: LogootBst = new Bst((a, b) => a.start.cmp(b.start))\n  /**\n   * See the Logoot paper for why. Unlike the Logoot implementation, this is\n   * incremented with each removal only and is kept constant with insertions.\n   */\n  vector_clock = new LogootInt()\n\n  /**\n   * Calculate the Logoot positions of a local insertion.\n   * @param position - The index of new text\n   * @param len - How much will be inserted\n   * @returns A Logoot insertion with a Logoot position (`start`), a vector\n   * clock value (`rclk`) (**copied** from the document), and the length passed\n   * to the function (`length`). Note that the start position is **not** copied,\n   * so if it is modified, it will mess up the sorting trees. Ensure that it is\n   * copied before modifying it.\n   * @throws {FatalError} Will throw in the event that internal corruption is\n   * encountered. If this happens, please submit an issue.\n   * @throws {Error} Will throw in the event that the position being inserted is\n   * after the end of the known document model.\n   */\n  insertLocal(\n    position: number,\n    len: number\n  ): { position: LogootPosition; rclk: LogootInt; length: number } {\n    debug.debug(`Insert into doc at ${position} + ${len}`)\n\n    // The position must be -1 for lesser because it can't count the text node\n    // currently in the insertion position (we're between two nodes)\n    const nodes_lesser = this.ldoc_bst.getLteq({ known_position: position - 1 })\n    const nodes_greater = this.ldoc_bst.getGteq({ known_position: position })\n\n    let lesser\n    let greater\n\n    // Nodes are not allowed to have the same position\n    if (nodes_lesser.length > 1 || nodes_greater.length > 1) {\n      throw new FatalError(\n        'Corrupt BST. There are multiple nodes at a position.'\n      )\n    } else {\n      lesser = nodes_lesser[0] ? nodes_lesser[0].data : undefined\n      greater = nodes_greater[0] ? nodes_greater[0].data : undefined\n    }\n\n    if (lesser && lesser.known_end_position < position) {\n      throw new Error('Position cannot be added after the end of the document.')\n    }\n\n    if (lesser && lesser.length + lesser.known_position > position) {\n      // This means that we're right inside another node, so the next position\n      // will be inside the first node\n      // Now, we must split the node in half (nodes can't overlap)\n      greater = new LogootNode()\n\n      greater.length = lesser.known_end_position - position\n      lesser.length = position - lesser.known_position\n\n      greater.known_position = position\n      greater.start = lesser.start.offsetLowest(lesser.length)\n      greater.rclk = new LogootInt(lesser.rclk)\n\n      this.ldoc_bst.add(greater)\n      this.logoot_bst.add(greater)\n    }\n\n    // Finally, we can create positions...\n    let left_position\n    let right_position\n\n    if (lesser) {\n      left_position = lesser.end\n    }\n    if (greater) {\n      right_position = greater.start\n    }\n\n    const node = new LogootNode()\n    node.start = new LogootPosition(len, left_position, right_position)\n    node.known_position = position\n    node.rclk = new LogootInt(this.vector_clock)\n    node.length = len\n\n    // Now, make a space between the nodes\n    this.ldoc_bst.operateOnAllGteq({ known_position: position }, (n) => {\n      n.data.known_position += len\n    })\n\n    this.ldoc_bst.add(node)\n    this.logoot_bst.add(node)\n\n    return {\n      position: node.start,\n      rclk: new LogootInt(this.vector_clock),\n      length: len\n    }\n  }\n\n  /**\n   * Calculate the Logoot positions and lengths of removals from a removal in\n   * the local document.\n   * @param position - The index of old text\n   * @param length - The length text that will be removed\n   * @returns An object containing an array of removals and the calculated\n   * vector clock. Each removal contains a `start` LogootPosition, which is not\n   * copied, so it **cannot be modified**, and a numeric `length`.\n   */\n  removeLocal(\n    position: number,\n    length: number\n  ): { removals: Removal[]; rclk: LogootInt } {\n    debug.debug(`Remove from doc at ${position} + ${length}`)\n\n    // First, find any nodes that MAY have content removed from them\n    const nodes = this.ldoc_bst\n      .getRange(\n        { known_position: position },\n        { known_position: position + length - 1 }\n      )\n      .concat(this.ldoc_bst.getLteq({ known_position: position - 1 }))\n      .sort((a, b) => a.data.known_position - b.data.known_position)\n\n    const removals: Removal[] = []\n    let last_end: LogootPosition\n    let cumulative_offset = 0\n    nodes.forEach(({ data }) => {\n      // 'Data' refers to the node having text removed\n\n      // Length and start of new removal\n      let newlen = data.length\n      let newstart = data.start\n\n      // Remove the ends of the node not being removed\n      if (data.known_position < position) {\n        newlen -= position - data.known_position\n        newstart = newstart.offsetLowest(position - data.known_position)\n      }\n      if (data.known_position + data.length > position + length) {\n        newlen -= data.known_position + data.length - (position + length)\n      }\n\n      if (newlen <= 0) {\n        return\n      }\n\n      // Add the removal to the last one if possible\n      if (last_end && last_end.cmp(newstart) === 0) {\n        removals[removals.length - 1].length += newlen\n      } else {\n        removals.push({\n          start: newstart,\n          length: newlen\n        })\n      }\n\n      // Record the last end so we can add another removal to it if possible\n      last_end = newstart.offsetLowest(newlen)\n\n      // Now, modify the node to remove the start region (if necessary)\n      if (data.known_position > position) {\n        data.start = data.start.offsetLowest(data.known_position - position)\n      }\n      // And remove the removal inside of it\n      data.length -= newlen\n\n      // Now apply the running total offset and calculate it for the next run\n      data.known_position -= cumulative_offset\n      cumulative_offset += newlen\n\n      if (data.length <= 0) {\n        this.logoot_bst.remove(data)\n        this.ldoc_bst.remove(data)\n      }\n    })\n\n    // Offset the nodes that come after the removal\n    this.ldoc_bst.operateOnAllGteq(\n      { known_position: position + length },\n      (n) => {\n        n.data.known_position -= length\n      }\n    )\n\n    const target_rclk = new LogootInt(this.vector_clock)\n    this.vector_clock.add(1)\n\n    return { removals, rclk: target_rclk }\n  }\n\n  /**\n   * Calculate the local positions inserted from an insertion at a Logoot\n   * position from a given length and vector clock.\n   * @param nstart - The start `LogootPosition` of the insertion\n   * @param length - The length of the insertion\n   * @param this_rclk - The vector clock when the insertion took place.\n   * @returns An object with the `insertions` member set to an array with\n   * objects containing a numeric `offset`, which represents which part of the\n   * source string the insertion is pulling from, a numeric `length`, and a\n   * numeric `known_position` where to place the string. Insertions must be\n   * applied in the order of the return value. The object also has a `removals`\n   * variable set to an array of objects containing `known_position` and\n   * `length` that represent removed conflicts with existing data. These\n   * `removals` should be applied before the `insertions`.\n   */\n  insertLogoot(\n    nstart: LogootPosition,\n    length: number,\n    this_rclk: LogootInt\n  ): {\n    insertions: { offset: number; length: number; known_position: number }[]\n    removals: { known_position: number; length: number }[]\n  } {\n    debug.debug(\n      `Insert into doc at ${nstart.toString()} + ${length} @ ${this_rclk.toString()}`\n    )\n\n    if (this_rclk.cmp(this.vector_clock) > 0) {\n      this.vector_clock.assign(this_rclk)\n      debug.info(`Fast-forward vector clock to ${this_rclk.toString()}`)\n    }\n\n    const removals: { known_position: number; length: number }[] = []\n    const nodes = _mergeNode(\n      this.logoot_bst,\n      nstart,\n      length,\n      (node, conflict, lesser) => {\n        // If we're inside and on a lower level than lesser, simply ignore it\n        if (node === lesser && lesser.start.levels < conflict.level) {\n          return 0\n        }\n        if (node.rclk.cmp(this_rclk) < 0) {\n          return -1\n        }\n        if (node.rclk.cmp(this_rclk) === 0) {\n          // TODO: Do something about conflicts that cause dropped data here\n          // This is HUGE and the editor WILL NOT FUNCTION WITHOUT IT!!!\n          // I really don't like the idea of pushing this until after initial\n          // release, but oh well.\n          // Also, does this even work?\n          debug.info('Dropped conflicting node')\n        }\n        return 1\n      },\n      (node) => {\n        // We don't add to the known_position here because the node we're adding\n        // comes from splitting an existing node\n        this.ldoc_bst.add(node)\n        this.logoot_bst.add(node)\n      },\n      (node, pos, length, whole) => {\n        if (whole) {\n          this.ldoc_bst.remove(node)\n          this.logoot_bst.remove(node)\n        }\n        removals.push({ known_position: pos, length })\n        // this.removeLocal(pos, length)\n        this.ldoc_bst.operateOnAllGteq({ known_position: pos }, (n) => {\n          if (n.data === node) {\n            return\n          }\n          n.data.known_position -= length\n        })\n      }\n    )\n\n    arraymap(nodes, (node) => {\n      let last_known_position = node.known_position\n      return _mergeNode(\n        this.removal_bst,\n        node.start,\n        node.length,\n        (node) => {\n          if (node.rclk.cmp(this_rclk) < 0) {\n            return 0\n          }\n          return 1\n        },\n        () => {},\n        () => {}\n      ).map((newnode) => {\n        // known_positions in the removal tree are BS, so set them correctly\n        // here. TODO: Remove known_position from removals\n        newnode.known_position = last_known_position\n        newnode.offset += node.offset\n        last_known_position += newnode.length\n        return newnode\n      })\n    })\n\n    const insertions: {\n      offset: number\n      length: number\n      known_position: number\n    }[] = []\n\n    nodes.forEach((node) => {\n      node.rclk = new LogootInt(this_rclk)\n      // Now, make a space between the nodes\n      this.ldoc_bst.operateOnAllGteq(node, (n) => {\n        if (n.data === node) {\n          return\n        }\n        n.data.known_position += node.length\n      })\n\n      const insertion = {\n        known_position: node.known_position,\n        offset: node.offset,\n        length: node.length\n      }\n      insertions.push(insertion)\n\n      this.ldoc_bst.add(node)\n      this.logoot_bst.add(node)\n    })\n\n    return { insertions, removals }\n  }\n\n  /**\n   * Calculate the regions of text to be removed from the local document from\n   * a Logoot position, length, and vector clock of a removal.\n   * @param start - The start at which to start removing.\n   * @param length - How much to remove.\n   * @param rclk - The vector clock of the removal.\n   * @returns An object containing a member `removals`, which is an array of\n   * objects containing a `known_position` at which to start removing and a\n   * `length`, both of which are numbers.\n   */\n  removeLogoot(\n    start: LogootPosition,\n    length: number,\n    rclk: LogootInt\n  ): { removals: { known_position: number; length: number }[] } {\n    const new_rclk = new LogootInt(rclk).add(1)\n    if (new_rclk.cmp(this.vector_clock) > 0) {\n      this.vector_clock.assign(new_rclk)\n      debug.info('Fast-forward vector clock to', JSON.stringify(new_rclk))\n    }\n\n    const end = start.offsetLowest(length)\n    // The level where our removal is happening (always the lowest)\n    const level = start.levels\n    debug.debug(\n      `Remove from doc at ${start.toString()} + ${length} @ ${rclk.toString()}`\n    )\n\n    const removals: { known_position: number; length: number }[] = []\n    // This is basically the same as the invocation in remoteInsert, only it\n    // doesn't add the resulting nodes to the BSTs\n    const nodes = _mergeNode(\n      this.logoot_bst,\n      start,\n      length,\n      (node) => {\n        // TODO: Nodes with the SAME `rclk` should still have a removal added\n        // at their position because another node with the same `rclk` as the\n        // one just removed could show up.\n        if (node.rclk.cmp(rclk) <= 0) {\n          return -1\n        }\n        return 1\n      },\n      (node) => {\n        this.ldoc_bst.add(node)\n        this.logoot_bst.add(node)\n      },\n      (node, pos, length, whole) => {\n        if (whole) {\n          this.ldoc_bst.remove(node)\n          this.logoot_bst.remove(node)\n        }\n        removals.push({ known_position: pos, length })\n        this.ldoc_bst.operateOnAllGteq({ known_position: pos }, (n) => {\n          if (n.data === node) {\n            return\n          }\n          n.data.known_position -= length\n        })\n      }\n    )\n\n    // Now, use the text nodes that stay as `skip_ranges`, like in the\n    // `_mergeNode` function, to find where the removal should be added to the\n    // removal BST\n    nodes.push({\n      start: end,\n      end,\n      length: 0,\n      known_position: 0,\n      known_end_position: 0,\n      rclk: new LogootInt(),\n      offset: 0\n    })\n\n    // I've gotten lazier and lazier with variable names as this file has\n    // gotten longer. I've regressed to single letter variable names\n    let last_end = start\n    nodes.forEach((n) => {\n      const length = new LogootInt(n.end.l(level)).sub(last_end.l(level)).js_int\n      // Now, merge this removal with possible other ones in the removal_bst\n      const nodes = _mergeNode(\n        this.removal_bst,\n        last_end,\n        length,\n        (node) => {\n          if (node.rclk.cmp(rclk) < 0) {\n            return -1\n          }\n          return 1\n        },\n        (node) => {\n          this.removal_bst.add(node)\n        },\n        (node, pos, length, whole) => {\n          if (whole) {\n            this.removal_bst.remove(node)\n          }\n        }\n      )\n\n      // Make sure the removals actually exist\n      nodes.forEach((node) => {\n        node.rclk = rclk\n        delete node.offset\n\n        this.removal_bst.add(node)\n      })\n      last_end = n.end\n    })\n\n    return { removals }\n  }\n}\n\nexport {\n  LogootInt,\n  LogootPosition,\n  KnownPositionBst,\n  LogootBst,\n  Removal,\n  ListDocumentModel,\n  _mergeNode\n}\n","/**\n * @file A binary search tree implementation for finding ranges within the tree\n * and finding neighboring nodes.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { DualCompareFunction, MemberPtr } from './utils'\n\n/**\n * The node type used by the binary search tree\n */\nclass BstNode<T> {\n  /**\n   * The data contained in the node.\n   */\n  data: T\n  left: BstNode<T> | undefined\n  right: BstNode<T> | undefined\n  constructor(data: T) {\n    this.data = data\n  }\n}\n\n/**\n * The pointer type either to a leaf of the BST or the root. By using\n * `MemberPtr`, methods in the BST can re-assign the node value simply through\n * this 'pointer' object.\n */\ntype BstNodePtr<T> =\n  | MemberPtr<BstNode<T>, 'left'>\n  | MemberPtr<BstNode<T>, 'right'>\n  // eslint-disable-next-line\n  | MemberPtr<Bst<T, any>, 'bst_root'>\n/**\n * The type of a function that operates on nodes of the BST.\n */\ntype NodeOp<T> = (node: BstNode<T>) => void\n\n/**\n * A binary search tree implementation for finding ranges within the tree and\n * finding neighboring nodes.\n * @template T - The type stored in the tree.\n * @template S - The type used by search functions, but that cannot be added to\n * the tree. It defaults to `T`.\n */\nclass Bst<T extends S, S = T> {\n  bst_root: BstNode<T> | undefined = undefined\n  readonly cmp: DualCompareFunction<S>\n\n  /**\n   * @param cmp - The compare function to use to sort the tree.\n   */\n  constructor(cmp: DualCompareFunction<S>) {\n    this.cmp = cmp\n  }\n\n  gteqcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) >= 0\n  }\n  gtcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) > 0\n  }\n  eqcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) === 0\n  }\n\n  /**\n   * Add an element to the tree.\n   * @param object - The object to add to the tree.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  add(object: T, node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')): void {\n    if (!node.value) {\n      node.value = new BstNode(object)\n    } else if (this.gteqcmp(node.value.data, object)) {\n      this.add(object, new MemberPtr(node.value, 'left'))\n    } else {\n      this.add(object, new MemberPtr(node.value, 'right'))\n    }\n  }\n\n  /**\n   * A method designed mostly for internal use that finds the next element in\n   * the tree if all of the elements were placed in order.\n   * @param object - The object or search type to find the successor of\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  _getInorderSuccessor(\n    object: S,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): { ptr: BstNodePtr<T>; data: T } | undefined {\n    type SuccessorType = { ptr: BstNodePtr<T>; data: T } | undefined\n    let successor: SuccessorType\n    const setSuccessor = (s: SuccessorType): void => {\n      if (!successor || (s && this.gtcmp(successor.data, s.data))) {\n        successor = s\n      }\n    }\n    if (node.value) {\n      if (this.gteqcmp(node.value.data, object)) {\n        if (!this.eqcmp(node.value.data, object)) {\n          setSuccessor({ ptr: node, data: node.value.data })\n        }\n        setSuccessor(\n          this._getInorderSuccessor(object, new MemberPtr(node.value, 'left'))\n        )\n      }\n      setSuccessor(\n        this._getInorderSuccessor(object, new MemberPtr(node.value, 'right'))\n      )\n    }\n    return successor\n  }\n  /**\n   * Remove an element from the tree.\n   * @param object - The object to remove or a search type that is evaluated\n   * to the same value as an object in the tree. Equivalence is determined\n   * exclusively using the compare function.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  remove(\n    object: S,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      const result = this.cmp(node.value.data, object)\n      if (result > 0) {\n        this.remove(object, new MemberPtr(node.value, 'left'))\n      } else if (result < 0) {\n        this.remove(object, new MemberPtr(node.value, 'right'))\n      } else if (node.value.left && node.value.right) {\n        const successor = this._getInorderSuccessor(node.value.data, node)\n\n        this.remove(successor.data, successor.ptr)\n        node.value.data = successor.data\n      } else {\n        node.value = node.value.left || node.value.right\n      }\n    }\n  }\n\n  /**\n   * Perform an operation on all of the elements in a range.\n   * @param start - The search type or object at which to start a search.\n   * @param endm1 - The search type or object at which to end a search\n   * inclusively. The name is `endm1` to stand for `END Minus 1` since the\n   * search is performed inclusively.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   * @param undef - TODO: Fix\n   */\n  operateOnAllRange(\n    start: S,\n    endm1: S,\n    operation: NodeOp<T>,\n    node = this.bst_root,\n    undef = false\n  ): void {\n    if (node && !undef) {\n      if (this.gteqcmp(node.data, start)) {\n        if (this.gteqcmp(endm1, node.data)) {\n          this.operateOnAllRange(start, endm1, operation, node.left, !node.left)\n          this.operateOnAllRange(\n            start,\n            endm1,\n            operation,\n            node.right,\n            !node.right\n          )\n          operation(node)\n        } else {\n          this.operateOnAllRange(start, endm1, operation, node.left, !node.left)\n        }\n      } else {\n        this.operateOnAllRange(start, endm1, operation, node.right, !node.right)\n      }\n    }\n  }\n  /**\n   * Perform an operation on all of the elements greater than or equal to a\n   * search type or object.\n   * @param value - The search type or object at which to start a search.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAllGteq(\n    value: S,\n    operation: NodeOp<T>,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      if (this.gteqcmp(node.value.data, value)) {\n        operation(node.value)\n        this.operateOnAllGteq(\n          value,\n          operation,\n          new MemberPtr(node.value, 'left')\n        )\n      }\n      this.operateOnAllGteq(\n        value,\n        operation,\n        new MemberPtr(node.value, 'right')\n      )\n    }\n  }\n  /**\n   * Perform an operation on all of the elements less than or equal to a\n   * search type or object.\n   * @param value - The search type or object at which to end a search.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAllLteq(\n    value: S,\n    operation: NodeOp<T>,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      if (this.gteqcmp(value, node.value.data)) {\n        operation(node.value)\n        this.operateOnAllLteq(\n          value,\n          operation,\n          new MemberPtr(node.value, 'right')\n        )\n      }\n      this.operateOnAllLteq(value, operation, new MemberPtr(node.value, 'left'))\n    }\n  }\n\n  /**\n   * Perform an operation on all nodes.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAll(\n    operation: NodeOp<T>,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      this.operateOnAll(operation, new MemberPtr(node.value, 'left'))\n      operation(node.value)\n      this.operateOnAll(operation, new MemberPtr(node.value, 'right'))\n    }\n  }\n\n  /**\n   * Get all the objects in a range.\n   * @param start - The search type or object at which to start a search.\n   * @param endm1 - The search type or object at which to end a search\n   * inclusively. The name is `endm1` to stand for `END Minus 1` since the\n   * search is performed inclusively.\n   */\n  getRange(start: S, endm1: S): (BstNode<T> | undefined)[] {\n    const nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllRange(start, endm1, (n) => nodes.push(n))\n\n    return nodes\n  }\n  /**\n   * Get all the objects greater than or equal to an object or search type.\n   * @param value - The search type or object at which to start a search.\n   */\n  getGteq(value: S): (BstNode<T> | undefined)[] {\n    let nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllGteq(value, (n) => {\n      if (!nodes[0] || this.gtcmp(nodes[0].data, n.data)) {\n        nodes = [n]\n      } else if (this.eqcmp(nodes[0].data, n.data)) {\n        nodes.push(n)\n      }\n    })\n\n    return nodes\n  }\n  /**\n   * Get all the objects less than or equal to an object or search type.\n   * @param value - The search type or object at which to end a search.\n   */\n  getLteq(value: S): (BstNode<T> | undefined)[] {\n    let nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllLteq(value, (n) => {\n      if (!nodes[0] || this.gtcmp(n.data, nodes[0].data)) {\n        nodes = [n]\n      } else if (this.eqcmp(nodes[0].data, n.data)) {\n        nodes.push(n)\n      }\n    })\n\n    return nodes\n  }\n\n  toString(): string {\n    let str = 'BST [\\n'\n    this.operateOnAll(({ data }) => {\n      str += '  ' + data.toString() + '\\n'\n    })\n    str += ']'\n    return str\n  }\n}\n\nexport { Bst, BstNode }\n","// What a C++ typedef would do\n// This makes it possible to completely swap out the type of the int used in the\nimport { Int32 } from '../ints'\nimport { CompareResult } from '../utils'\n\n// algorithm w/o actually replacing each instance (which would be a real pain)\nimport LogootInt = Int32\n\n/**\n * A position in Logoot. This is just an array of numbers with some utility\n * functions. In Logoot, it must always be possible to allocate a position\n * between any possible two positions. In this algorithm, a position with more\n * `levels` (or elements in the array) comes first. So, if it is necessary to\n * create a position between `A` and `B`, then another level can be added to the\n * position to make it come after `A` and before `B`. Positions are represented\n * in writing the same as arrays: `[1,2,3]`\n * @example ```typescript\n * const a = new LogootPosition()\n * console.log(a.toString()) // [0]\n *\n * const b = a.offsetLowest(1)\n * console.log(b.toString()) // [1]\n *\n * console.log(new LogootPosition(1, a, b).toString()) // [0]\n * console.log(new LogootPosition(2, a, b).toString()) // [0,0]\n * ```\n */\nclass LogootPosition {\n  protected array: LogootInt[] = [new LogootInt(0)]\n\n  /**\n   * This constructor constructs a new position that is in the range specified\n   * by `start` and `end`. By using `len`, it is possible to enforce that a\n   * certain number of additional positions are available in the selected range.\n   * This guarantees that there's space for a LogootNode of length `len` at this\n   * position between `start` and `end`.\n   *\n   * @param len - The length of the allocation to make. The length is never\n   * actually stored in the Logoot position, but is used when finding space for\n   * the position to be created and `len` position(s) after it.\n   * @param start - This will cause the new position to have a value greater\n   * than or equal to this. This value is tricky: It must be the end of the last\n   * node. So if `A` is at `[1]` and an allocation *after* it is desired, then\n   * `[2]` would need to be passed to `start`.\n   * @param end - This will cause the new position to have a value less than or\n   * equal to this, subject to the value of `len`.\n   */\n  constructor(\n    len = 0,\n    readonly start?: LogootPosition,\n    readonly end?: LogootPosition\n  ) {\n    if (!start && end) {\n      this.array = end.inverseOffsetLowest(len).array\n    } else if (!end && start) {\n      this.array = start.copy().array\n    } else if (start && end) {\n      let done = false\n      const itstart = start.array.values()\n      const itend = end.array.values()\n      let nstart\n      let nend\n\n      this.array.length = 0\n\n      while (!done) {\n        if (!nstart || !nstart.done) {\n          nstart = itstart.next()\n        }\n        if (!nend || !nend.done) {\n          nend = itend.next()\n        }\n\n        if (!nstart.done && !nend.done) {\n          // See if we have enough space to insert 'len' between the nodes\n          if (nend.value.gteq(new LogootInt(nstart.value).add(len))) {\n            // There's space. We're done now: At the shallowest possible level\n            done = true\n          }\n          // Regardless, the start ID is the new ID for this level of our node\n          this.array.push(new LogootInt(nstart.value))\n        } else if (!nstart.done) {\n          // So there's no end restriction, that means we can just add right on\n          // top of the old end (the start of the new node)\n          this.array.push(new LogootInt(nstart.value))\n          done = true\n        } else if (!nend.done) {\n          // We have an end restriction, but no start restriction, so we just\n          // put the new node's start behind the old end\n          this.array.push(new LogootInt(nend.value).sub(len))\n          done = true\n        } else {\n          // So both other IDs have nothing else. It must be time to make a new\n          // level and be done\n          this.array.push(new LogootInt())\n          done = true\n        }\n      }\n    }\n  }\n\n  static fromJSON(eventnode: LogootPosition.JSON): LogootPosition {\n    const pos = new LogootPosition()\n    pos.array.length = 0\n    eventnode.forEach((n) => {\n      pos.array.push(LogootInt.fromJSON(n))\n    })\n    return pos\n  }\n  toJSON(): LogootPosition.JSON {\n    return this.array.map((n) => n.toJSON())\n  }\n\n  /**\n   * @returns Internal array length\n   */\n  get length(): number {\n    // A zero-length position is NOT valid\n    // Through some sneakiness, you COULD directly assign the array to make it\n    // have a length of zero. Don't do it.\n    return this.array.length\n  }\n  /**\n   * Returns the last index of the array. This is useful because before this,\n   * the algorithm code often contained many occurences of `length - 1`. This\n   * is used to cut down redundancy.\n   */\n  get levels(): number {\n    // A zero-length position is NOT valid\n    // Through some sneakiness, you COULD directly assign the array to make it\n    // have a length of zero. Don't do it.\n    return this.length - 1\n  }\n  /**\n   * An array accessor\n   */\n  level(n: number): LogootInt {\n    return this.array[n]\n  }\n  /**\n   * An array accessor\n   * @alias level\n   */\n  l(n: number): LogootInt {\n    return this.level(n)\n  }\n\n  /**\n   * Returns a new position with `offset` added to the lowest level of the\n   * position.\n   */\n  offsetLowest(offset: number | LogootInt): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((current, i, array) => {\n        return i < array.length - 1\n          ? current\n          : new LogootInt(current).add(offset)\n      })\n    })\n  }\n  /**\n   * Returns a new position with `offset` subtracted from the lowest level of\n   * the position.\n   */\n  inverseOffsetLowest(offset: number | LogootInt): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((current, i, array) => {\n        return i < array.length - 1\n          ? current\n          : new LogootInt(current).sub(offset)\n      })\n    })\n  }\n\n  /**\n   * Duplicates this position.\n   */\n  copy(): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((e) => new LogootInt(e))\n    })\n  }\n\n  /**\n   * Return a copy of this position, but with the number of levels specified by\n   * `level`. If this position has fewer levels, zeroes will be added in place.\n   */\n  equivalentPositionAtLevel(level: number): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: new Array(level + 1).fill(0, 0, level + 1).map((el, i) => {\n        return new LogootInt(this.array[i])\n      })\n    })\n  }\n\n  cmp(pos: LogootPosition, level = 0): CompareResult {\n    if (level >= this.length) {\n      if (this.length === pos.length) {\n        return 0\n      }\n      return 1\n    }\n    if (level >= pos.length) {\n      return -1\n    }\n    switch (this.level(level).cmp(pos.level(level))) {\n      case 1:\n        return 1\n      case -1:\n        return -1\n      case 0:\n        return this.cmp(pos, level + 1)\n      default:\n        return 0\n    }\n  }\n\n  /**\n   * Return this position if it is between `min` or `max`, otherwise return\n   * `min` if this is less and `max` if this is greater.\n   * @param min - The minimum output.\n   * @param max - The maximum output.\n   * @param preserve_levels - If defined, the output number of levels will be\n   * equal to `preserve_levels`.\n   */\n  clamp(\n    min: LogootPosition,\n    max: LogootPosition,\n    preserve_levels?: undefined | number\n  ): LogootPosition {\n    const clamped = this.cmp(min) < 0 ? min : this.cmp(max) > 0 ? max : this\n    if (preserve_levels !== undefined) {\n      return clamped.equivalentPositionAtLevel(preserve_levels)\n    } else {\n      return clamped.copy()\n    }\n  }\n\n  toString(): string {\n    let str = '['\n    this.array.forEach((el, i, a) => {\n      str += el.toString() + (i >= a.length - 1 ? '' : ',')\n    })\n    str += ']'\n    return str\n  }\n}\nnamespace LogootPosition {\n  export type JSON = LogootInt.JSON[]\n  export namespace JSON {\n    export const Schema = { type: 'array', items: LogootInt.JSON.Schema }\n  }\n}\n\n/**\n * Logoot treats each atom as seperate. However, in a real-world environment, it\n * is not practical to treat each atom seperately. To save memory and CPU time,\n * the algorithm groups together consecutive atoms into `LogootNode`s. A\n * `LogootNode` is technically just a series of consecutive atoms with the same\n * `rclk` (vector clock).\n */\nclass LogootNode {\n  /**\n   * The position of the node in the local document.\n   */\n  known_position = 0\n  length = 0\n  start: LogootPosition = new LogootPosition()\n  rclk: LogootInt = new LogootInt(0)\n\n  /**\n   * @param node - A node to copy, C++ style\n   */\n  constructor(node?: LogootNode) {\n    if (node) {\n      Object.assign(this, {\n        known_position: node.known_position,\n        length: node.length,\n        start: node.start.offsetLowest(new LogootInt()),\n        rclk: new LogootInt(node.rclk)\n      })\n    }\n  }\n\n  /**\n   * The end of the node. Note that technically there is not an atom at this\n   * position, so it's fair game to have another node placed at this position.\n   */\n  get end(): LogootPosition {\n    return this.start.offsetLowest(this.length)\n  }\n  /**\n   * The end of the node in the local document.\n   */\n  get known_end_position(): number {\n    return this.known_position + this.length\n  }\n\n  toString(): string {\n    return (\n      this.start.toString() +\n      (typeof this.known_position === 'number'\n        ? '(' + this.known_position + ')'\n        : '') +\n      ` + ${this.length} @ ${this.rclk}`\n    )\n  }\n}\ntype LogootNodeWithMeta = LogootNode & { offset: number }\n\nexport { LogootInt, LogootPosition, LogootNode, LogootNodeWithMeta }\n","/**\n * @file Definition of various integers.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { CompareResult, Comparable } from './utils'\n\n/**\n * An abstract subclass of `Comparable` to provide a generic interface for\n * integer types that may not be supported by JavaScript\n * @template FutureType - The type of the subclass with which to restrict all\n * operations to the int class.\n * @inheritdoc\n */\nabstract class IntType<FutureType> extends Comparable<FutureType | number> {\n  // eslint-disable-next-line\n  abstract toJSON(): any\n  abstract toString(): string\n\n  /**\n   * Add another integer to the value of this one\n   * @param n - The number to add\n   */\n  abstract add(n: FutureType | number): FutureType\n  /**\n   * Add another integer to the value of this one\n   * @param n - The number to subtract\n   */\n  abstract sub(n: FutureType | number): FutureType\n\n  /**\n   * Assign another integer to this object\n   * @param n - The number to assign\n   */\n  abstract sub(n: FutureType | number): FutureType\n\n  /**\n   * The JavaScript int type for this integer (with an exception thrown if the\n   * value cannot be represented in 32 bits)\n   */\n  abstract js_int: number\n}\n\n/**\n * An `IntType` that restricts the number to 32 bits by using an `Int32Array`.\n * @inheritdoc\n * @example ```typescript\n * const a = new Int32(5)\n * console.log(a.toString()) // 5\n * a.add(10).sub(8)\n * console.log(a.toString()) // 7\n * const b = new Int32(3)\n * console.log(a.cmp(b)) // 1\n * ```\n */\nclass Int32 extends IntType<Int32> {\n  // Size limit the int, enforce signing, and remove decimals\n  private int32 = new Int32Array([0])\n  is_rclk = false\n\n  constructor(n: Int32 | number = 0) {\n    super()\n    if (n instanceof Int32) {\n      this.int32[0] = n.int32[0]\n    } else {\n      this.int32[0] = n\n    }\n  }\n\n  static fromJSON(obj: Int32.JSON): Int32 {\n    return new Int32(obj)\n  }\n\n  toJSON(): Int32.JSON {\n    return this.int32[0]\n  }\n\n  add(n: Int32 | number): Int32 {\n    if (this.is_rclk) {\n      console.trace('RCLK')\n    }\n    if (n instanceof Int32) {\n      this.int32[0] += n.int32[0]\n    } else {\n      this.int32[0] += n\n    }\n    return this\n  }\n  sub(n: Int32 | number): Int32 {\n    if (n instanceof Int32) {\n      this.int32[0] -= n.int32[0]\n    } else {\n      this.int32[0] -= n\n    }\n    return this\n  }\n\n  assign(n: Int32 | number): Int32 {\n    if (n instanceof Int32) {\n      this.int32[0] = n.int32[0]\n    } else {\n      this.int32[0] = n\n    }\n    return this\n  }\n\n  cmp(n: Int32 | number): CompareResult {\n    if (n instanceof Int32) {\n      return ((this.int32[0] >= n.int32[0] ? 1 : 0) +\n        (this.int32[0] <= n.int32[0] ? -1 : 0)) as CompareResult\n    } else {\n      return ((this.int32[0] >= n ? 1 : 0) +\n        (this.int32[0] <= n ? -1 : 0)) as CompareResult\n    }\n  }\n\n  get js_int(): number {\n    return this.int32[0]\n  }\n\n  toString(): string {\n    return this.int32[0].toString()\n  }\n}\nnamespace Int32 {\n  export type JSON = number\n  export namespace JSON {\n    export const Schema = { type: 'number' }\n  }\n}\n\nexport { IntType, Int32 }\n"],"sourceRoot":""}