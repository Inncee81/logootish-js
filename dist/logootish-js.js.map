{"version":3,"sources":["webpack://logootish-js/webpack/universalModuleDefinition","webpack://logootish-js/webpack/bootstrap","webpack://logootish-js/./node_modules/loglevel/lib/loglevel.js","webpack://logootish-js/./src/bst.ts","webpack://logootish-js/./src/debug.ts","webpack://logootish-js/./src/index.ts","webpack://logootish-js/./src/ints.ts","webpack://logootish-js/./src/listmodel/index.ts","webpack://logootish-js/./src/listmodel/logoot.ts","webpack://logootish-js/./src/utils.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAA0C;AAClD,QAAQ,oCAAO,UAAU;AAAA;AAAA;AAAA;AAAA,oGAAC;AAC1B,KAAK,MAAM,EAIN;AACL,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;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","file":"logootish-js.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"logootish-js\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"logootish-js\"] = factory();\n\telse\n\t\troot[\"logootish-js\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n","/**\n * @file A binary search tree implementation for finding ranges within the tree\n * and finding neighboring nodes.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { DualCompareFunction, MemberPtr } from './utils'\n\n/**\n * The node type used by the binary search tree\n */\nclass BstNode<T> {\n  /**\n   * The data contained in the node.\n   */\n  data: T\n  left: BstNode<T> | undefined\n  right: BstNode<T> | undefined\n  constructor(data: T) {\n    this.data = data\n  }\n}\n\n/**\n * The pointer type either to a leaf of the BST or the root. By using\n * `MemberPtr`, methods in the BST can re-assign the node value simply through\n * this 'pointer' object.\n */\ntype BstNodePtr<T> =\n  | MemberPtr<BstNode<T>, 'left'>\n  | MemberPtr<BstNode<T>, 'right'>\n  // eslint-disable-next-line\n  | MemberPtr<Bst<T, any>, 'bst_root'>\n/**\n * The type of a function that operates on nodes of the BST.\n */\ntype NodeOp<T> = (node: BstNode<T>) => void\n\n/**\n * A binary search tree implementation for finding ranges within the tree and\n * finding neighboring nodes.\n * @template T - The type stored in the tree.\n * @template S - The type used by search functions, but that cannot be added to\n * the tree. It defaults to `T`.\n */\nclass Bst<T extends S, S = T> {\n  bst_root: BstNode<T> | undefined = undefined\n  readonly cmp: DualCompareFunction<S>\n\n  /**\n   * @param cmp - The compare function to use to sort the tree.\n   */\n  constructor(cmp: DualCompareFunction<S>) {\n    this.cmp = cmp\n  }\n\n  gteqcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) >= 0\n  }\n  gtcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) > 0\n  }\n  eqcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) === 0\n  }\n\n  /**\n   * Add an element to the tree.\n   * @param object - The object to add to the tree.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  add(object: T, node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')): void {\n    if (!node.value) {\n      node.value = new BstNode(object)\n    } else if (this.gteqcmp(node.value.data, object)) {\n      this.add(object, new MemberPtr(node.value, 'left'))\n    } else {\n      this.add(object, new MemberPtr(node.value, 'right'))\n    }\n  }\n\n  /**\n   * A method designed mostly for internal use that finds the next element in\n   * the tree if all of the elements were placed in order.\n   * @param object - The object or search type to find the successor of\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  _getInorderSuccessor(\n    object: S,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): { ptr: BstNodePtr<T>; data: T } | undefined {\n    type SuccessorType = { ptr: BstNodePtr<T>; data: T } | undefined\n    let successor: SuccessorType\n    const setSuccessor = (s: SuccessorType): void => {\n      if (!successor || (s && this.gtcmp(successor.data, s.data))) {\n        successor = s\n      }\n    }\n    if (node.value) {\n      if (this.gteqcmp(node.value.data, object)) {\n        if (!this.eqcmp(node.value.data, object)) {\n          setSuccessor({ ptr: node, data: node.value.data })\n        }\n        setSuccessor(\n          this._getInorderSuccessor(object, new MemberPtr(node.value, 'left'))\n        )\n      }\n      setSuccessor(\n        this._getInorderSuccessor(object, new MemberPtr(node.value, 'right'))\n      )\n    }\n    return successor\n  }\n  /**\n   * Remove an element from the tree.\n   * @param object - The object to remove or a search type that is evaluated\n   * to the same value as an object in the tree. Equivalence is determined\n   * exclusively using the compare function.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  remove(\n    object: S,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      const result = this.cmp(node.value.data, object)\n      if (result > 0) {\n        this.remove(object, new MemberPtr(node.value, 'left'))\n      } else if (result < 0) {\n        this.remove(object, new MemberPtr(node.value, 'right'))\n      } else if (node.value.left && node.value.right) {\n        const successor = this._getInorderSuccessor(node.value.data, node)\n\n        this.remove(successor.data, successor.ptr)\n        node.value.data = successor.data\n      } else {\n        node.value = node.value.left || node.value.right\n      }\n    }\n  }\n\n  /**\n   * Perform an operation on all of the elements in a range.\n   * @param start - The search type or object at which to start a search.\n   * @param endm1 - The search type or object at which to end a search\n   * inclusively. The name is `endm1` to stand for `END Minus 1` since the\n   * search is performed inclusively.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   * @param undef - TODO: Fix\n   */\n  operateOnAllRange(\n    start: S,\n    endm1: S,\n    operation: NodeOp<T>,\n    node = this.bst_root,\n    undef = false\n  ): void {\n    if (node && !undef) {\n      if (this.gteqcmp(node.data, start)) {\n        if (this.gteqcmp(endm1, node.data)) {\n          this.operateOnAllRange(start, endm1, operation, node.left, !node.left)\n          this.operateOnAllRange(\n            start,\n            endm1,\n            operation,\n            node.right,\n            !node.right\n          )\n          operation(node)\n        } else {\n          this.operateOnAllRange(start, endm1, operation, node.left, !node.left)\n        }\n      } else {\n        this.operateOnAllRange(start, endm1, operation, node.right, !node.right)\n      }\n    }\n  }\n  /**\n   * Perform an operation on all of the elements greater than or equal to a\n   * search type or object.\n   * @param value - The search type or object at which to start a search.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAllGteq(\n    value: S,\n    operation: NodeOp<T>,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      if (this.gteqcmp(node.value.data, value)) {\n        operation(node.value)\n        this.operateOnAllGteq(\n          value,\n          operation,\n          new MemberPtr(node.value, 'left')\n        )\n      }\n      this.operateOnAllGteq(\n        value,\n        operation,\n        new MemberPtr(node.value, 'right')\n      )\n    }\n  }\n  /**\n   * Perform an operation on all of the elements less than or equal to a\n   * search type or object.\n   * @param value - The search type or object at which to end a search.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAllLteq(\n    value: S,\n    operation: NodeOp<T>,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      if (this.gteqcmp(value, node.value.data)) {\n        operation(node.value)\n        this.operateOnAllLteq(\n          value,\n          operation,\n          new MemberPtr(node.value, 'right')\n        )\n      }\n      this.operateOnAllLteq(value, operation, new MemberPtr(node.value, 'left'))\n    }\n  }\n\n  /**\n   * Perform an operation on all nodes.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAll(\n    operation: NodeOp<T>,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      this.operateOnAll(operation, new MemberPtr(node.value, 'left'))\n      operation(node.value)\n      this.operateOnAll(operation, new MemberPtr(node.value, 'right'))\n    }\n  }\n\n  /**\n   * Get all the objects in a range.\n   * @param start - The search type or object at which to start a search.\n   * @param endm1 - The search type or object at which to end a search\n   * inclusively. The name is `endm1` to stand for `END Minus 1` since the\n   * search is performed inclusively.\n   */\n  getRange(start: S, endm1: S): (BstNode<T> | undefined)[] {\n    const nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllRange(start, endm1, (n) => nodes.push(n))\n\n    return nodes\n  }\n  /**\n   * Get all the objects greater than or equal to an object or search type.\n   * @param value - The search type or object at which to start a search.\n   */\n  getGteq(value: S): (BstNode<T> | undefined)[] {\n    let nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllGteq(value, (n) => {\n      if (!nodes[0] || this.gtcmp(nodes[0].data, n.data)) {\n        nodes = [n]\n      } else if (this.eqcmp(nodes[0].data, n.data)) {\n        nodes.push(n)\n      }\n    })\n\n    return nodes\n  }\n  /**\n   * Get all the objects less than or equal to an object or search type.\n   * @param value - The search type or object at which to end a search.\n   */\n  getLteq(value: S): (BstNode<T> | undefined)[] {\n    let nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllLteq(value, (n) => {\n      if (!nodes[0] || this.gtcmp(n.data, nodes[0].data)) {\n        nodes = [n]\n      } else if (this.eqcmp(nodes[0].data, n.data)) {\n        nodes.push(n)\n      }\n    })\n\n    return nodes\n  }\n\n  toString(): string {\n    let str = 'BST [\\n'\n    this.operateOnAll(({ data }) => {\n      str += '  ' + data.toString() + '\\n'\n    })\n    str += ']'\n    return str\n  }\n}\n\nexport { Bst, BstNode }\n","/**\n * @file Definition of the `debug` constant from `loglevel`.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport loglevel from 'loglevel'\n\nconst debug = loglevel.getLogger('logootish-js')\n\nexport { debug }\n","/**\n * @file This is the core of the Logootish algorithm. It contains all position\n * manipulation code.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { debug } from './debug'\nimport {\n  ListDocumentModel,\n  Removal,\n  LogootInt,\n  LogootPosition,\n  KnownPositionBst,\n  LogootBst\n} from './listmodel'\n\nenum EventState {\n  /**\n   * Not being actively sent and can be modified.\n   */\n  PENDING,\n  /**\n   * In transit. Cannot be modified.\n   */\n  SENDING,\n  /**\n   * Already sent. Also cannot be modified.\n   */\n  COMPLETE\n}\n/**\n * @deprecated in favor of typeof statements, but I've been meaning to remove\n * code dependent on this for a few versions now.\n * @TODO Fix me\n */\nenum EventType {\n  INSERTION,\n  REMOVAL\n}\n\n/**\n * Generic event interface.\n */\ninterface LogootEvent {\n  type: EventType\n  state: EventState\n  // eslint-disable-next-line\n  toJSON(): any\n  rclk: LogootInt\n}\n\n/**\n * An event sent when text is added, which contains a body and start position.\n */\nclass InsertionEvent implements LogootEvent {\n  type = EventType.INSERTION\n  body = ''\n  start?: LogootPosition = undefined\n  rclk = new LogootInt()\n\n  // Previous & next insertion event\n  last: InsertionEvent = undefined\n  next: InsertionEvent = undefined\n\n  state = EventState.PENDING\n\n  constructor(body: string, start = new LogootPosition(), rclk?: LogootInt) {\n    Object.assign(this, {\n      body,\n      start,\n      rclk: new LogootInt(rclk)\n    })\n  }\n\n  static fromJSON(eventnode: InsertionEvent.JSON): InsertionEvent {\n    return new InsertionEvent(\n      eventnode.body,\n      LogootPosition.fromJSON(eventnode.start),\n      LogootInt.fromJSON(eventnode.rclk)\n    )\n  }\n  toJSON(): InsertionEvent.JSON {\n    return {\n      body: this.body,\n      start: this.start.toJSON(),\n      rclk: this.rclk.toJSON()\n    }\n  }\n\n  get length(): number {\n    return this.body.length\n  }\n  get end(): LogootPosition {\n    return this.start.offsetLowest(this.length)\n  }\n}\nnamespace InsertionEvent {\n  export type JSON = {\n    body: string\n    start: LogootPosition.JSON\n    rclk: LogootInt.JSON\n  }\n  export namespace JSON {\n    export const Schema = {\n      type: 'object',\n      properties: {\n        body: { type: 'string' },\n        start: LogootPosition.JSON.Schema,\n        rclk: LogootInt.JSON.Schema\n      }\n    }\n  }\n}\n\ntype RemovalJSON = { start: LogootPosition.JSON; length: number }\n/**\n * An event sent when text is removed, which contains an array of start\n * positions and lengths. An array was chosen since it is preferred for one\n * operation to translate to one event. In an insertion, this is easy since\n * there is just a start and body. However, a removal might remove areas of text\n * that are on different levels and could generate many events.\n */\nclass RemovalEvent implements LogootEvent {\n  type = EventType.REMOVAL\n  removals: Removal[] = []\n  rclk: LogootInt\n\n  state = EventState.PENDING\n\n  constructor(removals: Removal[], rclk?: LogootInt) {\n    this.removals = removals\n    this.rclk = new LogootInt(rclk)\n  }\n\n  static fromJSON(eventnode: RemovalEvent.JSON): RemovalEvent {\n    return new RemovalEvent(\n      eventnode.removals.map((r) => ({\n        start: LogootPosition.fromJSON(r.start),\n        length: r.length\n      })),\n      LogootInt.fromJSON(eventnode.rclk)\n    )\n  }\n  toJSON(): RemovalEvent.JSON {\n    return {\n      removals: this.removals.map((r) => ({\n        start: r.start.toJSON(),\n        length: r.length\n      })),\n      rclk: this.rclk.toJSON()\n    }\n  }\n}\nnamespace RemovalEvent {\n  export type JSON = { removals: RemovalJSON[]; rclk: LogootInt.JSON }\n  export namespace JSON {\n    export const Schema = {\n      type: 'object',\n      properties: {\n        removals: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              start: LogootPosition.JSON.Schema,\n              length: { type: 'number' }\n            }\n          }\n        },\n        rclk: LogootInt.JSON.Schema\n      }\n    }\n  }\n}\n\n/**\n * Exists only for backwards compatability.\n * @deprecated Will be removed in next minor version bump. Semver allows this\n * when the major version is 0.\n * @TODO Remove this class. Create an event bus system.\n */\nclass Document {\n  /** Events that need to get sent over Matrix */\n  pending_events: LogootEvent[] = []\n\n  /**\n   * Used to keep track of active EventEmitter listeners having anything to do\n   * with this document\n   * @deprecated it shouldn't be here and is temporary\n   * @todo Move this to matrix-notepad\n   */\n  _active_listeners: any[] = []\n\n  private send: (e: LogootEvent) => Promise<any>\n\n  private insertLocal: (position: number, body: string) => void\n  private removeLocal: (position: number, length: number) => void\n\n  last_insertion_event: InsertionEvent = undefined\n\n  doc: ListDocumentModel = new ListDocumentModel()\n\n  /**\n   * @param send - A callback function to send a LogootEvent\n   * @param insertLocal - A callback function to insert text\n   * @param removeLocal - A callback function to remove text\n   */\n  constructor(\n    send: (e: LogootEvent) => Promise<any>,\n    insertLocal: (position: number, body: string) => void,\n    removeLocal: (position: number, length: number) => void\n  ) {\n    this.send = send\n    this.insertLocal = insertLocal\n    this.removeLocal = removeLocal\n  }\n\n  /**\n   * Remove an event from the pending event array\n   */\n  private _removePendingEvent(event: LogootEvent): boolean {\n    const index = this.pending_events.indexOf(event)\n    if (index >= 0) {\n      this.pending_events.splice(index, 1)\n      return true\n    }\n    return false\n  }\n  /**\n   * Merge an event with other neighboring ones\n   */\n  private _tryMergeEvents(event: InsertionEvent): boolean {\n    if (event.state !== EventState.PENDING) {\n      return false\n    }\n    // TODO: Maybe do a tree lookup instead. But this is complicated since then\n    // each node has to store its associated event\n    if (event.last && event.last.state === EventState.PENDING) {\n      let oldevent = event\n      while (oldevent.last && oldevent.last.state === EventState.PENDING) {\n        oldevent.last.body += oldevent.body\n\n        oldevent.last.next = oldevent.next\n        if (oldevent.next) {\n          oldevent.next.last = oldevent.last\n        }\n\n        this._removePendingEvent(oldevent)\n\n        if (this.last_insertion_event === oldevent) {\n          this.last_insertion_event = oldevent.last\n        }\n        oldevent = oldevent.last\n      }\n      // Now try the other direction...\n      this._tryMergeEvents(oldevent)\n      return true\n    } else if (event.next && event.next.state === EventState.PENDING) {\n      let oldevent = event\n      while (oldevent.next && oldevent.next.state === EventState.PENDING) {\n        oldevent.next.body = oldevent.body + oldevent.next.body\n        oldevent.next.start = oldevent.start\n\n        oldevent.next.last = oldevent.last\n        if (oldevent.last) {\n          oldevent.last.next = oldevent.next\n        }\n\n        this._removePendingEvent(oldevent)\n\n        if (this.last_insertion_event === oldevent) {\n          this.last_insertion_event = oldevent.next\n        }\n        oldevent = oldevent.next\n      }\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Send a `LogootEvent` using the document-specific logic.\n   */\n  private _pushEvent(event: LogootEvent): void {\n    this.pending_events.push(event)\n\n    const queue_send = (): void => {\n      event.state = EventState.SENDING\n      this.send(event)\n        .then(() => {\n          this._removePendingEvent(event)\n          event.state = EventState.COMPLETE\n        })\n        .catch((e) => {\n          event.state = EventState.PENDING\n          // TODO: Nothing is here *should* be Matrix specific\n          if (e.event) {\n            e.event.flagCancelled()\n          }\n          if (e && e.data && e.data.retry_after_ms) {\n            if (\n              event.type === EventType.INSERTION &&\n              this._tryMergeEvents(event as InsertionEvent)\n            ) {\n              debug.warn(\n                `Hitting the rate limit: Will resend in ${e.data.retry_after_ms} ms with multiple messages merged together`\n              )\n              return {}\n            }\n            debug.warn(\n              `Hitting the rate limit: Will resend in ${e.data.retry_after_ms} ms`\n            )\n            setTimeout(queue_send, e.data.retry_after_ms)\n          } else {\n            debug.error('Error sending event', e)\n            return e\n          }\n        })\n    }\n    queue_send()\n  }\n\n  get ldoc_bst(): KnownPositionBst {\n    return this.ldoc_bst\n  }\n  get logoot_bst(): LogootBst {\n    return this.logoot_bst\n  }\n  get removal_bst(): LogootBst {\n    return this.removal_bst\n  }\n\n  /**\n   * Inform the document of new text in the local text copy. This will call the\n   * `send` function with the resulting event.\n   * @param position - The index of new text\n   * @param text - The text that will be inserted\n   */\n  insert(position: number, text: string): void {\n    const ins = this.doc.insertLocal(position, text.length)\n    this._pushEvent(new InsertionEvent(text, ins.position, ins.rclk))\n  }\n  /**\n   * Inform the document of removed text in the local text copy. This will call\n   * the `send` function with the resulting event.\n   * @param position - The index of old text\n   * @param length - The length text that will be removed\n   */\n  remove(position: number, length: number): void {\n    const { removals, rclk } = this.doc.removeLocal(position, length)\n    this._pushEvent(new RemovalEvent(removals, rclk))\n  }\n  /**\n   * Inform the document of an incoming event from remote documents. The\n   * function `insertLocal` will be called based on the results of this.\n   * @param event_contents - The raw incoming JSON\n   */\n  remoteInsert(event_contents: InsertionEvent.JSON): void {\n    const { body, start, rclk } = InsertionEvent.fromJSON(event_contents)\n    const { insertions } = this.doc.insertLogoot(start, body.length, rclk)\n    insertions.forEach(({ offset, length, known_position }) =>\n      this.insertLocal(known_position, body.substr(offset, length))\n    )\n  }\n  /**\n   * Inform the document of an incoming event from remote documents. The\n   * function `removeLocal` will be called based on the results of this.\n   * @param event_contents - The raw incoming JSON\n   */\n  remoteRemove(event_contents: RemovalEvent.JSON): void {\n    const { rclk, removals } = RemovalEvent.fromJSON(event_contents)\n    removals.forEach(({ start, length }) => {\n      const { removals } = this.doc.removeLogoot(start, length, rclk)\n      removals.forEach(({ known_position, length }) =>\n        this.removeLocal(known_position, length)\n      )\n    })\n  }\n}\n\nexport {\n  EventType,\n  EventState,\n  ListDocumentModel,\n  InsertionEvent,\n  RemovalEvent,\n  LogootInt,\n  LogootPosition,\n  Document\n}\n","/**\n * @file Definition of various integers.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { CompareResult, Comparable } from './utils'\n\n/**\n * An abstract subclass of `Comparable` to provide a generic interface for\n * integer types that may not be supported by JavaScript\n * @template FutureType - The type of the subclass with which to restrict all\n * operations to the int class.\n * @inheritdoc\n */\nabstract class IntType<FutureType> extends Comparable<FutureType | number> {\n  // eslint-disable-next-line\n  abstract toJSON(): any\n  abstract toString(): string\n\n  /**\n   * Add another integer to the value of this one\n   * @param n - The number to add\n   */\n  abstract add(n: FutureType | number): FutureType\n  /**\n   * Add another integer to the value of this one\n   * @param n - The number to subtract\n   */\n  abstract sub(n: FutureType | number): FutureType\n\n  /**\n   * Assign another integer to this object\n   * @param n - The number to assign\n   */\n  abstract sub(n: FutureType | number): FutureType\n\n  /**\n   * The JavaScript int type for this integer (with an exception thrown if the\n   * value cannot be represented in 32 bits)\n   */\n  abstract js_int: number\n}\n\n/**\n * An `IntType` that restricts the number to 32 bits by using an `Int32Array`.\n * @inheritdoc\n * @example ```typescript\n * const a = new Int32(5)\n * console.log(a.toString()) // 5\n * a.add(10).sub(8)\n * console.log(a.toString()) // 7\n * const b = new Int32(3)\n * console.log(a.cmp(b)) // 1\n * ```\n */\nclass Int32 extends IntType<Int32> {\n  // Size limit the int, enforce signing, and remove decimals\n  private int32 = new Int32Array([0])\n  is_rclk = false\n\n  constructor(n: Int32 | number = 0) {\n    super()\n    if (n instanceof Int32) {\n      this.int32[0] = n.int32[0]\n    } else {\n      this.int32[0] = n\n    }\n  }\n\n  static fromJSON(obj: Int32.JSON): Int32 {\n    return new Int32(obj)\n  }\n\n  toJSON(): Int32.JSON {\n    return this.int32[0]\n  }\n\n  add(n: Int32 | number): Int32 {\n    if (this.is_rclk) {\n      console.trace('RCLK')\n    }\n    if (n instanceof Int32) {\n      this.int32[0] += n.int32[0]\n    } else {\n      this.int32[0] += n\n    }\n    return this\n  }\n  sub(n: Int32 | number): Int32 {\n    if (n instanceof Int32) {\n      this.int32[0] -= n.int32[0]\n    } else {\n      this.int32[0] -= n\n    }\n    return this\n  }\n\n  assign(n: Int32 | number): Int32 {\n    if (n instanceof Int32) {\n      this.int32[0] = n.int32[0]\n    } else {\n      this.int32[0] = n\n    }\n    return this\n  }\n\n  cmp(n: Int32 | number): CompareResult {\n    if (n instanceof Int32) {\n      return ((this.int32[0] >= n.int32[0] ? 1 : 0) +\n        (this.int32[0] <= n.int32[0] ? -1 : 0)) as CompareResult\n    } else {\n      return ((this.int32[0] >= n ? 1 : 0) +\n        (this.int32[0] <= n ? -1 : 0)) as CompareResult\n    }\n  }\n\n  get js_int(): number {\n    return this.int32[0]\n  }\n\n  toString(): string {\n    return this.int32[0].toString()\n  }\n}\nnamespace Int32 {\n  export type JSON = number\n  export namespace JSON {\n    export const Schema = { type: 'number' }\n  }\n}\n\nexport { IntType, Int32 }\n","import { arraymap, FatalError, CompareResult } from '../utils'\nimport { debug } from '../debug'\nimport { Bst } from '../bst'\n\nimport {\n  LogootInt,\n  LogootPosition,\n  LogootNode,\n  LogootNodeWithMeta\n} from './logoot'\n\ntype Removal = { start: LogootPosition; length: number }\n\ntype KnownPositionBst = Bst<LogootNode, { known_position: number }>\ntype LogootBst = Bst<LogootNode, { start: LogootPosition }>\n\ntype Conflict = {\n  start: LogootPosition\n  end: LogootPosition\n  clip_nstart: boolean\n  clip_nend: boolean\n  whole_node: boolean\n  level: number\n}\n\n/**\n * This is possibly the most important function in this entire program. The\n * role of this function is to determine which parts of a node will have\n * precedence over nodes currently in a Logoot binary search tree. Any new\n * node must be filtered to determine which parts can actually make it into\n * the document. For example, if there is a node with a higher `rclk`\n * currently in the BST, that portion that overlaps with the node must be cut\n * out. If the reverse is true, the node must be removed. This is done by\n * first filtering the nodes in the region in question using a user-defined\n * priority function. Nodes are either kept, ignored, or removed. These nodes\n * are then used as regions of the input to skip over (variable named\n * `skip_ranges`) and the resulting node(s) are returned.\n *\n * @param bst - The binary search tree containing current nodes to consider\n * @param nstart - The start of the region in question\n * @param length - The length of the region in question\n * @param resolveConflict - A callback function determining what happens to a\n * node currently in the BST in the region in question. If it returns 1, the\n * node is kept. If it is 0, the node is ignored and is not skipped over. If\n * it is -1, the section in question of the node is removed and the\n * `informRemoval` function is called so further removals can be performed.\n * @param addNode - A function only called when a node is split into pieces\n * and additional nodes must be added as side-effects of the operation.\n * @param informRemoval - A function to be called when a section or all of a\n * node is removed so that the caller can modify the document as necessary.\n */\nfunction _mergeNode(\n  bst: LogootBst,\n  nstart: LogootPosition,\n  length: number,\n  resolveConflict: (\n    node: LogootNode,\n    conflict: Conflict,\n    lesser: LogootNode\n  ) => CompareResult,\n  addNode: (node: LogootNode) => void,\n  informRemoval: (\n    node: LogootNode,\n    pos: number,\n    length: number,\n    whole: boolean\n  ) => void\n): LogootNodeWithMeta[] {\n  const level = nstart.levels\n  const nend = nstart.offsetLowest(length)\n\n  // These ranges are areas of the document that are already populated in the\n  // region where the insert is happening. If there are conflicts, they will be\n  // skipped. The end of this new insert must be added to the end as a fake\n  // zero-length node so that the for each loop triggers for the end.\n  let skip_ranges = bst\n    .getRange({ start: nstart }, { start: nend })\n    .map(({ data }) => data)\n    .sort((a, b) => a.start.cmp(b.start))\n\n  const nodes_lesser = bst.getLteq({ start: nstart })\n  let lesser: LogootNode\n  if (nodes_lesser.length > 1) {\n    throw new FatalError('Corrupt BST. There are multiple nodes at a position.')\n  } else if (nodes_lesser.length) {\n    lesser = nodes_lesser[0].data\n  }\n\n  // Ensure that lesser is initially defined as a skip_range (this is useful for\n  // some removals that may want to use conflicts with lesser\n  if (lesser && !skip_ranges.includes(lesser)) {\n    skip_ranges.unshift(lesser)\n  }\n  // It's fine that known_position is invalid because that would only impact\n  // nodes AFTER this one (whose calculations depend upon it)\n  skip_ranges.push({\n    start: nend,\n    end: nend,\n    length: 0,\n    known_position: 0,\n    known_end_position: 0,\n    rclk: new LogootInt(0)\n  })\n\n  skip_ranges = skip_ranges.filter((n) => {\n    if (n.length && n.start.levels === level) {\n      const clip_nstart = nstart.cmp(n.start) > 0\n      const clip_nend = nend.cmp(n.end) < 0\n      const start = clip_nstart ? nstart : n.start\n      const end = clip_nend ? nend : n.end\n      if (start.cmp(end) === 0) {\n        return true\n      }\n      const conflict = {\n        start,\n        end,\n        clip_nstart,\n        clip_nend,\n        whole_node: !(clip_nstart || clip_nend),\n        level\n      }\n\n      // Get the externally defined result for this conflict\n      const result = resolveConflict(n, conflict, lesser)\n\n      // Actually remove the node or part of it if it looses\n      if (result < 1) {\n        if (result < 0) {\n          // Shortcut to remove the whole node\n          if (conflict.whole_node) {\n            informRemoval(n, n.known_position, n.length, true)\n            n.length = 0\n          } else {\n            // Find the length of the middle region of the node\n            // nnnnnRRRRnnnn <- Where the 'R' is (l=4 in this case)\n            const l = new LogootInt(end.l(level)).sub(start.l(level)).js_int\n\n            // Make a copy because we will need to modify the original\n            const endnode = new LogootNode(n)\n            endnode.start = end\n            const n_end_old = n.end.offsetLowest(0)\n\n            if (clip_nstart) {\n              // This means we're dealing with an area ahead of the node with a\n              // length > 0:\n              // NNNNrrrrrnnnnn (As above, 'r' is the section of the node being\n              // removed)\n              n.length = new LogootInt(start.l(level)).sub(\n                n.start.l(level)\n              ).js_int\n\n              endnode.known_position += n.length\n              endnode.start.offsetLowest(n.known_position + n.length + l)\n              informRemoval(n, n.known_position + n.length, l, n.length <= 0)\n            } else {\n              // The removal must be right up against the edge of the node,\n              // so we can take an easy shortcut:\n              // RRRRnnnnnn\n              informRemoval(n, n.known_position, l, true)\n              endnode.start.offsetLowest(n.known_position + l)\n            }\n            if (clip_nend) {\n              // Ok, so now we have to add a new node to account for the\n              // trailing end portion: [nnnn]rrrrNNNNN <- that\n              // We also have to re-add it to the BSTs because they are sorted\n              // by start position, so if we modify the start, we could break\n              // the sorting\n              endnode.length = new LogootInt(n_end_old.l(level)).sub(\n                end.l(level)\n              ).js_int\n              if (endnode.length > 0) {\n                addNode(endnode)\n              }\n            }\n          }\n        }\n        return false\n      }\n    }\n    return true\n  })\n\n  let known_start = 0\n  if (lesser) {\n    const positions = [lesser.length]\n    // Find where we are inside lesser. If we're outside of lesser, this will be\n    // greater than lesser's length and will be ignored\n    if (lesser.start.levels < nstart.levels) {\n      positions.push(\n        new LogootInt(nstart.l(lesser.start.levels)).sub(\n          lesser.start.l(lesser.start.levels)\n        ).js_int\n      )\n    }\n\n    // Figure out which endpoint to use, the end of lesser or where our position\n    // is if its inside lesser\n    const lesser_pos = Math.min(...positions)\n    known_start = lesser.known_position + lesser_pos\n\n    // Split lesser in two if necessary\n    if (lesser.length - lesser_pos) {\n      const node = new LogootNode(lesser)\n      node.start = node.start.offsetLowest(lesser_pos)\n      node.length -= lesser_pos\n      node.known_position += lesser_pos\n      addNode(node)\n\n      lesser.length = lesser_pos\n    }\n  }\n\n  const newnodes: LogootNodeWithMeta[] = []\n  // We fake the last node end to be the start of the new node because the\n  // inserted text always needs to 'snap' to the end of the last node,\n  // regardless of discontinuities in Logoot positions\n  let last_end = nstart\n  let last_known_position = known_start\n  skip_ranges.forEach((skip_range) => {\n    const { start, end, length } = skip_range\n    // Clamped regions to consider. Anything outside of the node to be inserted\n    // doesn't matter, so we clamp it out\n    // Of course, that means we have to recalculate EVERYTHING *sigh*\n    const cstart = start.equivalentPositionAtLevel(level).clamp(nstart, nend)\n    const cend = end.equivalentPositionAtLevel(level).clamp(nstart, nend)\n\n    // Now, find the offset in our body string\n    const offset = new LogootInt(last_end.l(level)).sub(nstart.l(level)).js_int\n\n    const node: LogootNodeWithMeta = Object.assign(new LogootNode(), {\n      offset\n    })\n    // Find the new node length by finding the distance between the last end\n    // and the next one\n    node.length = new LogootInt(cstart.l(level)).sub(last_end.l(level)).js_int\n\n    if (node.length <= 0) {\n      last_end = cend\n      if (skip_range !== lesser) {\n        last_known_position += length\n      }\n      return\n    }\n\n    node.start = nstart.offsetLowest(offset)\n    node.known_position = last_known_position\n\n    newnodes.push(node)\n\n    last_end = cend\n    last_known_position += node.length\n    if (skip_range !== lesser) {\n      // When incrementing the known_position, we ALWAYS use the length of the\n      // whole node since we will have to skip over the node regardless of how\n      // much of it actually concerns the node being added\n      // For example, if we're adding a node around an existing node with a\n      // greater number of levels, it will have the length of zero on our\n      // current level (because it is between two positions), but we still\n      // MUST skip over its entire non-zero length\n      last_known_position += length\n    }\n  })\n  return newnodes\n}\n\n/**\n * A representation of the Logootish Document Model for mapping \"real,\"\n * continuous `known_position`s to Logoot positions. This is useful when working\n * with strings, arrays, or, just in general, anything that needs a fixed order.\n * This does not actually store the data in question, but stores a mapping of\n * real indices in the data to the Logoot positions of that element. This is\n * used to transform edits between ones in the Logoot and local position spaces.\n * One important thing to note: Logoot edits (insertions/removals) can be\n * applied in any order. Local edits **must** be applied in a consistent order.\n * @TODO Conflict resolution does not exist. **This will create significant\n * changes to this API**\n */\nclass ListDocumentModel {\n  /**\n   * The BST maps out where all insertion nodes are in the local document's\n   * memory. It is used to go from position -> node\n   */\n  ldoc_bst: KnownPositionBst = new Bst(\n    (a, b) => (a.known_position - b.known_position) as CompareResult\n  )\n  /**\n   * This BST maps Logoot position identifiers to their text node to allow\n   * lookup of text position from Logoot ID\n   */\n  logoot_bst: LogootBst = new Bst((a, b) => a.start.cmp(b.start))\n  /** A map of removals that do not yet have text to remove */\n  removal_bst: LogootBst = new Bst((a, b) => a.start.cmp(b.start))\n  /**\n   * See the Logoot paper for why. Unlike the Logoot implementation, this is\n   * incremented with each removal only and is kept constant with insertions.\n   */\n  vector_clock = new LogootInt()\n\n  /**\n   * Calculate the Logoot positions of a local insertion.\n   * @param position - The index of new text\n   * @param len - How much will be inserted\n   * @returns A Logoot insertion with a Logoot position (`start`), a vector\n   * clock value (`rclk`) (**copied** from the document), and the length passed\n   * to the function (`length`). Note that the start position is **not** copied,\n   * so if it is modified, it will mess up the sorting trees. Ensure that it is\n   * copied before modifying it.\n   * @throws {FatalError} Will throw in the event that internal corruption is\n   * encountered. If this happens, please submit an issue.\n   * @throws {Error} Will throw in the event that the position being inserted is\n   * after the end of the known document model.\n   */\n  insertLocal(\n    position: number,\n    len: number\n  ): { position: LogootPosition; rclk: LogootInt; length: number } {\n    debug.debug(`Insert into doc at ${position} + ${len}`)\n\n    // The position must be -1 for lesser because it can't count the text node\n    // currently in the insertion position (we're between two nodes)\n    const nodes_lesser = this.ldoc_bst.getLteq({ known_position: position - 1 })\n    const nodes_greater = this.ldoc_bst.getGteq({ known_position: position })\n\n    let lesser\n    let greater\n\n    // Nodes are not allowed to have the same position\n    if (nodes_lesser.length > 1 || nodes_greater.length > 1) {\n      throw new FatalError(\n        'Corrupt BST. There are multiple nodes at a position.'\n      )\n    } else {\n      lesser = nodes_lesser[0] ? nodes_lesser[0].data : undefined\n      greater = nodes_greater[0] ? nodes_greater[0].data : undefined\n    }\n\n    if (lesser && lesser.known_end_position < position) {\n      throw new Error('Position cannot be added after the end of the document.')\n    }\n\n    if (lesser && lesser.length + lesser.known_position > position) {\n      // This means that we're right inside another node, so the next position\n      // will be inside the first node\n      // Now, we must split the node in half (nodes can't overlap)\n      greater = new LogootNode()\n\n      greater.length = lesser.known_end_position - position\n      lesser.length = position - lesser.known_position\n\n      greater.known_position = position\n      greater.start = lesser.start.offsetLowest(lesser.length)\n      greater.rclk = new LogootInt(lesser.rclk)\n\n      this.ldoc_bst.add(greater)\n      this.logoot_bst.add(greater)\n    }\n\n    // Finally, we can create positions...\n    let left_position\n    let right_position\n\n    if (lesser) {\n      left_position = lesser.end\n    }\n    if (greater) {\n      right_position = greater.start\n    }\n\n    const node = new LogootNode()\n    node.start = new LogootPosition(len, left_position, right_position)\n    node.known_position = position\n    node.rclk = new LogootInt(this.vector_clock)\n    node.length = len\n\n    // Now, make a space between the nodes\n    this.ldoc_bst.operateOnAllGteq({ known_position: position }, (n) => {\n      n.data.known_position += len\n    })\n\n    this.ldoc_bst.add(node)\n    this.logoot_bst.add(node)\n\n    return {\n      position: node.start,\n      rclk: new LogootInt(this.vector_clock),\n      length: len\n    }\n  }\n\n  /**\n   * Calculate the Logoot positions and lengths of removals from a removal in\n   * the local document.\n   * @param position - The index of old text\n   * @param length - The length text that will be removed\n   * @returns An object containing an array of removals and the calculated\n   * vector clock. Each removal contains a `start` LogootPosition, which is not\n   * copied, so it **cannot be modified**, and a numeric `length`.\n   */\n  removeLocal(\n    position: number,\n    length: number\n  ): { removals: Removal[]; rclk: LogootInt } {\n    debug.debug(`Remove from doc at ${position} + ${length}`)\n\n    // First, find any nodes that MAY have content removed from them\n    const nodes = this.ldoc_bst\n      .getRange(\n        { known_position: position },\n        { known_position: position + length - 1 }\n      )\n      .concat(this.ldoc_bst.getLteq({ known_position: position - 1 }))\n      .sort((a, b) => a.data.known_position - b.data.known_position)\n\n    const removals: Removal[] = []\n    let last_end: LogootPosition\n    let cumulative_offset = 0\n    nodes.forEach(({ data }) => {\n      // 'Data' refers to the node having text removed\n\n      // Length and start of new removal\n      let newlen = data.length\n      let newstart = data.start\n\n      // Remove the ends of the node not being removed\n      if (data.known_position < position) {\n        newlen -= position - data.known_position\n        newstart = newstart.offsetLowest(position - data.known_position)\n      }\n      if (data.known_position + data.length > position + length) {\n        newlen -= data.known_position + data.length - (position + length)\n      }\n\n      if (newlen <= 0) {\n        return\n      }\n\n      // Add the removal to the last one if possible\n      if (last_end && last_end.cmp(newstart) === 0) {\n        removals[removals.length - 1].length += newlen\n      } else {\n        removals.push({\n          start: newstart,\n          length: newlen\n        })\n      }\n\n      // Record the last end so we can add another removal to it if possible\n      last_end = newstart.offsetLowest(newlen)\n\n      // Now, modify the node to remove the start region (if necessary)\n      if (data.known_position > position) {\n        data.start = data.start.offsetLowest(data.known_position - position)\n      }\n      // And remove the removal inside of it\n      data.length -= newlen\n\n      // Now apply the running total offset and calculate it for the next run\n      data.known_position -= cumulative_offset\n      cumulative_offset += newlen\n\n      if (data.length <= 0) {\n        this.logoot_bst.remove(data)\n        this.ldoc_bst.remove(data)\n      }\n    })\n\n    // Offset the nodes that come after the removal\n    this.ldoc_bst.operateOnAllGteq(\n      { known_position: position + length },\n      (n) => {\n        n.data.known_position -= length\n      }\n    )\n\n    const target_rclk = new LogootInt(this.vector_clock)\n    this.vector_clock.add(1)\n\n    return { removals, rclk: target_rclk }\n  }\n\n  /**\n   * Calculate the local positions inserted from an insertion at a Logoot\n   * position from a given length and vector clock.\n   * @param nstart - The start `LogootPosition` of the insertion\n   * @param length - The length of the insertion\n   * @param this_rclk - The vector clock when the insertion took place.\n   * @returns An object with the `insertions` member set to an array with\n   * objects containing a numeric `offset`, which represents which part of the\n   * source string the insertion is pulling from, a numeric `length`, and a\n   * numeric `known_position` where to place the string. Insertions must be\n   * applied in the order of the return value. The object also has a `removals`\n   * variable set to an array of objects containing `known_position` and\n   * `length` that represent removed conflicts with existing data. These\n   * `removals` should be applied before the `insertions`.\n   */\n  insertLogoot(\n    nstart: LogootPosition,\n    length: number,\n    this_rclk: LogootInt\n  ): {\n    insertions: { offset: number; length: number; known_position: number }[]\n    removals: { known_position: number; length: number }[]\n  } {\n    debug.debug(\n      `Insert into doc at ${nstart.toString()} + ${length} @ ${this_rclk.toString()}`\n    )\n\n    if (this_rclk.cmp(this.vector_clock) > 0) {\n      this.vector_clock.assign(this_rclk)\n      debug.info(`Fast-forward vector clock to ${this_rclk.toString()}`)\n    }\n\n    const removals: { known_position: number; length: number }[] = []\n    const nodes = _mergeNode(\n      this.logoot_bst,\n      nstart,\n      length,\n      (node, conflict, lesser) => {\n        // If we're inside and on a lower level than lesser, simply ignore it\n        if (node === lesser && lesser.start.levels < conflict.level) {\n          return 0\n        }\n        if (node.rclk.cmp(this_rclk) < 0) {\n          return -1\n        }\n        if (node.rclk.cmp(this_rclk) === 0) {\n          // TODO: Do something about conflicts that cause dropped data here\n          // This is HUGE and the editor WILL NOT FUNCTION WITHOUT IT!!!\n          // I really don't like the idea of pushing this until after initial\n          // release, but oh well.\n          // Also, does this even work?\n          debug.info('Dropped conflicting node')\n        }\n        return 1\n      },\n      (node) => {\n        // We don't add to the known_position here because the node we're adding\n        // comes from splitting an existing node\n        this.ldoc_bst.add(node)\n        this.logoot_bst.add(node)\n      },\n      (node, pos, length, whole) => {\n        if (whole) {\n          this.ldoc_bst.remove(node)\n          this.logoot_bst.remove(node)\n        }\n        removals.push({ known_position: pos, length })\n        // this.removeLocal(pos, length)\n        this.ldoc_bst.operateOnAllGteq({ known_position: pos }, (n) => {\n          if (n.data === node) {\n            return\n          }\n          n.data.known_position -= length\n        })\n      }\n    )\n\n    arraymap(nodes, (node) => {\n      let last_known_position = node.known_position\n      return _mergeNode(\n        this.removal_bst,\n        node.start,\n        node.length,\n        (node) => {\n          if (node.rclk.cmp(this_rclk) < 0) {\n            return 0\n          }\n          return 1\n        },\n        () => {},\n        () => {}\n      ).map((newnode) => {\n        // known_positions in the removal tree are BS, so set them correctly\n        // here. TODO: Remove known_position from removals\n        newnode.known_position = last_known_position\n        newnode.offset += node.offset\n        last_known_position += newnode.length\n        return newnode\n      })\n    })\n\n    const insertions: {\n      offset: number\n      length: number\n      known_position: number\n    }[] = []\n\n    nodes.forEach((node) => {\n      node.rclk = new LogootInt(this_rclk)\n      // Now, make a space between the nodes\n      this.ldoc_bst.operateOnAllGteq(node, (n) => {\n        if (n.data === node) {\n          return\n        }\n        n.data.known_position += node.length\n      })\n\n      const insertion = {\n        known_position: node.known_position,\n        offset: node.offset,\n        length: node.length\n      }\n      insertions.push(insertion)\n\n      this.ldoc_bst.add(node)\n      this.logoot_bst.add(node)\n    })\n\n    return { insertions, removals }\n  }\n\n  /**\n   * Calculate the regions of text to be removed from the local document from\n   * a Logoot position, length, and vector clock of a removal.\n   * @param start - The start at which to start removing.\n   * @param length - How much to remove.\n   * @param rclk - The vector clock of the removal.\n   * @returns An object containing a member `removals`, which is an array of\n   * objects containing a `known_position` at which to start removing and a\n   * `length`, both of which are numbers.\n   */\n  removeLogoot(\n    start: LogootPosition,\n    length: number,\n    rclk: LogootInt\n  ): { removals: { known_position: number; length: number }[] } {\n    const new_rclk = new LogootInt(rclk).add(1)\n    if (new_rclk.cmp(this.vector_clock) > 0) {\n      this.vector_clock.assign(new_rclk)\n      debug.info('Fast-forward vector clock to', JSON.stringify(new_rclk))\n    }\n\n    const end = start.offsetLowest(length)\n    // The level where our removal is happening (always the lowest)\n    const level = start.levels\n    debug.debug(\n      `Remove from doc at ${start.toString()} + ${length} @ ${rclk.toString()}`\n    )\n\n    const removals: { known_position: number; length: number }[] = []\n    // This is basically the same as the invocation in remoteInsert, only it\n    // doesn't add the resulting nodes to the BSTs\n    const nodes = _mergeNode(\n      this.logoot_bst,\n      start,\n      length,\n      (node) => {\n        // TODO: Nodes with the SAME `rclk` should still have a removal added\n        // at their position because another node with the same `rclk` as the\n        // one just removed could show up.\n        if (node.rclk.cmp(rclk) <= 0) {\n          return -1\n        }\n        return 1\n      },\n      (node) => {\n        this.ldoc_bst.add(node)\n        this.logoot_bst.add(node)\n      },\n      (node, pos, length, whole) => {\n        if (whole) {\n          this.ldoc_bst.remove(node)\n          this.logoot_bst.remove(node)\n        }\n        removals.push({ known_position: pos, length })\n        this.ldoc_bst.operateOnAllGteq({ known_position: pos }, (n) => {\n          if (n.data === node) {\n            return\n          }\n          n.data.known_position -= length\n        })\n      }\n    )\n\n    // Now, use the text nodes that stay as `skip_ranges`, like in the\n    // `_mergeNode` function, to find where the removal should be added to the\n    // removal BST\n    nodes.push({\n      start: end,\n      end,\n      length: 0,\n      known_position: 0,\n      known_end_position: 0,\n      rclk: new LogootInt(),\n      offset: 0\n    })\n\n    // I've gotten lazier and lazier with variable names as this file has\n    // gotten longer. I've regressed to single letter variable names\n    let last_end = start\n    nodes.forEach((n) => {\n      const length = new LogootInt(n.end.l(level)).sub(last_end.l(level)).js_int\n      // Now, merge this removal with possible other ones in the removal_bst\n      const nodes = _mergeNode(\n        this.removal_bst,\n        last_end,\n        length,\n        (node) => {\n          if (node.rclk.cmp(rclk) < 0) {\n            return -1\n          }\n          return 1\n        },\n        (node) => {\n          this.removal_bst.add(node)\n        },\n        (node, pos, length, whole) => {\n          if (whole) {\n            this.removal_bst.remove(node)\n          }\n        }\n      )\n\n      // Make sure the removals actually exist\n      nodes.forEach((node) => {\n        node.rclk = rclk\n        delete node.offset\n\n        this.removal_bst.add(node)\n      })\n      last_end = n.end\n    })\n\n    return { removals }\n  }\n}\n\nexport {\n  LogootInt,\n  LogootPosition,\n  KnownPositionBst,\n  LogootBst,\n  Removal,\n  ListDocumentModel,\n  _mergeNode\n}\n","// What a C++ typedef would do\n// This makes it possible to completely swap out the type of the int used in the\nimport { Int32 } from '../ints'\nimport { CompareResult } from '../utils'\n\n// algorithm w/o actually replacing each instance (which would be a real pain)\nimport LogootInt = Int32\n\n/**\n * A position in Logoot. This is just an array of numbers with some utility\n * functions. In Logoot, it must always be possible to allocate a position\n * between any possible two positions. In this algorithm, a position with more\n * `levels` (or elements in the array) comes first. So, if it is necessary to\n * create a position between `A` and `B`, then another level can be added to the\n * position to make it come after `A` and before `B`. Positions are represented\n * in writing the same as arrays: `[1,2,3]`\n * @example ```typescript\n * const a = new LogootPosition()\n * console.log(a.toString()) // [0]\n *\n * const b = a.offsetLowest(1)\n * console.log(b.toString()) // [1]\n *\n * console.log(new LogootPosition(1, a, b).toString()) // [0]\n * console.log(new LogootPosition(2, a, b).toString()) // [0,0]\n * ```\n */\nclass LogootPosition {\n  protected array: LogootInt[] = [new LogootInt(0)]\n\n  /**\n   * This constructor constructs a new position that is in the range specified\n   * by `start` and `end`. By using `len`, it is possible to enforce that a\n   * certain number of additional positions are available in the selected range.\n   * This guarantees that there's space for a LogootNode of length `len` at this\n   * position between `start` and `end`.\n   *\n   * @param len - The length of the allocation to make. The length is never\n   * actually stored in the Logoot position, but is used when finding space for\n   * the position to be created and `len` position(s) after it.\n   * @param start - This will cause the new position to have a value greater\n   * than or equal to this. This value is tricky: It must be the end of the last\n   * node. So if `A` is at `[1]` and an allocation *after* it is desired, then\n   * `[2]` would need to be passed to `start`.\n   * @param end - This will cause the new position to have a value less than or\n   * equal to this, subject to the value of `len`.\n   */\n  constructor(\n    len = 0,\n    readonly start?: LogootPosition,\n    readonly end?: LogootPosition\n  ) {\n    if (!start && end) {\n      this.array = end.inverseOffsetLowest(len).array\n    } else if (!end && start) {\n      this.array = start.copy().array\n    } else if (start && end) {\n      let done = false\n      const itstart = start.array.values()\n      const itend = end.array.values()\n      let nstart\n      let nend\n\n      this.array.length = 0\n\n      while (!done) {\n        if (!nstart || !nstart.done) {\n          nstart = itstart.next()\n        }\n        if (!nend || !nend.done) {\n          nend = itend.next()\n        }\n\n        if (!nstart.done && !nend.done) {\n          // See if we have enough space to insert 'len' between the nodes\n          if (nend.value.gteq(new LogootInt(nstart.value).add(len))) {\n            // There's space. We're done now: At the shallowest possible level\n            done = true\n          }\n          // Regardless, the start ID is the new ID for this level of our node\n          this.array.push(new LogootInt(nstart.value))\n        } else if (!nstart.done) {\n          // So there's no end restriction, that means we can just add right on\n          // top of the old end (the start of the new node)\n          this.array.push(new LogootInt(nstart.value))\n          done = true\n        } else if (!nend.done) {\n          // We have an end restriction, but no start restriction, so we just\n          // put the new node's start behind the old end\n          this.array.push(new LogootInt(nend.value).sub(len))\n          done = true\n        } else {\n          // So both other IDs have nothing else. It must be time to make a new\n          // level and be done\n          this.array.push(new LogootInt())\n          done = true\n        }\n      }\n    }\n  }\n\n  static fromJSON(eventnode: LogootPosition.JSON): LogootPosition {\n    const pos = new LogootPosition()\n    pos.array.length = 0\n    eventnode.forEach((n) => {\n      pos.array.push(LogootInt.fromJSON(n))\n    })\n    return pos\n  }\n  toJSON(): LogootPosition.JSON {\n    return this.array.map((n) => n.toJSON())\n  }\n\n  /**\n   * @returns Internal array length\n   */\n  get length(): number {\n    // A zero-length position is NOT valid\n    // Through some sneakiness, you COULD directly assign the array to make it\n    // have a length of zero. Don't do it.\n    return this.array.length\n  }\n  /**\n   * Returns the last index of the array. This is useful because before this,\n   * the algorithm code often contained many occurences of `length - 1`. This\n   * is used to cut down redundancy.\n   */\n  get levels(): number {\n    // A zero-length position is NOT valid\n    // Through some sneakiness, you COULD directly assign the array to make it\n    // have a length of zero. Don't do it.\n    return this.length - 1\n  }\n  /**\n   * An array accessor\n   */\n  level(n: number): LogootInt {\n    return this.array[n]\n  }\n  /**\n   * An array accessor\n   * @alias level\n   */\n  l(n: number): LogootInt {\n    return this.level(n)\n  }\n\n  /**\n   * Returns a new position with `offset` added to the lowest level of the\n   * position.\n   */\n  offsetLowest(offset: number | LogootInt): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((current, i, array) => {\n        return i < array.length - 1\n          ? current\n          : new LogootInt(current).add(offset)\n      })\n    })\n  }\n  /**\n   * Returns a new position with `offset` subtracted from the lowest level of\n   * the position.\n   */\n  inverseOffsetLowest(offset: number | LogootInt): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((current, i, array) => {\n        return i < array.length - 1\n          ? current\n          : new LogootInt(current).sub(offset)\n      })\n    })\n  }\n\n  /**\n   * Duplicates this position.\n   */\n  copy(): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((e) => new LogootInt(e))\n    })\n  }\n\n  /**\n   * Return a copy of this position, but with the number of levels specified by\n   * `level`. If this position has fewer levels, zeroes will be added in place.\n   */\n  equivalentPositionAtLevel(level: number): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: new Array(level + 1).fill(0, 0, level + 1).map((el, i) => {\n        return new LogootInt(this.array[i])\n      })\n    })\n  }\n\n  cmp(pos: LogootPosition, level = 0): CompareResult {\n    if (level >= this.length) {\n      if (this.length === pos.length) {\n        return 0\n      }\n      return 1\n    }\n    if (level >= pos.length) {\n      return -1\n    }\n    switch (this.level(level).cmp(pos.level(level))) {\n      case 1:\n        return 1\n      case -1:\n        return -1\n      case 0:\n        return this.cmp(pos, level + 1)\n      default:\n        return 0\n    }\n  }\n\n  /**\n   * Return this position if it is between `min` or `max`, otherwise return\n   * `min` if this is less and `max` if this is greater.\n   * @param min - The minimum output.\n   * @param max - The maximum output.\n   * @param preserve_levels - If defined, the output number of levels will be\n   * equal to `preserve_levels`.\n   */\n  clamp(\n    min: LogootPosition,\n    max: LogootPosition,\n    preserve_levels?: undefined | number\n  ): LogootPosition {\n    const clamped = this.cmp(min) < 0 ? min : this.cmp(max) > 0 ? max : this\n    if (preserve_levels !== undefined) {\n      return clamped.equivalentPositionAtLevel(preserve_levels)\n    } else {\n      return clamped.copy()\n    }\n  }\n\n  toString(): string {\n    let str = '['\n    this.array.forEach((el, i, a) => {\n      str += el.toString() + (i >= a.length - 1 ? '' : ',')\n    })\n    str += ']'\n    return str\n  }\n}\nnamespace LogootPosition {\n  export type JSON = LogootInt.JSON[]\n  export namespace JSON {\n    export const Schema = { type: 'array', items: LogootInt.JSON.Schema }\n  }\n}\n\n/**\n * Logoot treats each atom as seperate. However, in a real-world environment, it\n * is not practical to treat each atom seperately. To save memory and CPU time,\n * the algorithm groups together consecutive atoms into `LogootNode`s. A\n * `LogootNode` is technically just a series of consecutive atoms with the same\n * `rclk` (vector clock).\n */\nclass LogootNode {\n  /**\n   * The position of the node in the local document.\n   */\n  known_position = 0\n  length = 0\n  start: LogootPosition = new LogootPosition()\n  rclk: LogootInt = new LogootInt(0)\n\n  /**\n   * @param node - A node to copy, C++ style\n   */\n  constructor(node?: LogootNode) {\n    if (node) {\n      Object.assign(this, {\n        known_position: node.known_position,\n        length: node.length,\n        start: node.start.offsetLowest(new LogootInt()),\n        rclk: new LogootInt(node.rclk)\n      })\n    }\n  }\n\n  /**\n   * The end of the node. Note that technically there is not an atom at this\n   * position, so it's fair game to have another node placed at this position.\n   */\n  get end(): LogootPosition {\n    return this.start.offsetLowest(this.length)\n  }\n  /**\n   * The end of the node in the local document.\n   */\n  get known_end_position(): number {\n    return this.known_position + this.length\n  }\n\n  toString(): string {\n    return (\n      this.start.toString() +\n      (typeof this.known_position === 'number'\n        ? '(' + this.known_position + ')'\n        : '') +\n      ` + ${this.length} @ ${this.rclk}`\n    )\n  }\n}\ntype LogootNodeWithMeta = LogootNode & { offset: number }\n\nexport { LogootInt, LogootPosition, LogootNode, LogootNodeWithMeta }\n","/**\n * @file Various utilities that don't belong anywhere else.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n\n/**\n * Like the built-in map function, but it replaces the element with an arbitrary\n * number of elements, making it a combination of map, push, and filter.\n * @template T - The type of the array elements.\n * @param array - The array to map. It will be modified.\n * @param fn - The element mapper function. It takes the current element as an\n * argument and returns the element(s) take its place.\n * @return The same array that was passed as an argument.\n */\nfunction arraymap<T>(array: T[], fn: (el: T) => T[]): T[] {\n  for (let i = 0; i < array.length; ) {\n    const newarray = fn(array[i])\n    array.splice(i, 1, ...newarray)\n    i += newarray.length ? newarray.length : 1\n  }\n  return array\n}\n\n/**\n * A class created with a variable `fatal` added and set to true. This is used\n * for ensuring that a client knows to shut down a document if an error has\n * indicated that the document is corrupt.\n */\nclass FatalError extends Error {\n  fatal = true\n}\n\n/**\n * One of zero, one, or negative one.\n */\ntype CompareResult = -1 | 0 | 1\n/**\n * A function type that takes `T` and returns a CompareResult.\n */\ntype CompareFunction<T> = (other: T) => CompareResult\n/**\n * A function type that takes two of a type `T` and returns a CompareResult.\n */\ntype DualCompareFunction<T> = (a: T, b: T) => CompareResult\n\n/**\n * A utility abstract class with no implementation for the function `cmp` and\n * implementations for `gt`, `gteq`, `eq`, `lteq`, and `lt` functions.\n * @template T The other type that can be compared.\n */\nabstract class Comparable<T> {\n  /**\n   * Compare this object to another one.\n   */\n  abstract cmp(other: T): CompareResult\n  /**\n   * @return True if this object is greater than the one provided.\n   */\n  gt(n: T): boolean {\n    return this.cmp(n) === 1\n  }\n  /**\n   * @return True if this object is greater than or equal to the one provided.\n   */\n  gteq(n: T): boolean {\n    return this.cmp(n) >= 0\n  }\n  /**\n   * @return True if this object is equal to the one provided.\n   */\n  eq(n: T): boolean {\n    return this.cmp(n) === 0\n  }\n  /**\n   * @return True if this object is less than or equal to the one provided.\n   */\n  lteq(n: T): boolean {\n    return this.cmp(n) <= 0\n  }\n  /**\n   * @return True if this object is less than the one provided.\n   */\n  lt(n: T): boolean {\n    return this.cmp(n) === -1\n  }\n}\n\n/**\n * Designed to emulate pointers to members of an object. This is useful inside\n * the B-trees. This should not be used like a C pointer: If the value in the\n * destination object changes, so does the value reported by this object.\n * @template T - The container object type.\n * @template K - The key inside the object.\n */\nclass MemberPtr<T, K extends keyof T> {\n  private obj: T\n  private key: K\n  /**\n   * @param obj - The object with the member to reference.\n   * @param key - The key of the reference inside the object.\n   */\n  constructor(obj: T, key: K) {\n    this.obj = obj\n    this.key = key\n  }\n  /**\n   * The value of the 'pointer.'\n   */\n  get value(): T[K] {\n    return this.obj[this.key]\n  }\n  set value(val: T[K]) {\n    this.obj[this.key] = val\n  }\n}\n\nexport {\n  arraymap,\n  FatalError,\n  CompareResult,\n  CompareFunction,\n  DualCompareFunction,\n  Comparable,\n  MemberPtr\n}\n"],"sourceRoot":""}