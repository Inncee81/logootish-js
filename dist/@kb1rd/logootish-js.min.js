!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("@kb1rd/logootish-js",[],e):"object"==typeof exports?exports["@kb1rd/logootish-js"]=e():t["@kb1rd/logootish-js"]=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function r(o){if(e[o])return e[o].exports;var n=e[o]={i:o,l:!1,exports:{}};return t[o].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=t,r.c=e,r.d=function(t,e,o){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)r.d(o,n,function(e){return t[e]}.bind(null,n));return o},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=1)}([function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.arraymap=function(t,e){for(let r=0;r<t.length;){const o=e(t[r]);t.splice(r,1,...o),r+=o.length?o.length:1}return t};class o extends Error{constructor(){super(...arguments),this.fatal=!0}}e.FatalError=o;e.Comparable=class{gt(t){return 1===this.cmp(t)}gteq(t){return this.cmp(t)>=0}eq(t){return 0===this.cmp(t)}lteq(t){return this.cmp(t)<=0}lt(t){return-1===this.cmp(t)}};function n(t){return Object.keys(t).concat(Object.getOwnPropertySymbols(t))}e.MemberPtr=class{constructor(t,e){this.obj=t,this.key=e}get value(){return this.obj[this.key]}set value(t){this.obj[this.key]=t}},e.allKeys=n,e.allValues=function(t){return n(t).map(e=>t[e])};const s={};e.BreakException=s,e.catchBreak=function(t){try{t()}catch(t){if(t!==s)throw t}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const o=r(2);var n;e.ListDocumentModel=o.ListDocumentModel,e.LogootInt=o.LogootInt,e.LogootPosition=o.LogootPosition,e.NodeType=o.NodeType,function(t){t[t.PENDING=0]="PENDING",t[t.SENDING=1]="SENDING",t[t.COMPLETE=2]="COMPLETE"}(n||(n={})),e.EventState=n},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const o=r(0),n=r(3),s=r(4);e.LogootInt=s.LogootInt,e.LogootPosition=s.LogootPosition,e.NodeType=s.NodeType;class i extends Error{}const a=(t,e)=>!t.branches.filter(t=>!e.br(t)).length&&!e.branches.filter(e=>!t.br(e)).length;e.ListDocumentModel=class{constructor(t,e=a){this.ldoc_bst=new n.Bst((t,e)=>{if(t.known_position>e.known_position)return 1;if(t.known_position<e.known_position)return-1;{const r=t.logoot_start,o=e.logoot_start;if(r&&o)return r.cmp(o)}return 0}),this.logoot_bst=new n.Bst((t,e)=>t.start.cmp(e.start)),this.clock=new s.LogootInt,this.branch=t,this.canJoin=e}insertLocal(t,e){const r=this.ldoc_bst.create_range_search();r.lesser_find_greatest=!0,r.greater_find_least=!0,r.push_point({known_position:t},"_lesser",!1),r.all_greater("_greater");const{_lesser:n,_greater:a}=this.ldoc_bst.search(r);let l,h,c,u;n&&n.length&&(l=n.sort((t,e)=>t.logoot_start.cmp(e.logoot_start))[0]),a&&a.length&&(h=a.sort((t,e)=>e.logoot_start.cmp(t.logoot_start))[0]);const p=l?l.ldoc_length:0;if(l&&l.known_position+p===t){if(h&&l.last_branch===h.first_branch&&l.last_branch!==this.branch)throw new i;c=l.logoot_end,u=h?h.logoot_start:void 0}else l?(()=>{let e=t-l.known_position;if(l.branch_order.indexOf(this.branch)<0?e-=l.ldoc_length:e-=l.branchLength(l.branch_order.slice(0,l.branch_order.indexOf(this.branch))),e<0)throw new o.FatalError("Search returned out of order nodes");if(0===e){const t=this.ldoc_bst.create_range_search();t.lesser_find_greatest=!0,t.push_point({known_position:l.known_position},"_lesser",!1);const{_lesser:e}=this.ldoc_bst.search(t);let r;return e&&e.length&&(r=e.sort((t,e)=>t.logoot_start.cmp(e.logoot_start))[0]),c=r.logoot_end,void(u=l.logoot_start)}for(let t=0;t<l.groups.length;t++){const{end:r}=l.groups[t];if(e-=l.groups[t].branchLength([this.branch]),e<0)return void(c=u=r.inverseOffsetLowest(-e));if(0===e)return c=r,void(u=l.groups[t+1]?l.groups[t+1].start:h?h.logoot_start:void 0)}throw new i})():h&&(u=h.logoot_start);return{start:new s.LogootPosition(e,c,u),length:e,br:this.branch,rclk:this.clock}}removeLocal(t,e){const r=this.ldoc_bst.create_range_search();r.lesser_find_greatest=!0,r.greater_find_least=!0,r.push_point({known_position:t},"_lesser",!1),r.push_point({known_position:t+e},"_range",!1),r.all_greater(void 0);const{_lesser:n,_range:i}=this.ldoc_bst.search(r),a=i||[];if(n&&n.length){const e=n.sort((t,e)=>t.logoot_start.cmp(e.logoot_start))[0];e.ldoc_end>t&&a.unshift(e)}const l={};let h=t+e-a[0].known_position;o.catchBreak(()=>a.forEach(t=>{t.branch_order.forEach(r=>{t.groups.forEach(t=>{if(!t.br(r))return;let{start:n,length:i}=t;const{type:a,rclk:c}=t.br(r);if(a===s.NodeType.DATA&&(h>e&&(n=n.offsetLowest(h-e),i-=h-e),function(t,e,r,o){if(r<=0)return;l[t]||(l[t]={});const n=l[t];n[e.levels]||(n[e.levels]=[]);const s=n[e.levels],i=s[s.length-1];i&&i.branch===t&&0===i.start.offsetLowest(i.length).cmp(e)&&0===i.rclk.cmp(o)?i.length+=r:s.push({branch:t,start:e,length:r,rclk:o})}(r,n,Math.min(i,h),c),h-=t.length),h<=0)throw o.BreakException})})}));const c=[];return o.allValues(l).forEach(t=>{Object.entries(t).forEach(([,t])=>{t.forEach(t=>c.push(t))})}),{removals:c}}_mergeNode(t,e,r,n,i,a){const l=e.levels,h=e.offsetLowest(r);this.clock.cmp(n)<0&&this.clock.assign(n);const c=this.logoot_bst.create_range_search();c.lesser_find_greatest=!0,c.greater_find_least=!0,c.push_point({start:e},"_lesser",!1),c.push_point({start:h},"_skip_ranges",!1),c.all_greater("_greater");const{_lesser:u,_skip_ranges:p,_greater:g}=this.logoot_bst.search(c);let d,f;if(u&&u.length>1)throw new o.FatalError("Corrupt BST. There are multiple nodes at a position.");if(u&&u.length&&(d=u[0]),g&&g.length>1)throw new o.FatalError("Corrupt BST. There are multiple nodes at a position.");g&&g.length&&(f=g[0]);let _=p?p.sort((t,e)=>t.start.cmp(e.start)):[];if(d&&_.includes(d)&&_.splice(_.indexOf(d),1),f&&_.includes(f)&&_.splice(_.indexOf(f),1),d&&_.unshift(d),d&&d.start.levels<l&&d.start.cmp(e)<0&&d.end.cmp(h)>0){const t=e.copy().level(d.start.levels).sub(d.start.level(d.start.levels)).js_int;if(t>0&&t<d.length){const e=d.splitAround(t);_.push(e),this.logoot_bst.add(e)}}f&&!_.includes(f)&&_.push(f);let b=[];if(_.forEach(({group:t})=>{t&&!b.includes(t)&&t.branch_order.length&&b.push(t)}),b=b.sort((t,e)=>t.known_position-e.known_position),_=_.filter(({start:t})=>t.levels>=l||t.cmp(h)>=0),!_.length||_[_.length-1].start.cmp(h)<0){const t=new s.LogootNodeGroup;t.start=h,_.push(t)}const w=b.length?b[b.length-1].ldoc_end:0,m=[];let v=0;const y=(t,e,r,o)=>{v+=r;const n=t.logoot_start;for(let s=b.length-1;s>0;s--){const i=b[s];if(o){if(i.known_position<e||i.logoot_start.cmp(n)<0)return}else if(i.known_position<=e||i.logoot_start.cmp(n)<=0)return;i!==t&&(b[s].known_position+=r)}},k=(t,e,r,o)=>{0!==o&&(m.push({type:"i",start:e,offset:r,length:o}),y(t,e,o,!0))},O=(t,e,r)=>{0!==e&&t!==r&&m.push({type:"t",source:t,length:e,dest:r})},A=(t,e,r=(()=>{}))=>{if(!t.groups.includes(e))throw new o.FatalError("Node group not in conflict group.");if(!b.includes(t))throw new o.FatalError("Conflict group not in conflict_order");const n=new s.ConflictGroup(t.ldoc_end);let i=t.known_position;const a=n.known_position;return t.branch_order.forEach(r=>{const s=(()=>{let n=0;for(let o=0;o<t.groups.length;o++)if(n+=t.groups[o].branchLength([r]),t.groups[o]===e)return n;throw new o.FatalError})();n.branch_order.push(r);const l=t.branchLength([r])-s;n.known_position-=l,i+=s,O(i,l,a-l)}),n.groups=t.groups.splice(t.groups.indexOf(e)+1,t.groups.length),n.groups.forEach(t=>t.group=n),r(n),this.ldoc_bst.add(n),b.splice(b.indexOf(t)+1,0,n),n},L=(t,e)=>{e.branch_order.forEach(e=>{t.branch_order.includes(e)||t.branch_order.push(e)}),e.groups.forEach(e=>e.group=t),t.groups.splice(t.groups.length,0,...e.groups);let r=e.known_position,o=t.known_position;e.branch_order.forEach(n=>{o+=t.branchLength([n]);const s=e.branchLength([n]);O(r,s,o-s),r+=s}),e.branch_order.length=0,e.groups=[],this.ldoc_bst.remove(e,t=>t===e),b.splice(b.indexOf(e),1)};let E=e.level(l),P=d;return _.forEach((o,c)=>{let u=_[c+1];const p=o.start.clamp(e,h,l).l(l),g=o.end.clamp(e,h,l).l(l),d=p.copy().sub(E).js_int,f=E.copy().sub(e.l(l)).js_int;if(d>0||o.start.levels<l&&r-f>0&&o.start.cmp(e)>0&&E.cmp(e.l(l))<0){const h=new s.LogootNodeGroup;h.start=e.copy(),h.start.l(l).assign(E),h.length=d||r-f,h.br(t,{type:i,rclk:n});const c=P&&a(P,h),u=o&&a(h,o),p=P&&o&&P.group===o.group;!p&&c&&u?L(P.group,o.group):!p||c&&u||A(P.group,P),c||u?h.group=c?P.group:o.group:(h.group=new s.ConflictGroup(P?P.group.ldoc_end:0),h.group.branch_order.push(t),b.splice(P?b.indexOf(P.group)+1:0,0,h.group)),i===s.NodeType.DATA?k(h.group,h.group.insertSingleBranchGroup(h),f,h.length):h.group.insertSingleBranchGroup(h),P=h,this.logoot_bst.add(h),c||u||this.ldoc_bst.add(h.group)}const w=g.copy().sub(p).js_int,v=p.copy().sub(e.l(l)).js_int;if(o.start.levels===l&&w>0&&(!o.br(t)||n.cmp(o.br(t).rclk)>(i===s.NodeType.DATA?0:-1))){if(o.start.cmp(e)<0&&(P=o,o=o.splitAround(e.l(l).sub(o.start.l(l)).js_int),this.logoot_bst.add(o)),o.end.cmp(h)>0){const t=o.splitAround(o.length-o.end.l(l).sub(h.l(l)).js_int);this.logoot_bst.add(t),u=t}o.group.branch_order.includes(t)||o.group.branch_order.push(t);const r=o.group.insertPos(t,o);o.br(t)&&o.br(t).type===s.NodeType.DATA&&((t,e,r)=>{0!==r&&(m.push({type:"r",start:e,length:r}),y(t,e,-r,!0))})(o.group,r,o.length),o.br(t,{type:i,rclk:n}),i===s.NodeType.DATA&&k(o.group,r,v,o.length);const c=(t,e,r=!1)=>{if(!t||!e)return;const n=t.group===e.group,l=a(t,e);if(!n&&l)L(t.group,e.group);else if(n&&!l){const e=A(t.group,t,t=>{i===s.NodeType.DATA&&r&&(t.known_position-=o.length)});i===s.NodeType.DATA&&r&&(e.known_position+=o.length)}};c(P,o,!1),c(o,u,!0)}E=o.end.clamp(e,h,l).level(l),P=o}),b.forEach(({known_position:t,ldoc_length:e,conflicted:r})=>{((t,e,r)=>{0!==e&&m.push({type:"m",start:t,length:e,conflicting:r})})(t,e,r)}),this.ldoc_bst.operateOnAllGteq({known_position:w},({data:t})=>{if(!t.groups.length)throw new o.FatalError("An empty conflict group was found in the BST");t.logoot_start.cmp(h)<0||b.includes(t)||(t.known_position+=v)},!1),m}insertLogoot(t,e,r,o){return this._mergeNode(t,e,r,o,s.NodeType.DATA,this.canJoin)}removeLogoot(t,e,r,o){return this._mergeNode(t,e,r,o,s.NodeType.REMOVAL,this.canJoin)}selfTest(){let t,e=0;this.ldoc_bst.operateOnAll(({data:r})=>{if(!r.groups.length)throw new o.FatalError("Node with no groups detected.");if(r.known_position!==e)throw new Error(`Ldoc is out of order. Found known position ${r.known_position} after ${e}`);e=r.ldoc_end,r.groups.forEach(({start:e})=>{if(t&&t.cmp(e)>=0)throw new o.FatalError(`Ldoc is out of order. Found ${e.toString()} after ${t.toString()}.`);t=e})})}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const o=r(0);class n{constructor(t){this.data=t}}e.BstNode=n;class s{constructor(t){this.lesser_find_greatest=!1,this.greater_find_least=!1,this.points=[],this.cf=t}static lteq(t,e,r){const o=new s(t);return o.points.push([e,!0,r]),o.last_bucket=void 0,o}static lt(t,e,r){const o=new s(t);return o.points.push([e,!1,r]),o.last_bucket=void 0,o}static gteq(t,e,r){const o=new s(t);return o.points.push([e,!1,void 0]),o.last_bucket=r,o}static gt(t,e,r){const o=new s(t);return o.points.push([e,!0,void 0]),o.last_bucket=r,o}push_point(t,e,r=!1){const o=[t,r,e];for(let e=0;e<this.points.length;e++)if(this.cf(t,this.points[e][0])<0)return void this.points.splice(e,0,o);this.points.push(o)}all_greater(t){this.last_bucket=t}getBucketInfo(t,e,r=!1,o){let n=!1,s=!1,i=this.last_bucket,a=Boolean(this.last_bucket);!this.points.length&&this.last_bucket&&(!n&&o&&o(),n=!0);for(let l=0;l<this.points.length;l++){const[h,c,u]=this.points[l];u&&!s&&(!n&&o&&o(),n=!0),this.cf(t,h)<(c?1:0)&&(s||(s=!0,i=u),0==l&&this.lesser_find_greatest&&r&&e[u]&&e[u].length&&(this.cf(e[u][0],t)<0?e[u]=[]:this.cf(e[u][0],t)>0&&(i=void 0))),u&&s&&0!==this.cf(h,t)&&(a=!0)}if(!s&&this.last_bucket){const s=this.last_bucket;i&&!n&&(n=!0,o()),this.greater_find_least&&r&&e[s]&&e[s].length&&(this.cf(e[s][0],t)>0?e[s]=[]:this.cf(e[s][0],t)<0&&(i=void 0)),a=!0}return n=n&&(!this.lesser_find_greatest||!this.points.length||!e[this.points[0][2]]||!e[this.points[0][2]].length||this.cf(e[this.points[0][2]][0],t)<=0),a=a&&(!this.greater_find_least||!e[this.last_bucket]||!e[this.last_bucket].length||this.cf(e[this.last_bucket][0],t)>=0),{left:n,bucket:i,right:a}}sort(t,e={}){let r;for(r=0;r<this.points.length;r++){const[o,n,s]=this.points[r];if(this.cf(t,o)<(n?1:0))return s?((!e[s]||0===r&&this.lesser_find_greatest&&e[s].length&&this.cf(e[s][0],t)<0)&&(e[s]=[]),e[s].push(t),e):e}r=this.points.length;const o=this.last_bucket;return o?((!e[o]||this.greater_find_least&&e[o].length&&this.cf(e[o][0],t)>0)&&(e[o]=[]),e[o].push(t),e):e}search_array(t){const e={};return t.forEach(t=>this.sort(t,e)),e}}e.RangeSearch=s;e.Bst=class{constructor(t){this.bst_root=void 0,this.cmp=t}gteqcmp(t,e){return this.cmp(t,e)>=0}gtcmp(t,e){return this.cmp(t,e)>0}eqcmp(t,e){return 0===this.cmp(t,e)}add(t,e=new o.MemberPtr(this,"bst_root")){e.value?this.gteqcmp(e.value.data,t)?this.add(t,new o.MemberPtr(e.value,"left")):this.add(t,new o.MemberPtr(e.value,"right")):e.value=new n(t)}create_range_search(){return new s(this.cmp)}search(t,e=new o.MemberPtr(this,"bst_root"),r={}){if(!e.value)return r;const{bucket:n,right:s}=t.getBucketInfo(e.value.data,r,!0,()=>{this.search(t,new o.MemberPtr(e.value,"left"),r)});return n&&(r[n]||(r[n]=[]),r[n].push(e.value.data)),s&&this.search(t,new o.MemberPtr(e.value,"right"),r),r}_getInorderSuccessor(t,e=new o.MemberPtr(this,"bst_root")){let r;const n=t=>{(!r||t&&this.gtcmp(r.data,t.data))&&(r=t)};return e.value&&(this.gteqcmp(e.value.data,t)&&(this.eqcmp(e.value.data,t)||n({ptr:e,data:e.value.data}),n(this._getInorderSuccessor(t,new o.MemberPtr(e.value,"left")))),n(this._getInorderSuccessor(t,new o.MemberPtr(e.value,"right")))),r}remove(t,e=(()=>!0),r=new o.MemberPtr(this,"bst_root")){if(r.value){const n=this.cmp(r.value.data,t),s=e(r.value.data);if(n>0)this.remove(t,e,new o.MemberPtr(r.value,"left"));else if(n<0)this.remove(t,e,new o.MemberPtr(r.value,"right"));else if(r.value.left&&r.value.right&&s){const t=this._getInorderSuccessor(r.value.data,r);this.remove(t.data,void 0,t.ptr),r.value.data=t.data}else s&&(r.value=r.value.left||r.value.right)}}operateOnAllRange(t,e,r,o=this.bst_root,n=!1){o&&!n&&(this.gteqcmp(o.data,t)?this.gteqcmp(e,o.data)?(this.operateOnAllRange(t,e,r,o.left,!o.left),this.operateOnAllRange(t,e,r,o.right,!o.right),r(o)):this.operateOnAllRange(t,e,r,o.left,!o.left):this.operateOnAllRange(t,e,r,o.right,!o.right))}operateOnAllGteq(t,e,r=!0,n=new o.MemberPtr(this,"bst_root")){n.value&&(this.gteqcmp(n.value.data,t)&&(r||e(n.value),this.operateOnAllGteq(t,e,r,new o.MemberPtr(n.value,"left")),r&&e(n.value)),this.operateOnAllGteq(t,e,r,new o.MemberPtr(n.value,"right")))}operateOnAllLteq(t,e,r=!0,n=new o.MemberPtr(this,"bst_root")){n.value&&(this.gteqcmp(t,n.value.data)?(r||e(n.value),this.operateOnAllLteq(t,e,r,new o.MemberPtr(n.value,"left")),r&&e(n.value),this.operateOnAllLteq(t,e,r,new o.MemberPtr(n.value,"right"))):this.operateOnAllLteq(t,e,r,new o.MemberPtr(n.value,"left")))}operateOnAll(t,e=!0,r=new o.MemberPtr(this,"bst_root")){r.value&&(e||t(r.value),this.operateOnAll(t,e,new o.MemberPtr(r.value,"left")),e&&t(r.value),this.operateOnAll(t,e,new o.MemberPtr(r.value,"right")))}getRange(t,e){const r=[];return this.operateOnAllRange(t,e,t=>r.push(t)),r}getGteq(t){let e=[];return this.operateOnAllGteq(t,t=>{!e[0]||this.gtcmp(e[0].data,t.data)?e=[t]:this.eqcmp(e[0].data,t.data)&&e.push(t)}),e}getLteq(t){let e=[];return this.operateOnAllLteq(t,t=>{!e[0]||this.gtcmp(t.data,e[0].data)?e=[t]:this.eqcmp(e[0].data,t.data)&&e.push(t)}),e}toString(){let t="BST [\n";return this.operateOnAll(({data:e})=>{t+="  "+e.toString().split("\n").join("\n  ")+"\n"}),t+="]",t}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const o=r(5),n=r(0);var s,i=o.Int32;e.LogootInt=i;class a{constructor(t=0,e,r){if(this.start=e,this.end=r,this.array=[new i(0)],!e&&r)this.array=r.inverseOffsetLowest(t).array;else if(!r&&e)this.array=e.copy().array;else if(e&&r){let o=!1;const n=e.array.values(),s=r.array.values();let a,l;for(this.array.length=0;!o;)a&&a.done||(a=n.next()),l&&l.done||(l=s.next()),a.done||l.done?a.done?l.done?(this.array.push(new i),o=!0):(this.array.push(new i(l.value).sub(t)),o=!0):(this.array.push(new i(a.value)),o=!0):(l.value.gteq(new i(a.value).add(t))&&(o=!0),this.array.push(new i(a.value)))}}static fromJSON(t){const e=new a;return e.array.length=0,t.forEach(t=>{e.array.push(i.fromJSON(t))}),e}static fromInts(...t){const e=new a;return e.array.length=0,t.forEach(t=>{e.array.push(new i(t))}),e}toJSON(){return this.array.map(t=>t.toJSON())}get length(){return this.array.length}get levels(){return this.length-1}level(t){return this.array[t]}l(t){return this.level(t)}offsetLowest(t){return Object.assign(new a,{array:this.array.map((e,r,o)=>r<o.length-1?e:new i(e).add(t))})}inverseOffsetLowest(t){return Object.assign(new a,{array:this.array.map((e,r,o)=>r<o.length-1?e:new i(e).sub(t))})}copy(){return Object.assign(new a,{array:this.array.map(t=>new i(t))})}equivalentPositionAtLevel(t){return Object.assign(new a,{array:new Array(t+1).fill(0,0,t+1).map((t,e)=>new i(this.array[e]))})}cmp(t,e=0){if(e>=this.length)return this.length===t.length?0:1;if(e>=t.length)return-1;switch(this.level(e).cmp(t.level(e))){case 1:return 1;case-1:return-1;case 0:return this.cmp(t,e+1);default:return 0}}clamp(t,e,r){const o=this.cmp(t)<0?t:this.cmp(e)>0?e:this;return void 0!==r?o.equivalentPositionAtLevel(r):o.copy()}toString(){let t="[";return this.array.forEach((e,r,o)=>{t+=e.toString()+(r>=o.length-1?"":",")}),t+="]",t}}e.LogootPosition=a,function(t){let e;!function(t){t.Schema={type:"array",items:i.JSON.Schema}}(e=t.JSON||(t.JSON={}))}(a||(a={})),e.LogootPosition=a,function(t){t[t.DATA=0]="DATA",t[t.REMOVAL=1]="REMOVAL"}(s||(s={})),e.NodeType=s;const l={[s.DATA]:"DATA",[s.REMOVAL]:"REMOVAL"};e.ConflictGroup=class{constructor(t){this.known_position=0,this.branch_order=[],this.groups=[],this.known_position=t}get ldoc_length(){return this.groups.reduce((t,e)=>t+e.ldoc_length,0)}get ldoc_end(){return this.known_position+this.ldoc_length}get logoot_start(){return this.groups[0]?this.groups[0].start:void 0}get logoot_end(){return this.groups.length?this.groups[this.groups.length-1].end:void 0}get first_branch(){return this.branch_order[0]}get last_branch(){return this.branch_order.length?this.branch_order[this.branch_order.length-1]:void 0}get conflicted(){return this.groups.some(t=>t.conflicted)}branchLength(t){return this.groups.reduce((e,r)=>e+r.branchLength(t),0)}insertPos(t,e){let r=this.known_position+this.branchLength(this.branch_order.slice(0,this.branch_order.indexOf(t)+(e?0:1)));if(!e)return r;for(let o=0;o<this.groups.length;o++){if(this.groups[o]===e)return r;r+=this.groups[o].branchLength([t])}throw new n.FatalError("Tried to insert after a LogootNodeGroup that is not in this conflict group")}getNeighbors({start:t}){let e;for(let r=0;r<this.groups.length;r++)if(this.groups[r].start.cmp(t)<=0&&(e=this.groups[r]),this.groups[r].start.cmp(t)>0)return{left:e,right:this.groups[r],pos:r};return{left:e,right:void 0,pos:this.groups.length}}insertSingleBranchGroup(t){if(1!==t.n_branches)throw new TypeError("Passed group with no or more than one branch");if(t.group!==this)throw new TypeError("Conflict group not assigned to node group");const e=t.branches[0];this.branch_order.includes(e)||this.branch_order.push(e);const{right:r,pos:o}=this.getNeighbors(t),n=this.insertPos(e,r);return this.groups.splice(o,0,t),n}toString(){let t=`Conflict @ ${this.known_position} (`;return t+=this.branch_order.map(t=>t.toString()).join(" "),t+=") {",t+=this.groups.map(t=>"\n  "+t.toString().split("\n").join("\n  ")),t+="\n}",t}};class h{constructor(t){this.length=0,this.start=new a,this.nodes={},t&&(Object.assign(this,{length:t.length,start:t.start.copy(),group:t.group}),t.eachNode(({type:t,rclk:e},r)=>{this.br(r,{type:t,rclk:new i(e)})}))}get ldoc_length(){return this.branches.reduce((t,e)=>this.br(e).type===s.DATA?t+this.length:t,0)}branchLength(t){return this.branches.filter(e=>t.includes(e)).reduce((t,e)=>this.br(e).type===s.DATA?t+this.length:t,0)}get end(){return this.start.offsetLowest(this.length)}get branches(){return n.allKeys(this.nodes)}get n_branches(){return this.branches.length}get conflicted(){return this.n_branches>1}eachNode(t){this.branches.forEach(e=>{t(this.br(e),e)})}mapNodes(t){const e={};return this.branches.forEach(r=>{e[r]=t(this.br(r),r)}),e}br(t,e){return e&&(this.nodes[t]=e),this.nodes[t]}delBr(t){delete this.nodes[t]}splitAround(t){const e=new h(this);e.start=this.start.offsetLowest(t),e.length=this.length-t;const r=e.group.groups;return r.splice(r.indexOf(this)+1,0,e),this.length=t,e}toString(){let t=`Group ${this.start.toString()} + ${this.length} {`;return t+=this.branches.map(t=>{const e=this.br(t);return`\n  ${String(t)}: ${l[e.type]} @ ${e.rclk.toString()}`}),t+="\n}",t}}e.LogootNodeGroup=h},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const o=r(0);class n extends o.Comparable{}e.IntType=n;class s extends n{constructor(t=0){super(),this.int32=new Int32Array([0]),this.int32[0]=t instanceof s?t.int32[0]:t}static fromJSON(t){return new s(t)}toJSON(){return this.int32[0]}add(t){return this.int32[0]+=t instanceof s?t.int32[0]:t,this}sub(t){return this.int32[0]-=t instanceof s?t.int32[0]:t,this}assign(t){return this.int32[0]=t instanceof s?t.int32[0]:t,this}cmp(t){return t instanceof s?(this.int32[0]>=t.int32[0]?1:0)+(this.int32[0]<=t.int32[0]?-1:0):(this.int32[0]>=t?1:0)+(this.int32[0]<=t?-1:0)}copy(){return new s(this)}get js_int(){return this.int32[0]}toString(){return this.int32[0].toString()}}e.Int32=s,function(t){let e;!function(t){t.Schema={type:"number"}}(e=t.JSON||(t.JSON={}))}(s||(s={})),e.Int32=s}])}));
//# sourceMappingURL=logootish-js.min.js.map