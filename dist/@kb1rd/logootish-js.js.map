{"version":3,"sources":["webpack://@kb1rd/logootish-js/webpack/universalModuleDefinition","webpack://@kb1rd/logootish-js/webpack/bootstrap","webpack://@kb1rd/logootish-js/./node_modules/loglevel/lib/loglevel.js","webpack://@kb1rd/logootish-js/./src/bst.ts","webpack://@kb1rd/logootish-js/./src/compare.ts","webpack://@kb1rd/logootish-js/./src/debug.ts","webpack://@kb1rd/logootish-js/./src/index.ts","webpack://@kb1rd/logootish-js/./src/ints.ts","webpack://@kb1rd/logootish-js/./src/listmodel/index.ts","webpack://@kb1rd/logootish-js/./src/listmodel/logoot.ts","webpack://@kb1rd/logootish-js/./src/utils.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAA0C;AAClD,QAAQ,oCAAO,UAAU;AAAA;AAAA;AAAA;AAAA,oGAAC;AAC1B,KAAK,MAAM,EAIN;AACL,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;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","file":"@kb1rd/logootish-js.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"@kb1rd/logootish-js\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@kb1rd/logootish-js\"] = factory();\n\telse\n\t\troot[\"@kb1rd/logootish-js\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n","/**\n * @file A binary search tree implementation for finding ranges within the tree\n * and finding neighboring nodes. The documentation for this is, erm, not super\n * amazing.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { DualCompareFunction, MemberPtr, CompareResult } from './utils'\nimport { TypeRange, NumberRange } from './compare'\n\n/**\n * The node type used by the binary search tree\n */\nclass BstNode<T> {\n  /**\n   * The data contained in the node.\n   */\n  data: T\n  left: BstNode<T> | undefined\n  right: BstNode<T> | undefined\n  constructor(data: T) {\n    this.data = data\n  }\n}\n\n/**\n * The pointer type either to a leaf of the BST or the root. By using\n * `MemberPtr`, methods in the BST can re-assign the node value simply through\n * this 'pointer' object.\n */\ntype BstNodePtr<T> =\n  | MemberPtr<BstNode<T>, 'left'>\n  | MemberPtr<BstNode<T>, 'right'>\n  // eslint-disable-next-line\n  | MemberPtr<Bst<T, any>, 'bst_root'>\n/**\n * The type of a function that operates on nodes of the BST.\n */\ntype NodeOp<T> = (node: BstNode<T>) => void\n\nclass TypeRangeSearch<T, R> {\n  readonly buckets: {\n    lesser: [T, R][]\n    range: [T, R][]\n    greater: [T, R][]\n  } = { lesser: [], range: [], greater: [] }\n  constructor(public range: TypeRange<T>) {}\n\n  addToBucket(bucket: 'lesser' | 'range' | 'greater', val: T, obj: R): void {\n    this.buckets[bucket].push([val, obj])\n  }\n  setBucket(bucket: 'lesser' | 'greater', val: T, obj: R): void {\n    let cval: CompareResult\n    if (\n      !this.buckets[bucket].length ||\n      (cval = this.range.cf(val, this.buckets[bucket][0][0])) === 0\n    ) {\n      this.buckets[bucket].push([val, obj])\n      return\n    }\n    if (bucket === 'lesser' && cval > 0) {\n      this.buckets.lesser = [[val, obj]]\n    } else if (bucket === 'greater' && cval < 0) {\n      this.buckets.greater = [[val, obj]]\n    }\n  }\n}\n\n/**\n * A single point in a `RangeSearch`. The first element is the point value, the\n * second element is a boolean that is true if the point is inclusive, and the\n * third element the bucket string, or `undefined` to drop elements.\n */\ntype Point<T> = [T, boolean, string?]\n\n/**\n * A representation of an inequality that can be used to search and sort the\n * elements of an array into `bucket`s. It is a collection of `Point`s. Each\n * `Point` will include any values less that its own and, if the point is\n * inclusive, equal to its own.\n */\nclass RangeSearch<T> {\n  /**\n   * True if only **one** value is kept for elements before the first point.\n   * Used to find the inorder predecessor.\n   */\n  lesser_find_greatest = false\n  /**\n   * True if only **one** value is kept for elements after the last point. Used\n   * to find the inorder successor.\n   */\n  greater_find_least = false\n  private points: Point<T>[] = []\n  private last_bucket?: string\n  private cf: DualCompareFunction<T>\n\n  constructor(cf: DualCompareFunction<T>) {\n    this.cf = cf\n  }\n\n  static lteq<T>(\n    cf: DualCompareFunction<T>,\n    pd: T,\n    bucket: string\n  ): RangeSearch<T> {\n    const search = new RangeSearch<T>(cf)\n    search.points.push([pd, true, bucket])\n    search.last_bucket = undefined\n    return search\n  }\n  static lt<T>(\n    cf: DualCompareFunction<T>,\n    pd: T,\n    bucket: string\n  ): RangeSearch<T> {\n    const search = new RangeSearch<T>(cf)\n    search.points.push([pd, false, bucket])\n    search.last_bucket = undefined\n    return search\n  }\n  static gteq<T>(\n    cf: DualCompareFunction<T>,\n    pd: T,\n    bucket: string\n  ): RangeSearch<T> {\n    const search = new RangeSearch<T>(cf)\n    search.points.push([pd, false, undefined])\n    search.last_bucket = bucket\n    return search\n  }\n  static gt<T>(\n    cf: DualCompareFunction<T>,\n    pd: T,\n    bucket: string\n  ): RangeSearch<T> {\n    const search = new RangeSearch<T>(cf)\n    search.points.push([pd, true, undefined])\n    search.last_bucket = bucket\n    return search\n  }\n\n  /**\n   * Add a point to the collection.\n   * @param data - The value for comparison.\n   * @param bucket - The `bucket` to sort values into, or undefined to discard.\n   * @param inclusive - Determines if the point includes `data`.\n   */\n  push_point(data: T, bucket: string, inclusive = false): void {\n    const point: Point<T> = [data, inclusive, bucket]\n    for (let i = 0; i < this.points.length; i++) {\n      if (this.cf(data, this.points[i][0]) < 0) {\n        this.points.splice(i, 0, point)\n        return\n      }\n    }\n    this.points.push(point)\n  }\n  /**\n   * Set the default bucket for any values greater than the last point.\n   */\n  all_greater(bucket?: string): void {\n    this.last_bucket = bucket\n  }\n\n  /**\n   * A function used by Binary Search Trees to determine traversal.\n   * @param data - The value to compare.\n   * @param current - The current values that are stored.\n   * @param clear_buckets - If true, elements from `current` will be eliminated\n   * if they are affected by `lesser_find_greatest` or `greater_find_least` and\n   * an alternative closer to `data` is found.\n   * @param traverse_left - Will be called when there is the possibility that\n   * there are elements smaller than this one that will satisfy\n   * `greater_find_least`, thereby reducing the number of necessary traversals.\n   * @returns An object containing `left` and `right`, which are booleans that\n   * tell whether more data could be found to the left and right of `data`,\n   * respectively, as well as an optional `bucket` string to tell where `data`\n   * should be sorted.\n   */\n  getBucketInfo(\n    data: T,\n    current?: { [key: string]: T[] },\n    clear_buckets = false,\n    traverse_left?: () => void\n  ): {\n    left: boolean\n    right: boolean\n    bucket?: string\n  } {\n    let left = false\n    let passed_bucket = false\n    let bucket = this.last_bucket\n    let right = Boolean(this.last_bucket)\n\n    // Account for empty searches\n    if (!this.points.length && this.last_bucket) {\n      if (!left && traverse_left) {\n        traverse_left()\n      }\n      left = true\n    }\n\n    // Calculate the membership of each range before the point\n    for (let i = 0; i < this.points.length; i++) {\n      const [other, inclusive, b] = this.points[i]\n\n      if (b && !passed_bucket) {\n        if (!left && traverse_left) {\n          traverse_left()\n        }\n        left = true\n      }\n\n      // Should we add to this current bucket?\n      if (this.cf(data, other) < (inclusive ? 1 : 0)) {\n        if (!passed_bucket) {\n          passed_bucket = true\n          bucket = b\n        }\n        if (\n          i == 0 &&\n          this.lesser_find_greatest &&\n          clear_buckets &&\n          current[b] &&\n          current[b].length\n        ) {\n          if (this.cf(current[b][0], data) < 0) {\n            current[b] = []\n          } else if (this.cf(current[b][0], data) > 0) {\n            bucket = undefined\n          }\n        }\n      }\n\n      if (b && passed_bucket && this.cf(other, data) !== 0) {\n        right = true\n      }\n    }\n\n    // Ensure we account for the area after the last point\n    if (!passed_bucket && this.last_bucket) {\n      const b = this.last_bucket\n      // Traverse the left side assuming we haven't already\n      if (bucket && !left) {\n        left = true\n        traverse_left()\n      }\n      if (\n        this.greater_find_least &&\n        clear_buckets &&\n        current[b] &&\n        current[b].length\n      ) {\n        if (this.cf(current[b][0], data) > 0) {\n          current[b] = []\n        } else if (this.cf(current[b][0], data) < 0) {\n          bucket = undefined\n        }\n      }\n      right = true\n    }\n\n    // Don't traverse if unnecessary\n    left =\n      left &&\n      (!this.lesser_find_greatest ||\n        !this.points.length ||\n        !current[this.points[0][2]] ||\n        !current[this.points[0][2]].length ||\n        this.cf(current[this.points[0][2]][0], data) <= 0)\n    right =\n      right &&\n      (!this.greater_find_least ||\n        !current[this.last_bucket] ||\n        !current[this.last_bucket].length ||\n        this.cf(current[this.last_bucket][0], data) >= 0)\n\n    return { left, bucket, right }\n  }\n\n  /*\n   * Place `data` into a bucket defined by `range_buckets` based on the points\n   * that have been added to this search\n   * @param data - The value to sort.\n   * @param range_buckets - Sort `data` into one of the buckets defined as\n   * properties on this object. An array will be assigned at the bucket name if\n   * the target bucket is not already defined.\n   * @returns `range_buckets`\n   */\n  sort(\n    data: T,\n    range_buckets: { [key: string]: T[] } = {}\n  ): { [key: string]: T[] } {\n    let i\n    for (i = 0; i < this.points.length; i++) {\n      const [other, inclusive, b] = this.points[i]\n\n      if (this.cf(data, other) < (inclusive ? 1 : 0)) {\n        if (!b) {\n          return range_buckets\n        }\n        if (\n          !range_buckets[b] ||\n          (i === 0 &&\n            this.lesser_find_greatest &&\n            range_buckets[b].length &&\n            this.cf(range_buckets[b][0], data) < 0)\n        ) {\n          range_buckets[b] = []\n        }\n        range_buckets[b].push(data)\n        return range_buckets\n      }\n    }\n    i = this.points.length\n\n    const b = this.last_bucket\n    if (!b) {\n      return range_buckets\n    }\n    if (\n      !range_buckets[b] ||\n      (this.greater_find_least &&\n        range_buckets[b].length &&\n        this.cf(range_buckets[b][0], data) > 0)\n    ) {\n      range_buckets[b] = []\n    }\n    range_buckets[b].push(data)\n    return range_buckets\n  }\n\n  /*\n   * Sort the elements of `array` into buckets and return the result.\n   * @param array - The array to sort.\n   * @returns The populated buckets.\n   */\n  search_array(array: T[]): { [key: string]: T[] } {\n    const range_buckets: { [key: string]: T[] } = {}\n    array.forEach((el) => this.sort(el, range_buckets))\n    return range_buckets\n  }\n}\n\n/**\n * A binary search tree implementation for finding ranges within the tree and\n * finding neighboring nodes.\n * @template T - The type stored in the tree.\n * @template S - The type used by search functions, but that cannot be added to\n * the tree. It defaults to `T`.\n */\nclass Bst<T extends S, S = T> {\n  bst_root: BstNode<T> | undefined = undefined\n  readonly cmp: DualCompareFunction<S>\n\n  /**\n   * @param cmp - The compare function to use to sort the tree.\n   */\n  constructor(cmp: DualCompareFunction<S>) {\n    this.cmp = cmp\n  }\n\n  gteqcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) >= 0\n  }\n  gtcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) > 0\n  }\n  eqcmp(a: S, b: S): boolean {\n    return this.cmp(a, b) === 0\n  }\n\n  /**\n   * Add an element to the tree.\n   * @param object - The object to add to the tree.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  add(object: T, node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')): void {\n    if (!node.value) {\n      node.value = new BstNode(object)\n    } else if (this.gteqcmp(node.value.data, object)) {\n      this.add(object, new MemberPtr(node.value, 'left'))\n    } else {\n      this.add(object, new MemberPtr(node.value, 'right'))\n    }\n  }\n\n  /*\n   * Creates a range search from the local compare function.\n   * @returns A new range search.\n   */\n  create_range_search(): RangeSearch<S> {\n    return new RangeSearch<S>(this.cmp)\n  }\n\n  /*\n   * Efficiently search the BST and sort the applicable nodes into buckets.\n   * @param search - The `RangeSearch` to do\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   * @param map - The object to assign buckets to. It is returned.\n   * @returns An object with type `T` sorted into buckets.\n   */\n  search(\n    search: RangeSearch<S>,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root'),\n    map: { [key: string]: T[] } = {}\n  ): { [key: string]: T[] } {\n    if (!node.value) {\n      return map\n    }\n    const { bucket, right } = search.getBucketInfo(\n      node.value.data,\n      map,\n      true,\n      () => {\n        // Interrupting the sorting into buckets to search the left side of the\n        // tree allows us to look for elements that *might* be smaller, so we\n        // can avoid needlessly searching the right side of the tree\n        this.search(search, new MemberPtr(node.value, 'left'), map)\n      }\n    )\n    if (bucket) {\n      if (!map[bucket]) {\n        map[bucket] = []\n      }\n      map[bucket].push(node.value.data)\n    }\n    if (right) {\n      this.search(search, new MemberPtr(node.value, 'right'), map)\n    }\n    return map\n  }\n\n  /**\n   * A method designed mostly for internal use that finds the next element in\n   * the tree if all of the elements were placed in order.\n   * @param object - The object or search type to find the successor of\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  _getInorderSuccessor(\n    object: S,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): { ptr: BstNodePtr<T>; data: T } | undefined {\n    type SuccessorType = { ptr: BstNodePtr<T>; data: T } | undefined\n    let successor: SuccessorType\n    const setSuccessor = (s: SuccessorType): void => {\n      if (!successor || (s && this.gtcmp(successor.data, s.data))) {\n        successor = s\n      }\n    }\n    if (node.value) {\n      if (this.gteqcmp(node.value.data, object)) {\n        if (node.value.data !== object) {\n          setSuccessor({ ptr: node, data: node.value.data })\n        }\n        setSuccessor(\n          this._getInorderSuccessor(object, new MemberPtr(node.value, 'left'))\n        )\n      }\n      setSuccessor(\n        this._getInorderSuccessor(object, new MemberPtr(node.value, 'right'))\n      )\n    }\n    return successor\n  }\n  /**\n   * Remove an element from the tree.\n   * @param object - The object to remove or a search type that is evaluated\n   * to the same value as an object in the tree. Equivalence is determined\n   * exclusively using the compare function.\n   * @param filter - An optional function that has the final say in whether a\n   * node is removed. While an `object` is provided for quick tree traversal, it\n   * is not always desirable to remove *every* node with that particular value.\n   * This function allows the user to override that behavior.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  remove(\n    object: S,\n    filter: (data: T) => boolean = (): boolean => true,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      const result = this.cmp(node.value.data, object)\n      const should_remove = filter(node.value.data)\n      if (result > 0) {\n        this.remove(object, filter, new MemberPtr(node.value, 'left'))\n      } else if (result < 0) {\n        this.remove(object, filter, new MemberPtr(node.value, 'right'))\n      } else {\n        this.remove(object, filter, new MemberPtr(node.value, 'left'))\n        this.remove(object, filter, new MemberPtr(node.value, 'right'))\n      }\n      if (result === 0 && should_remove) {\n        if (node.value.left && node.value.right) {\n          const successor = this._getInorderSuccessor(node.value.data, node)\n\n          this.remove(successor.data, undefined, successor.ptr)\n          node.value.data = successor.data\n        } else {\n          node.value = node.value.left || node.value.right\n        }\n      }\n    }\n  }\n\n  /**\n   * Perform an operation on all of the elements in a range.\n   * @param start - The search type or object at which to start a search.\n   * @param endm1 - The search type or object at which to end a search\n   * inclusively. The name is `endm1` to stand for `END Minus 1` since the\n   * search is performed inclusively.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   * @param undef - TODO: Fix\n   */\n  operateOnAllRange(\n    start: S,\n    endm1: S,\n    operation: NodeOp<T>,\n    node = this.bst_root,\n    undef = false\n  ): void {\n    if (node && !undef) {\n      if (this.gteqcmp(node.data, start)) {\n        if (this.gteqcmp(endm1, node.data)) {\n          this.operateOnAllRange(start, endm1, operation, node.left, !node.left)\n          this.operateOnAllRange(\n            start,\n            endm1,\n            operation,\n            node.right,\n            !node.right\n          )\n          operation(node)\n        } else {\n          this.operateOnAllRange(start, endm1, operation, node.left, !node.left)\n        }\n      } else {\n        this.operateOnAllRange(start, endm1, operation, node.right, !node.right)\n      }\n    }\n  }\n  /**\n   * Perform an operation on all of the elements greater than or equal to a\n   * search type or object.\n   * @param value - The search type or object at which to start a search.\n   * @param sequential - If true, `operation` will be called sequentially. If\n   * false, `operation` will be called for the root node first, then children.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAllGteq(\n    value: S,\n    operation: NodeOp<T>,\n    sequential = true,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      if (this.gteqcmp(node.value.data, value)) {\n        if (!sequential) {\n          operation(node.value)\n        }\n        this.operateOnAllGteq(\n          value,\n          operation,\n          sequential,\n          new MemberPtr(node.value, 'left')\n        )\n        if (sequential) {\n          operation(node.value)\n        }\n      }\n      this.operateOnAllGteq(\n        value,\n        operation,\n        sequential,\n        new MemberPtr(node.value, 'right')\n      )\n    }\n  }\n  /**\n   * Perform an operation on all of the elements less than or equal to a\n   * search type or object.\n   * @param value - The search type or object at which to end a search.\n   * @param sequential - If true, `operation` will be called sequentially. If\n   * false, `operation` will be called for the root node first, then children.\n   * @param operation - The function to run on each node.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAllLteq(\n    value: S,\n    operation: NodeOp<T>,\n    sequential = true,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      if (this.gteqcmp(value, node.value.data)) {\n        if (!sequential) {\n          operation(node.value)\n        }\n        this.operateOnAllLteq(\n          value,\n          operation,\n          sequential,\n          new MemberPtr(node.value, 'left')\n        )\n        if (sequential) {\n          operation(node.value)\n        }\n        this.operateOnAllLteq(\n          value,\n          operation,\n          sequential,\n          new MemberPtr(node.value, 'right')\n        )\n      } else {\n        this.operateOnAllLteq(\n          value,\n          operation,\n          sequential,\n          new MemberPtr(node.value, 'left')\n        )\n      }\n    }\n  }\n\n  /**\n   * Perform an operation on all nodes.\n   * @param operation - The function to run on each node.\n   * @param sequential - If true, `operation` will be called sequentially. If\n   * false, `operation` will be called for the root node first, then children.\n   * @param node - The node in the tree where the search can be started. It's\n   * optional and does not need to be changed for nearly all use cases.\n   */\n  operateOnAll(\n    operation: NodeOp<T>,\n    sequential = true,\n    node: BstNodePtr<T> = new MemberPtr(this, 'bst_root')\n  ): void {\n    if (node.value) {\n      if (!sequential) {\n        operation(node.value)\n      }\n      this.operateOnAll(\n        operation,\n        sequential,\n        new MemberPtr(node.value, 'left')\n      )\n      if (sequential) {\n        operation(node.value)\n      }\n      this.operateOnAll(\n        operation,\n        sequential,\n        new MemberPtr(node.value, 'right')\n      )\n    }\n  }\n\n  /**\n   * Get all the objects in a range.\n   * @param start - The search type or object at which to start a search.\n   * @param endm1 - The search type or object at which to end a search\n   * inclusively. The name is `endm1` to stand for `END Minus 1` since the\n   * search is performed inclusively.\n   */\n  getRange(start: S, endm1: S): (BstNode<T> | undefined)[] {\n    const nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllRange(start, endm1, (n) => nodes.push(n))\n\n    return nodes\n  }\n  /**\n   * Get all the objects greater than or equal to an object or search type.\n   * @param value - The search type or object at which to start a search.\n   */\n  getGteq(value: S): (BstNode<T> | undefined)[] {\n    let nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllGteq(value, (n) => {\n      if (!nodes[0] || this.gtcmp(nodes[0].data, n.data)) {\n        nodes = [n]\n      } else if (this.eqcmp(nodes[0].data, n.data)) {\n        nodes.push(n)\n      }\n    })\n\n    return nodes\n  }\n  /**\n   * Get all the objects less than or equal to an object or search type.\n   * @param value - The search type or object at which to end a search.\n   */\n  getLteq(value: S): (BstNode<T> | undefined)[] {\n    let nodes: (BstNode<T> | undefined)[] = []\n    this.operateOnAllLteq(value, (n) => {\n      if (!nodes[0] || this.gtcmp(n.data, nodes[0].data)) {\n        nodes = [n]\n      } else if (this.eqcmp(nodes[0].data, n.data)) {\n        nodes.push(n)\n      }\n    })\n\n    return nodes\n  }\n\n  toString(): string {\n    let str = 'BST [\\n'\n    this.operateOnAll(({ data }) => {\n      str +=\n        '  ' +\n        data\n          .toString()\n          .split('\\n')\n          .join('\\n  ') +\n        '\\n'\n    })\n    str += ']'\n    return str\n  }\n}\n\ntype DBstSearchable = { value: number }\nabstract class DBstNode<T extends DBstNode<T>> {\n  parent_node?: T\n  left_node?: T\n  right_node?: T\n\n  constructor(public value: number = 0) {}\n\n  get absolute_value(): number {\n    return this.value + (this.parent_node ? this.parent_node.absolute_value : 0)\n  }\n\n  /**\n   * Order nodes that have the same `value` may be ordered differently using\n   * this function.\n   */\n  abstract preferential_cmp(other: DBstSearchable | T): CompareResult\n\n  addChild(node: T): void {\n    node.value -= this.value\n    if (node.value > 0 || this.preferential_cmp(node) < 0) {\n      if (this.right_node) {\n        this.right_node.addChild(node)\n      } else {\n        this.right_node = node as T\n        // T will always be an instance of DBstNode<T>\n        ;(node as DBstNode<T>).parent_node = (this as unknown) as T\n      }\n    } else {\n      if (this.left_node) {\n        this.left_node.addChild(node)\n      } else {\n        this.left_node = node as T\n        ;(node as DBstNode<T>).parent_node = (this as unknown) as T\n      }\n    }\n  }\n\n  get smallest_child(): T {\n    if (this.left_node) {\n      return this.left_node.smallest_child || this.left_node\n    } else if (this.right_node) {\n      return this.right_node.smallest_child || this.right_node\n    }\n    return undefined\n  }\n  get smallest_smaller_child(): T {\n    if (this.left_node) {\n      return this.left_node.smallest_smaller_child || this.left_node\n    }\n    return undefined\n  }\n  get largest_child(): T {\n    if (this.right_node) {\n      return this.right_node.largest_child || this.right_node\n    } else if (this.left_node) {\n      return this.left_node.largest_child || this.left_node\n    }\n    return undefined\n  }\n  get largest_larger_child(): T {\n    if (this.right_node) {\n      return this.right_node.largest_larger_child || this.right_node\n    }\n    return undefined\n  }\n\n  get inorder_successor(): T {\n    if (this.right_node) {\n      return this.right_node.smallest_smaller_child || this.right_node\n    }\n    let node = (this as undefined) as T\n    while (node) {\n      if (\n        node.value <= 0 &&\n        node.parent_node &&\n        node.parent_node.left_node === node\n      ) {\n        return node.parent_node\n      }\n      node = node.parent_node\n    }\n    return undefined\n  }\n\n  replaceWith(data: T): T {\n    if (data) {\n      data.value = data.value - this.absolute_value + this.value\n    }\n    if (this.parent_node) {\n      if (this.value <= 0) {\n        this.parent_node.left_node = data\n      } else {\n        this.parent_node.right_node = data\n      }\n      if (data) {\n        if (data.parent_node) {\n          if (data.parent_node.left_node === data) {\n            delete data.parent_node.left_node\n          } else if (data.parent_node.right_node === data) {\n            delete data.parent_node.right_node\n          }\n          delete data.parent_node\n        }\n        data.parent_node = this.parent_node\n      }\n    }\n\n    if (data && this.left_node && this.left_node !== data) {\n      data.left_node = this.left_node\n      data.left_node.parent_node = data\n      data.left_node.value += this.value - data.value\n    }\n    if (data && this.right_node && this.right_node !== data) {\n      data.right_node = this.right_node\n      data.right_node.parent_node = data\n      data.right_node.value += this.value - data.value\n    }\n\n    delete this.parent_node\n    delete this.right_node\n    delete this.left_node\n\n    return (this as unknown) as T\n  }\n\n  removeChild(\n    value: number,\n    filter: (data: T) => boolean = (): boolean => true,\n    vals: T[] = [],\n    parentUpdate: (np: T) => void = (): void => undefined\n  ): T[] {\n    const tryRmLeft = (): void => {\n      if (this.left_node) {\n        this.left_node.removeChild(value - this.left_node.value, filter, vals)\n      }\n    }\n    const tryRmRight = (): void => {\n      if (this.right_node) {\n        this.right_node.removeChild(value - this.right_node.value, filter, vals)\n      }\n    }\n    if (value <= 0) {\n      tryRmLeft()\n    } else if (value > 0) {\n      tryRmRight()\n    }\n    if (value === 0 && filter((this as unknown) as T)) {\n      vals.push((this as unknown) as T)\n      let cnode: T\n      if (this.right_node && this.left_node) {\n        cnode = this.inorder_successor\n\n        // Keep the value here while we remove (`removeChild` needs the tree to\n        // be preserved)\n        const absval = cnode.absolute_value\n        cnode.parent_node.removeChild(cnode.value, (n) => n === cnode)\n        cnode.value = absval\n      } else if (this.right_node) {\n        cnode = this.right_node\n        cnode.value = cnode.absolute_value\n      } else if (this.left_node) {\n        cnode = this.left_node\n        cnode.value = cnode.absolute_value\n      } else {\n        cnode = undefined\n      }\n      this.replaceWith(cnode)\n      parentUpdate(cnode)\n    }\n    return vals\n  }\n\n  addSpaceBefore(s: number): void {\n    let next = (this as unknown) as T\n    let cumulative = 0\n    while (next) {\n      // Increment `next` value if it's greater than `this`\n      if (cumulative >= 0 && this.preferential_cmp(next) <= 0) {\n        cumulative -= next.value\n        next.value += s\n        // Ensure that the left node's position is not changed\n        if (next.left_node) {\n          next.left_node.value -= s\n        }\n      } else {\n        cumulative -= next.value\n      }\n      next = next.parent_node\n    }\n  }\n\n  search(s: TypeRangeSearch<number, T>, cval: number): void {\n    cval += this.value\n    ;(s.range as NumberRange).push_offset(-this.value)\n\n    const traverse_left = (): void => {\n      this.left_node.search(s, cval)\n    }\n    const traverse_right = (): void => {\n      this.right_node.search(s, cval)\n    }\n\n    const sec = s.range.getRangeSection(0)\n    if (sec < 0) {\n      // We're under the target range...\n\n      // Try assigning this to a bucket (if the current value is greater, this)\n      // will be ignored.\n      s.setBucket('lesser', cval, (this as unknown) as T)\n      // Always traverse right since it could be greater\n      if (this.right_node) {\n        traverse_right()\n      }\n      // Traverse left if the left node is equal (zero offset)\n      if (this.left_node && this.left_node.value === 0) {\n        traverse_left()\n      }\n    } else if (sec > 0) {\n      // We're above the target range...\n\n      // The same as above, but with the `greater` bucket\n      s.setBucket('greater', cval, (this as unknown) as T)\n      // Always try to find a smaller node\n      if (this.left_node) {\n        traverse_left()\n      }\n    } else {\n      // We're in the target range...\n\n      s.addToBucket('range', cval, (this as unknown) as T)\n      // Now, we have to traverse left **and** right\n      if (this.left_node) {\n        traverse_left()\n      }\n      if (this.right_node) {\n        traverse_right()\n      }\n    }\n\n    ;(s.range as NumberRange).pop_offset(-this.value)\n  }\n\n  operateOnAll(cb: (data: T) => void): void {\n    if (this.left_node) {\n      this.left_node.operateOnAll(cb)\n    }\n    cb((this as unknown) as T)\n    if (this.right_node) {\n      this.right_node.operateOnAll(cb)\n    }\n  }\n}\n\nclass DBst<T extends DBstNode<T>> {\n  bst_root?: T = undefined\n\n  add(node: T): T {\n    if (!this.bst_root) {\n      this.bst_root = node\n    } else {\n      this.bst_root.addChild(node)\n    }\n    return node\n  }\n  remove(\n    value: number,\n    filter: (data: T) => boolean = (): boolean => true\n  ): T[] {\n    const vals: T[] = []\n    if (this.bst_root) {\n      this.bst_root.removeChild(\n        value - this.bst_root.value,\n        filter,\n        vals,\n        (p: T) => {\n          this.bst_root = p\n        }\n      )\n    }\n    return vals\n  }\n  search(range: NumberRange): TypeRangeSearch<number, T> {\n    const search = new TypeRangeSearch<number, T>(range)\n    if (this.bst_root) {\n      this.bst_root.search(search, 0)\n    }\n    return search\n  }\n\n  operateOnAll(cb: (data: T) => void): void {\n    if (this.bst_root) {\n      this.bst_root.operateOnAll(cb)\n    }\n  }\n\n  toString(): string {\n    let str = 'DBST [\\n'\n    this.operateOnAll((data) => {\n      str +=\n        '  ' +\n        data\n          .toString()\n          .split('\\n')\n          .join('\\n  ') +\n        '\\n'\n    })\n    str += ']'\n    return str\n  }\n}\n\nexport { Bst, RangeSearch, BstNode, DBst, DBstSearchable, DBstNode }\n","/**\n * @file Several useful things for doing comparisons and sorting data.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n\n/**\n * One of zero, one, or negative one.\n */\ntype CompareResult = -1 | 0 | 1\n/**\n * A function type that takes `T` and returns a CompareResult.\n */\ntype CompareFunction<T> = (other: T) => CompareResult\n/**\n * A function type that takes two of a type `T` and returns a CompareResult.\n */\ntype DualCompareFunction<T> = (a: T, b: T) => CompareResult\n\n/**\n * Turns a number into a `CompareResult.` If it is greater than 0, it will\n * become 1. If it is less then 0, it will become -1. If the input is\n * violating type constraints and is not a number, an error will be thrown.\n * @param n - The number to transform\n * @returns `-1` if `n<0`, `0` if `n==0`, `1` if `n>0`\n * @throws {TypeError} If `n` is not a number\n */\nfunction cmpResult(n: number): CompareResult {\n  if (isNaN(n) || n === undefined || n === null) {\n    throw new TypeError(`Invalid compare result '${n}.'`)\n  }\n  return n > 0 ? 1 : n < 0 ? -1 : 0\n}\n\n/**\n * A utility abstract class with no implementation for the function `cmp` and\n * implementations for `gt`, `gteq`, `eq`, `lteq`, and `lt` functions.\n * @template T The other type that can be compared.\n */\nabstract class Comparable<T> {\n  /**\n   * Compare this object to another one.\n   */\n  abstract cmp(other: T): CompareResult\n  /**\n   * @return True if this object is greater than the one provided.\n   */\n  gt(n: T): boolean {\n    return this.cmp(n) === 1\n  }\n  /**\n   * @return True if this object is greater than or equal to the one provided.\n   */\n  gteq(n: T): boolean {\n    return this.cmp(n) >= 0\n  }\n  /**\n   * @return True if this object is equal to the one provided.\n   */\n  eq(n: T): boolean {\n    return this.cmp(n) === 0\n  }\n  /**\n   * @return True if this object is less than or equal to the one provided.\n   */\n  lteq(n: T): boolean {\n    return this.cmp(n) <= 0\n  }\n  /**\n   * @return True if this object is less than the one provided.\n   */\n  lt(n: T): boolean {\n    return this.cmp(n) === -1\n  }\n}\n\n/**\n * An interface for anything that resembles a range of possible values.\n */\ninterface BaseRangeContainer<T> {\n  /**\n   * Determines if `item` is in this range.\n   * @param item - The item to test\n   * @returns True if the item is in the range\n   */\n  contains(item: T): boolean\n  /**\n   * Determines *all* of `range` is in this range\n   * @param item - The range to test\n   * @returns True if this range contains `range`\n   */\n  doesContainInRange(range: TypeRange<T>): boolean\n  /**\n   * Determines *any* of `range` is in this range\n   * @param item - The range to test\n   * @returns True if this range contains any element in `range`\n   */\n  mayContainInRange(range: TypeRange<T>): boolean\n}\n\nclass RangeBounds {\n  /**\n   * **L**esser **C**losed **G**reater **C**losed\n   */\n  static LCGC = new RangeBounds(true, true)\n  /**\n   * **L**esser **O**pen **G**reater **O**pen\n   */\n  static LOGO = new RangeBounds(false, false)\n  /**\n   * **L**esser **C**losed **G**reater **O**pen\n   */\n  static LCGO = new RangeBounds(true, false)\n  /**\n   * **L**esser **O**pen **G**reater **C**losed\n   */\n  static LOGC = new RangeBounds(false, true)\n\n  /**\n   * True if the left side is closed.\n   */\n  readonly closed_left: boolean\n  /**\n   * True if the right side is closed.\n   */\n  readonly closed_right: boolean\n\n  /**\n   * @param a - A boolean for the closure of the left side **or** a bracket\n   * string (like `[)`) for the range.\n   * @param b - A boolean for the closure of the right side. If brackets are\n   * provided, this will be ignored.\n   */\n  constructor(a: boolean | '[]' | '()' | '[)' | '(]', b?: boolean) {\n    if (a === true || a === false) {\n      this.closed_left = a\n      this.closed_right = Boolean(b)\n    } else if (a[0] && a[1]) {\n      this.closed_left = a[0] === '['\n      this.closed_right = a[1] === ']'\n    } else {\n      this.closed_left = true\n      this.closed_right = true\n    }\n  }\n  /**\n   * @returns A string that represents the left bracket (`[` or `(`)\n   */\n  get left_str(): string {\n    return this.closed_left ? '[' : '('\n  }\n  /**\n   * @returns A string that represents the right bracket (`]` or `)`)\n   */\n  get right_str(): string {\n    return this.closed_right ? ']' : ')'\n  }\n  /**\n   * @returns A bracket string like `[)`\n   */\n  toString(): string {\n    return this.left_str + this.right_str\n  }\n}\n\n/**\n * Specifies a bound of a range.\n */\ntype BoundSelector = 'max' | 'min'\n/**\n * Represents a simple range with a minimum and a maximum. Inclusivity is\n * controlled through `bounds`.\n */\nclass TypeRange<T> implements BaseRangeContainer<T> {\n  /**\n   * @param cf - A compare function that is used to compare two `T`\n   * @param min - The minimum value\n   * @param max - The maximum value\n   * @param bounds - The inclusivity bounds to use\n   */\n  constructor(\n    public readonly cf: DualCompareFunction<T>,\n    public min?: T,\n    public max?: T,\n    public bounds: RangeBounds = RangeBounds.LCGC\n  ) {}\n\n  /**\n   * Returns a range that is greater than `t`.\n   * @param cf - The compare function to use\n   * @param t - The value to use\n   */\n  static gt<T>(cf: DualCompareFunction<T>, t: T): TypeRange<T> {\n    return new TypeRange(cf, t, undefined, new RangeBounds(false, false))\n  }\n  /**\n   * Returns a range that is greater than or equal to `t`.\n   * @param cf - The compare function to use\n   * @param t - The value to use\n   */\n  static gteq<T>(cf: DualCompareFunction<T>, t: T): TypeRange<T> {\n    return new TypeRange(cf, t, undefined, new RangeBounds(true, false))\n  }\n  /**\n   * Returns a range that is less than `t`.\n   * @param cf - The compare function to use\n   * @param t - The value to use\n   */\n  static lt<T>(cf: DualCompareFunction<T>, t: T): TypeRange<T> {\n    return new TypeRange(cf, undefined, t, new RangeBounds(false, false))\n  }\n  /**\n   * Returns a range that is less than or equal to `t`.\n   * @param cf - The compare function to use\n   * @param t - The value to use\n   */\n  static lteq<T>(cf: DualCompareFunction<T>, t: T): TypeRange<T> {\n    return new TypeRange(cf, undefined, t, new RangeBounds(false, true))\n  }\n  /**\n   * A range that contains all possible values.\n   * @param cf - The compare function to use\n   */\n  static all<T>(cf: DualCompareFunction<T>): TypeRange<T> {\n    return new TypeRange(\n      cf,\n      undefined,\n      undefined,\n      new RangeBounds(false, false)\n    )\n  }\n\n  /**\n   * @returns True if `min` is `undefined` (Representing negative infinity)\n   */\n  get undef_min(): boolean {\n    return (\n      this.min === undefined ||\n      this.min === null ||\n      ((this.min as unknown) as number) === NaN ||\n      ((this.min as unknown) as number) === -Infinity\n    )\n  }\n  /**\n   * @returns True if `min` is defined (not negative infinity)\n   */\n  get def_min(): boolean {\n    return !this.undef_min\n  }\n  /**\n   * @returns True if `max` is `undefined` (Representing infinity)\n   */\n  get undef_max(): boolean {\n    return (\n      this.max === undefined ||\n      this.max === null ||\n      ((this.max as unknown) as number) === NaN ||\n      ((this.max as unknown) as number) === Infinity\n    )\n  }\n  /**\n   * @returns True if `max` is defined (not infinity)\n   */\n  get def_max(): boolean {\n    return !this.undef_max\n  }\n  /**\n   * @param b - The bound to select\n   * @returns True if the bound is defined (not an infinity)\n   */\n  bound_def(b: BoundSelector): boolean {\n    return b === 'min' ? this.def_min : this.def_max\n  }\n  /**\n   * @param b - The bound to select\n   * @returns True if the bound is undefined (is an infinity)\n   */\n  bound_undef(b: BoundSelector): boolean {\n    return b === 'min' ? this.undef_min : this.undef_max\n  }\n\n  contains(t: T): boolean {\n    return (\n      (!this.min ||\n        this.cf(t, this.min) >= (this.bounds.closed_left ? 0 : 1)) &&\n      (!this.max || this.cf(this.max, t) >= (this.bounds.closed_right ? 0 : 1))\n    )\n  }\n  /**\n   * Finds out if `t` is less than (`-1`), inside (`0`), or greater than\n   * (`1`) this range\n   * @param t The object to compare\n   */\n  getRangeSection(t: T): CompareResult {\n    if (\n      this.def_max &&\n      this.cf(this.max, t) < (this.bounds.closed_right ? 0 : 1)\n    ) {\n      return 1\n    }\n    if (\n      this.def_min &&\n      this.cf(t, this.min) < (this.bounds.closed_left ? 0 : 1)\n    ) {\n      return -1\n    }\n    return 0\n  }\n\n  /**\n   * Compares this range's endpoints to endpoints of another range. The\n   * comparison is relative to this (ex, it will be `1` if this is greater)\n   * @param local - The local bound to use\n   * @param r - The other range to use\n   * @param other - The other bound to use\n   * @returns The result of the comparison\n   */\n  compareEndpoints(\n    local: BoundSelector,\n    r: TypeRange<T>,\n    other: BoundSelector\n  ): CompareResult {\n    if (this.bound_def(local) && r.bound_undef(other)) {\n      return other === 'min' ? 1 : -1\n    }\n    if (this.bound_undef(local) && r.bound_undef(other)) {\n      return local !== other ? (local === 'max' ? 1 : -1) : 0\n    }\n    if (this.bound_undef(local) && r.bound_def(other)) {\n      return local === 'max' ? 1 : -1\n    }\n\n    const rval = this.cf(this[local] as T, r[other] as T)\n\n    if (rval === 0) {\n      const local_closed =\n        local === 'min' ? !this.bounds.closed_left : this.bounds.closed_right\n      const other_closed =\n        other === 'min' ? !r.bounds.closed_left : r.bounds.closed_right\n\n      if (local_closed && !other_closed) {\n        return 1\n      } else if (!local_closed && other_closed) {\n        return -1\n      }\n    }\n    return rval\n  }\n\n  doesContainInRange(r: TypeRange<T>): boolean {\n    return (\n      this.compareEndpoints('min', r, 'min') <= 0 &&\n      this.compareEndpoints('max', r, 'max') >= 0\n    )\n  }\n  mayContainInRange(r: TypeRange<T>): boolean {\n    return (\n      this.compareEndpoints('min', r, 'max') < 0 &&\n      this.compareEndpoints('max', r, 'min') > 0\n    )\n  }\n\n  toString(): string {\n    return `${this.bounds.left_str}${this.min},${this.max}${this.bounds.right_str}`\n  }\n}\n\n/**\n * A subclass of `TypeRange` that automatically creates a compare function if\n * `T` is of type `Comparable`.\n */\nclass ComparableTypeRange<T extends Comparable<T>> extends TypeRange<T> {\n  constructor(min: T, max: T, bounds?: RangeBounds) {\n    super((a: T, b: T) => a.cmp(b), min, max, bounds)\n  }\n}\n\n/**\n * A subclass of `TypeRange` for numbers. It has helper functions for applying\n * an offset to the range.\n */\nclass NumberRange extends TypeRange<number> {\n  constructor(min: number, max: number, bounds?: RangeBounds) {\n    super((a, b) => cmpResult(a - b), min, max, bounds)\n  }\n  /**\n   * Add a positive offset to the range\n   * @param o - The offset to apply\n   */\n  push_offset(o: number): void {\n    this.min += o\n    this.max += o\n  }\n  /**\n   * Add a negative offset to the range\n   * @param o - The offset to apply\n   */\n  pop_offset(o: number): void {\n    this.min -= o\n    this.max -= o\n  }\n}\n\nexport {\n  CompareResult,\n  CompareFunction,\n  DualCompareFunction,\n  cmpResult,\n  Comparable,\n  BaseRangeContainer,\n  RangeBounds,\n  TypeRange,\n  ComparableTypeRange,\n  NumberRange\n}\n","/**\n * @file Definition of the `debug` constant from `loglevel`.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport loglevel from 'loglevel'\n\nconst debug = loglevel.getLogger('logootish-js')\n\nexport { debug }\n","/**\n * @file This file imports the ListDocumentModel and defines event handling\n * systems.\n * @TODO Move event abstraction layer here\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport {\n  ListDocumentModel,\n  LogootInt,\n  LogootPosition,\n  NodeType\n} from './listmodel'\n\nenum EventState {\n  /**\n   * Not being actively sent and can be modified.\n   */\n  PENDING,\n  /**\n   * In transit. Cannot be modified.\n   */\n  SENDING,\n  /**\n   * Already sent. Also cannot be modified.\n   */\n  COMPLETE\n}\n\n/**\n * Generic event interface.\n */\ninterface LogootishEvent {\n  state: EventState\n  readonly type: string\n  // eslint-disable-next-line\n  toJSON(): any\n}\n\nexport { EventState, ListDocumentModel, LogootInt, LogootPosition, NodeType }\n","/**\n * @file Definition of various integers.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { CompareResult, Comparable } from './utils'\n\n/**\n * An abstract subclass of `Comparable` to provide a generic interface for\n * integer types that may not be supported by JavaScript\n * @template FutureType - The type of the subclass with which to restrict all\n * operations to the int class.\n * @inheritdoc\n */\nabstract class IntType<FutureType> extends Comparable<FutureType | number> {\n  // eslint-disable-next-line\n  abstract toJSON(): any\n  abstract toString(): string\n\n  /**\n   * Add another integer to the value of this one\n   * @param n - The number to add\n   */\n  abstract add(n: FutureType | number): FutureType\n  /**\n   * Add another integer to the value of this one\n   * @param n - The number to subtract\n   */\n  abstract sub(n: FutureType | number): FutureType\n\n  /**\n   * Assign another integer to this object\n   * @param n - The number to assign\n   */\n  abstract sub(n: FutureType | number): FutureType\n\n  /**\n   * The JavaScript int type for this integer (with an exception thrown if the\n   * value cannot be represented in 32 bits)\n   */\n  abstract js_int: number\n}\n\n/**\n * An `IntType` that restricts the number to 32 bits by using an `Int32Array`.\n * @inheritdoc\n * @example ```typescript\n * const a = new Int32(5)\n * console.log(a.toString()) // 5\n * a.add(10).sub(8)\n * console.log(a.toString()) // 7\n * const b = new Int32(3)\n * console.log(a.cmp(b)) // 1\n * ```\n */\nclass Int32 extends IntType<Int32> {\n  // Size limit the int, enforce signing, and remove decimals\n  private int32 = new Int32Array([0])\n\n  constructor(n: Int32 | number = 0) {\n    super()\n    if (n instanceof Int32) {\n      this.int32[0] = n.int32[0]\n    } else {\n      this.int32[0] = n\n    }\n  }\n\n  static fromJSON(obj: Int32.JSON): Int32 {\n    return new Int32(obj)\n  }\n\n  toJSON(): Int32.JSON {\n    return this.int32[0]\n  }\n\n  add(n: Int32 | number): Int32 {\n    if (n instanceof Int32) {\n      this.int32[0] += n.int32[0]\n    } else {\n      this.int32[0] += n\n    }\n    return this\n  }\n  sub(n: Int32 | number): Int32 {\n    if (n instanceof Int32) {\n      this.int32[0] -= n.int32[0]\n    } else {\n      this.int32[0] -= n\n    }\n    return this\n  }\n\n  assign(n: Int32 | number): Int32 {\n    if (n instanceof Int32) {\n      this.int32[0] = n.int32[0]\n    } else {\n      this.int32[0] = n\n    }\n    return this\n  }\n\n  cmp(n: Int32 | number): CompareResult {\n    if (n instanceof Int32) {\n      return ((this.int32[0] >= n.int32[0] ? 1 : 0) +\n        (this.int32[0] <= n.int32[0] ? -1 : 0)) as CompareResult\n    } else {\n      return ((this.int32[0] >= n ? 1 : 0) +\n        (this.int32[0] <= n ? -1 : 0)) as CompareResult\n    }\n  }\n\n  copy(): Int32 {\n    return new Int32(this)\n  }\n\n  get js_int(): number {\n    return this.int32[0]\n  }\n\n  toString(): string {\n    return this.int32[0].toString()\n  }\n}\nnamespace Int32 {\n  export type JSON = number\n  export namespace JSON {\n    export const Schema = { type: 'number' }\n  }\n}\n\nexport { IntType, Int32 }\n","/**\n * @file This file contains the bulky position manipulation logic for any list-\n * based CRDT (arrays, text, rich text, etc.)\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { NumberRange, RangeBounds } from '../compare'\nimport { FatalError, allValues, BreakException, catchBreak } from '../utils'\nimport { Bst, DBst } from '../bst'\n\nimport {\n  LogootInt,\n  LogootPosition,\n  NodeType,\n  ConflictGroup,\n  LogootNodeGroup,\n  BranchKey\n} from './logoot'\n\nimport { debug } from '../debug'\n\ntype KnownPositionBst = DBst<ConflictGroup>\ntype LogootBst = Bst<LogootNodeGroup, { start: LogootPosition }>\n\n/**\n * A Logoot removal.\n */\ntype Removal = {\n  branch: BranchKey\n  start: LogootPosition\n  length: number\n  rclk: LogootInt\n}\n\ntype RemovalOperation = {\n  type: 'r'\n  start: number\n  length: number\n}\ntype InsertionOperation = {\n  type: 'i'\n  start: number\n  offset: number\n  length: number\n}\ntype TranslationOperation = {\n  type: 't'\n  source: number\n  length: number\n  dest: number\n}\ntype MarkOperation = {\n  type: 'm'\n  start: number\n  length: number\n  conflicting: boolean\n}\n/**\n * An operation returned by `_mergeNode` to be run on the local document.\n */\ntype Operation =\n  | RemovalOperation\n  | InsertionOperation\n  | TranslationOperation\n  | MarkOperation\n\n/**\n * An error thrown when an insertion is attempted at the boundary between two\n * branches that are not the one in the active document.\n */\nclass InsertionConflictError extends Error {}\n\n/**\n * A function that determines if two `LogootNodeGroup`s should be in the same\n * `ConflictGroup`. The two arguments must be in order.\n * @param a - The first `LogootNodeGroup`\n * @param b - The second `LogootNodeGroup`\n * @returns True if the two groups can be joined.\n */\ntype JoinFunction = (a: LogootNodeGroup, b: LogootNodeGroup) => boolean\n/**\n * A `JoinFunction` that joins two nodes if they have the same branches that are\n * in conflict.\n */\nconst MinimalJoinFunction = (\n  a: LogootNodeGroup,\n  b: LogootNodeGroup\n): boolean => {\n  if (a.branches.filter((br) => !b.br(br)).length) {\n    return false\n  }\n  if (b.branches.filter((br) => !a.br(br)).length) {\n    return false\n  }\n  return true\n}\n\n/**\n * A representation of the Logootish Document Model for mapping \"real,\"\n * continuous `known_position`s to Logoot positions. This is useful when working\n * with strings, arrays, or, just in general, anything that needs a fixed order.\n * This does not actually store the data in question, but stores a mapping of\n * real indices in the data to the Logoot positions of that element. This is\n * used to transform edits between ones in the Logoot and local position spaces.\n * One important thing to note: Logoot edits (insertions/removals) can be\n * applied in any order. Local edits **must** be applied in a consistent order.\n */\nclass ListDocumentModel {\n  /**\n   * The BST maps out where all insertion nodes are in the local document's\n   * memory. It is used to go from position -> node\n   */\n  ldoc_bst: KnownPositionBst = new DBst()\n  /**\n   * This BST maps Logoot position identifiers to their text node to allow\n   * lookup of text position from Logoot ID\n   */\n  logoot_bst: LogootBst = new Bst((a, b) => a.start.cmp(b.start))\n  /** A map of removals that do not yet have text to remove */\n  // removal_bst: LogootBst = new Bst((a, b) => a.start.cmp(b.start))\n  /**\n   * This is a Lamport clock. A proper vector clock would have too many entries\n   * for large, multi-user documents.\n   * See the Logoot paper for why. Unlike the Logoot implementation, this is\n   * incremented with each removal only and is kept constant with insertions.\n   */\n  clock = new LogootInt()\n  branch: BranchKey\n\n  /**\n   * An optional instance of the `ListDocumentModel.Logger` class to log all\n   * operations that modify the BST (all calls to `_mergeNode`) to help with\n   * bug identification when applicable.\n   */\n  debug_logger?: ListDocumentModel.Logger\n\n  canJoin: JoinFunction\n\n  constructor(branch: BranchKey, jf: JoinFunction = MinimalJoinFunction) {\n    this.branch = branch\n    this.canJoin = jf\n  }\n\n  /**\n   * The goal of this method is to find the Logoot position corresponding to a\n   * particular local position. Unlike the old version, this does **not**\n   * actually record the insertion. The output of this must be passed in to\n   * `insertLogoot` for that to happen. This provides greater flexibility for\n   * the programmer. All insertions will be determined on the `branch` variable\n   * of this class. This means that if this funcion is called and the start\n   * position is in between two atoms, the first on `branch` and the second not,\n   * the resulting order will leave the new atom after the first atom, but *not\n   * necessarily* after the second atom since conflicts allow atoms to appear\n   * out of their Logoot order. However, if an insertion is attempted between\n   * two atoms on branches that are not `branch`, then it will not be possible\n   * to determine where the resulting node should go. A `InsertionConflictError`\n   * will be thrown. UI should respond to this by informing the user to resolve\n   * the conflict first.\n   * @param start - The position of the insertion\n   * @param length - The length of the insertion\n   * @returns An object containing `start` (a LogootPosition), `length`, `br`\n   * (just `this.branch`), and `rclk` (just `this.clock`). The `start` value is\n   * the only one that is actually calculated. The others are returned for\n   * convenience.\n   */\n  insertLocal(\n    start: number,\n    length: number\n  ): {\n    start: LogootPosition\n    length: number\n    br: BranchKey\n    rclk: LogootInt\n  } {\n    // Search:\n    // n < start   -> _lesser\n    // start <= n  -> _greater\n    const { buckets } = this.ldoc_bst.search(\n      new NumberRange(start, start, RangeBounds.LOGO)\n    )\n\n    let lesser: ConflictGroup\n    let greater: ConflictGroup\n    if (buckets.lesser && buckets.lesser.length) {\n      // The earliest one will not be a only a removal if nodes are ordered\n      // properly. We can ignore the removals in between\n      lesser = buckets.lesser\n        .map(([, cg]) => cg)\n        .sort((a, b) => a.logoot_start.cmp(b.logoot_start))[0]\n    }\n    if (buckets.greater && buckets.greater.length) {\n      // Now grab the last element...\n      greater = buckets.greater\n        .map(([, cg]) => cg)\n        .sort((a, b) => b.logoot_start.cmp(a.logoot_start))[0]\n    }\n\n    let before_position\n    let after_position\n\n    const lesser_length = lesser ? lesser.ldoc_length : 0\n    if (lesser && lesser.known_position + lesser_length === start) {\n      // Between two CGs...\n      if (\n        greater &&\n        lesser.last_branch === greater.first_branch &&\n        lesser.last_branch !== this.branch\n      ) {\n        // If we're between two CGs and they both are on the same branch, it's\n        // impossible to tell on which the insertion should be made\n        throw new InsertionConflictError()\n      }\n      before_position = lesser.logoot_end\n      after_position = greater ? greater.logoot_start : undefined\n    } else if (lesser) {\n      ;((): void => {\n        let remaining_length = start - lesser.known_position\n        if (lesser.branch_order.indexOf(this.branch) < 0) {\n          remaining_length -= lesser.ldoc_length\n        } else {\n          remaining_length -= lesser.branchLength(\n            lesser.branch_order.slice(\n              0,\n              lesser.branch_order.indexOf(this.branch)\n            )\n          )\n        }\n        if (remaining_length < 0) {\n          throw new FatalError('Search returned out of order nodes')\n        }\n        if (remaining_length === 0) {\n          // We're at the left end here, so we have to look up *another* lesser\n          // Search:\n          // n < lesser.known_position   -> _lesser\n          // lesser.known_position <= n  -x\n          // TODO: Don't find `greater`. Maybe make a range that ignores one\n          // bound?\n          // TODO: What about the case where two CGs have the same start\n          // position?\n          const { buckets } = this.ldoc_bst.search(\n            new NumberRange(\n              lesser.known_position,\n              lesser.known_position,\n              RangeBounds.LOGC\n            )\n          )\n\n          let most_lesser\n          if (buckets.lesser && buckets.lesser.length) {\n            most_lesser = buckets.lesser\n              .map(([, cg]) => cg)\n              .sort((a, b) => a.logoot_start.cmp(b.logoot_start))[0]\n          }\n          // Now, go in between the two nodes just as we would've above\n          before_position = most_lesser.logoot_end\n          after_position = lesser.logoot_start\n          return\n        }\n\n        // So, we're not at the start. Find a good position\n        for (let i = 0; i < lesser.groups.length; i++) {\n          const { end } = lesser.groups[i]\n          remaining_length -= lesser.groups[i].branchLength([this.branch])\n\n          if (remaining_length < 0) {\n            before_position = after_position = end.inverseOffsetLowest(\n              -remaining_length\n            )\n            return\n          } else if (remaining_length === 0) {\n            before_position = end\n            after_position = lesser.groups[i + 1]\n              ? lesser.groups[i + 1].start\n              : greater\n              ? greater.logoot_start\n              : undefined\n            return\n          }\n        }\n        // We must be in between two branches that are not ours\n        throw new InsertionConflictError()\n      })()\n    } else if (greater) {\n      after_position = greater.logoot_start\n    }\n\n    return {\n      start: new LogootPosition(length, before_position, after_position),\n      length,\n      br: this.branch,\n      rclk: this.clock\n    }\n  }\n\n  /**\n   * Finds the sets of Logoot positions in a certain real text range. This is\n   * used to find the removal operations to perform, but it does **not**\n   * actually record the updates, just like `insertLocal`.\n   * @param start - The position to start removing, inclusive.\n   * @param length - The length of the removal\n   * @returns - An object containing an array of `removals`. Each removal has a\n   * `start` LogootPosition, a numeric `length`, a `branch` (which is a\n   * BranchKey), and a `rclk` vector clock value.\n   */\n  removeLocal(start: number, length: number): { removals: Removal[] } {\n    // Search:\n    // n < start   -> _lesser\n    // start <= n  -> _greater\n    const { buckets } = this.ldoc_bst.search(\n      new NumberRange(start, start + length, RangeBounds.LOGC)\n    )\n\n    const nodes = buckets.range.map(([, cg]) => cg)\n    if (buckets.lesser && buckets.lesser.length) {\n      // The earliest one will not be a only a removal if nodes are ordered\n      // properly. We can ignore the removals in between\n      const l = buckets.lesser\n        .map(([, cg]) => cg)\n        .sort((a, b) => a.logoot_start.cmp(b.logoot_start))[0]\n      if (l.ldoc_end > start) {\n        nodes.unshift(l)\n      }\n    }\n\n    const removal_sets: { [key: string]: { [key: number]: Removal[] } } = {}\n    function onRemoval(\n      br: BranchKey,\n      start: LogootPosition,\n      len: number,\n      rclk: LogootInt\n    ): void {\n      if (len <= 0) {\n        return\n      }\n      if (!removal_sets[(br as unknown) as string]) {\n        removal_sets[(br as unknown) as string] = {}\n      }\n      const branch_removals = removal_sets[(br as unknown) as string]\n\n      if (!branch_removals[start.levels]) {\n        branch_removals[start.levels] = []\n      }\n      const depth_removals = branch_removals[start.levels]\n      const last_removal = depth_removals[depth_removals.length - 1]\n\n      if (\n        last_removal &&\n        last_removal.branch === br &&\n        last_removal.start.offsetLowest(last_removal.length).cmp(start) === 0 &&\n        last_removal.rclk.cmp(rclk) === 0\n      ) {\n        last_removal.length += len\n      } else {\n        depth_removals.push({ branch: br, start, length: len, rclk })\n      }\n    }\n\n    let remaining_length = start + length - nodes[0].known_position\n    // TODO: This is *really* inefficient for obvious reasons\n    catchBreak(() =>\n      nodes.forEach((cg) => {\n        cg.branch_order.forEach((br) => {\n          cg.groups.forEach((group) => {\n            if (!group.br(br)) {\n              return\n            }\n            let { start, length: rlen } = group\n            const { type, rclk } = group.br(br)\n\n            if (type === NodeType.DATA) {\n              if (remaining_length > length) {\n                start = start.offsetLowest(remaining_length - length)\n                rlen -= remaining_length - length\n              }\n              onRemoval(br, start, Math.min(rlen, remaining_length), rclk)\n              remaining_length -= group.length\n            }\n            if (remaining_length <= 0) {\n              throw BreakException\n            }\n          })\n        })\n      })\n    )\n\n    const removals: Removal[] = []\n    allValues(removal_sets).forEach((branch_set) => {\n      Object.entries(branch_set).forEach(([, depth_set]) => {\n        depth_set.forEach((o) => removals.push(o))\n      })\n    })\n\n    return { removals }\n  }\n\n  /**\n   * This is the most important method in the `ListDocumentModel`. This method\n   * adds atoms to the BSTs. By consequence, it replaces nodes and generates\n   * conflicts as necessary to add the node to the BST. **Users should never\n   * call this function directly.**\n   * @param br - The branch to insert on\n   * @param nstart - The start Logoot position of the insertion\n   * @param length - The length of the insertion\n   * @param nrclk - The clock value for the insertion\n   * @param type - The type of node to add. Anything other than data will result\n   * in data being removed if it conflicts on the same branch\n   * @param canJoin - A `JoinFunction` to determine if two node groups should\n   * be joined together in the same conflict group\n   */\n  _mergeNode(\n    br: BranchKey,\n    nstart: LogootPosition,\n    length: number,\n    nrclk: LogootInt,\n    type: NodeType,\n    canJoin: JoinFunction\n  ): Operation[] {\n    if (this.debug_logger) {\n      this.debug_logger.log({\n        br,\n        start: nstart,\n        length,\n        rclk: nrclk,\n        type\n      })\n    }\n\n    debug.info(`Merging ${type} ${String(br)} ${nstart} + ${length} @ ${nrclk}`)\n\n    const level = nstart.levels\n    const nend = nstart.offsetLowest(length)\n\n    if (this.clock.cmp(nrclk) < 0) {\n      this.clock.assign(nrclk)\n    }\n\n    // Search:\n    // n < nstart          -> _lesser\n    // nstart <= n < nend  -> _skip_ranges\n    // nend <= n           -> _greater\n    const range_search = this.logoot_bst.create_range_search()\n    range_search.lesser_find_greatest = true\n    range_search.greater_find_least = true\n    range_search.push_point({ start: nstart }, '_lesser', false)\n    range_search.push_point({ start: nend }, '_skip_ranges', false)\n    range_search.all_greater('_greater')\n    const { _lesser, _skip_ranges, _greater } = this.logoot_bst.search(\n      range_search\n    )\n\n    let lesser\n    let greater\n    if (_lesser && _lesser.length > 1) {\n      throw new FatalError(\n        'Corrupt BST. There are multiple nodes at a position.'\n      )\n    } else if (_lesser && _lesser.length) {\n      lesser = _lesser[0]\n    }\n    if (_greater && _greater.length > 1) {\n      throw new FatalError(\n        'Corrupt BST. There are multiple nodes at a position.'\n      )\n    } else if (_greater && _greater.length) {\n      greater = _greater[0]\n    }\n    let skip_ranges = _skip_ranges\n      ? _skip_ranges.sort((a, b) => a.start.cmp(b.start))\n      : []\n\n    if (lesser && skip_ranges.includes(lesser)) {\n      skip_ranges.splice(skip_ranges.indexOf(lesser), 1)\n    }\n    if (greater && skip_ranges.includes(greater)) {\n      skip_ranges.splice(skip_ranges.indexOf(greater), 1)\n    }\n    if (lesser) {\n      skip_ranges.unshift(lesser)\n    }\n    // Split lesser if there's no way that it will conflict (which will be if\n    // it's on a higher level)\n    if (\n      lesser &&\n      lesser.start.levels < level &&\n      lesser.start.cmp(nstart) < 0 &&\n      lesser.end.cmp(nend) > 0\n    ) {\n      const split_pos = nstart\n        .copy()\n        .level(lesser.start.levels)\n        .sub(lesser.start.level(lesser.start.levels)).js_int\n      if (split_pos > 0 && split_pos < lesser.length) {\n        const lesser_end = lesser.splitAround(split_pos)\n        skip_ranges.push(lesser_end)\n        this.logoot_bst.add(lesser_end)\n      }\n    }\n    if (greater && !skip_ranges.includes(greater)) {\n      skip_ranges.push(greater)\n    }\n\n    // Keep track of all the conflict groups we're automatically modifying\n    let conflict_order: ConflictGroup[] = []\n    if (skip_ranges.length) {\n      const ke = skip_ranges[skip_ranges.length - 1].group.ldoc_end\n\n      conflict_order = this.ldoc_bst\n        .search(new NumberRange(skip_ranges[0].group.known_position, ke))\n        .buckets.range.sort((a, b) => a[0] - b[0])\n        .map(([, cg]) => cg)\n    }\n\n    // Nodes on higher levels do not matter in our collision search, only in the\n    // sorting done by the BSTs. Lower levels matter since we must skip them.\n    // HOWEVER, we do need a greater node so that the algorithm will detect the\n    // next CG and (maybe) join into it\n    // TODO: Maybe a better search algo could come up with a pre-filtered\n    // `skip_ranges` for me\n    skip_ranges = skip_ranges.filter(\n      ({ start }) => start.levels >= level || start.cmp(nend) >= 0\n    )\n\n    // Ensure that there's something at the end of the list so that it will\n    // always run regardless and if there are nodes, that there is always a node\n    // last in the array at the end position\n    if (\n      !skip_ranges.length ||\n      skip_ranges[skip_ranges.length - 1].start.cmp(nend) < 0\n    ) {\n      const vgroup = new LogootNodeGroup()\n      vgroup.start = nend\n      skip_ranges.push(vgroup)\n    }\n\n    /* const original_known_end = conflict_order.length\n      ? conflict_order[conflict_order.length - 1].ldoc_end\n      : 0 */\n\n    // Track all the operations that have been performed and the offset that\n    // should be placed on nodes after this one. This will modify the nodes\n    // in `conflict_order`\n    const operations: Operation[] = []\n    const remove = (cg: ConflictGroup, start: number, length: number): void => {\n      if (length === 0) {\n        return\n      }\n      operations.push({\n        type: 'r',\n        start,\n        length\n      })\n      const successor = cg.inorder_successor\n      if (successor) {\n        successor.addSpaceBefore(-length)\n      }\n    }\n    const insert = (\n      cg: ConflictGroup,\n      start: number,\n      offset: number,\n      length: number\n    ): void => {\n      if (length === 0) {\n        return\n      }\n      operations.push({\n        type: 'i',\n        start,\n        offset,\n        length\n      })\n      const successor = cg.inorder_successor\n      if (successor) {\n        successor.addSpaceBefore(length)\n      }\n    }\n    const translate = (source: number, length: number, dest: number): void => {\n      if (length === 0) {\n        return\n      }\n      if (source === dest) {\n        return\n      }\n      operations.push({ type: 't', source, length, dest })\n    }\n    const mark = (\n      start: number,\n      length: number,\n      conflicting: boolean\n    ): void => {\n      if (length === 0) {\n        return\n      }\n      operations.push({ type: 'm', start, length, conflicting })\n    }\n\n    // Split a conflict group and translate the child nodes\n    const splitCg = (cg: ConflictGroup, ng: LogootNodeGroup): ConflictGroup => {\n      if (!cg.groups.includes(ng)) {\n        throw new FatalError('Node group not in conflict group.')\n      }\n      if (!conflict_order.includes(cg)) {\n        throw new FatalError('Conflict group not in conflict_order')\n      }\n\n      // New Conflict Group -- Ok, my naming is bad here lol\n      const ncg = new ConflictGroup(cg.ldoc_end)\n\n      let known_position = cg.known_position\n      const known_end = ncg.known_position\n      cg.branch_order.forEach((br) => {\n        // Calculate the area ahead of the known_position that isn't moved\n        const excerpt_length = ((): number => {\n          let origin = 0\n          for (let i = 0; i < cg.groups.length; i++) {\n            origin += cg.groups[i].branchLength([br])\n            if (cg.groups[i] === ng) {\n              return origin\n            }\n          }\n          // This should never happen\n          throw new FatalError()\n        })()\n\n        ncg.branch_order.push(br)\n\n        const moved_length = cg.branchLength([br]) - excerpt_length\n\n        ncg.value -= moved_length\n        known_position += excerpt_length\n        translate(known_position, moved_length, known_end - moved_length)\n      })\n\n      ncg.groups = cg.groups.splice(cg.groups.indexOf(ng) + 1, cg.groups.length)\n      ncg.groups.forEach((group) => (group.group = ncg))\n\n      this.ldoc_bst.add(ncg)\n      conflict_order.splice(conflict_order.indexOf(cg) + 1, 0, ncg)\n\n      return ncg\n    }\n    // Join a conflict group and translate the child nodes\n    const joinCg = (lcg: ConflictGroup, ncg: ConflictGroup): void => {\n      ncg.branch_order.forEach((br) => {\n        if (!lcg.branch_order.includes(br)) {\n          lcg.branch_order.push(br)\n        }\n      })\n\n      ncg.groups.forEach((group) => (group.group = lcg))\n      lcg.groups.splice(lcg.groups.length, 0, ...ncg.groups)\n\n      let fetch_position = ncg.known_position\n      let known_position = lcg.known_position\n      ncg.branch_order.forEach((br) => {\n        known_position += lcg.branchLength([br])\n        const next_length = ncg.branchLength([br])\n        translate(fetch_position, next_length, known_position - next_length)\n        fetch_position += next_length\n      })\n\n      ncg.branch_order.length = 0\n      ncg.groups = []\n      // Ensure that we remove **only** this node from the BST\n      this.ldoc_bst.remove(ncg.known_position, (other) => other === ncg)\n      conflict_order.splice(conflict_order.indexOf(ncg), 1)\n    }\n\n    let last_start = nstart.level(level)\n    let last_group = lesser\n    skip_ranges.forEach((group, i) => {\n      // Can be reassigned when nodes are split\n      let next_group = skip_ranges[i + 1]\n\n      const group_level_start = group.start.clamp(nstart, nend, level).l(level)\n      const group_level_end = group.end.clamp(nstart, nend, level).l(level)\n\n      const empty_length = group_level_start.copy().sub(last_start).js_int\n      const empty_offset = last_start.copy().sub(nstart.l(level)).js_int\n\n      // First, add a new group to the empty space (if there is any)\n      if (\n        empty_length > 0 ||\n        // If the next node has fewer levels, the empty space is *technically*\n        // infinite, but empty_length won't show this\n        (group.start.levels < level &&\n          length - empty_offset > 0 &&\n          group.start.cmp(nstart) > 0 &&\n          last_start.cmp(nstart.l(level)) < 0)\n      ) {\n        const newgroup = new LogootNodeGroup()\n        newgroup.start = nstart.copy()\n        newgroup.start.l(level).assign(last_start)\n        newgroup.length = empty_length || length - empty_offset\n        newgroup.br(br, { type, rclk: nrclk })\n        debug.info(`Creating new group at ${newgroup.start.toString()}`)\n\n        // Now, we actually insert the node where it should be according to the\n        // node canJoin function\n        // First, check if we can join with the two nodes flanking this one\n        // Remember, we're operating BEFORE `group`\n        const last_join = last_group && canJoin(last_group, newgroup)\n        const next_join = group && canJoin(newgroup, group)\n        const already_joined =\n          last_group && group && last_group.group === group.group\n\n        if (!already_joined && last_join && next_join) {\n          // Join last and next\n          joinCg(last_group.group, group.group)\n        } else if (already_joined && !(last_join && next_join)) {\n          // Split last and next\n          splitCg(last_group.group, last_group)\n        }\n\n        if (!last_join && !next_join) {\n          // Ok, so now we need to create a new conflict group\n          newgroup.group = new ConflictGroup(\n            last_group ? last_group.group.ldoc_end : 0\n          )\n          newgroup.group.branch_order.push(br)\n\n          conflict_order.splice(\n            last_group ? conflict_order.indexOf(last_group.group) + 1 : 0,\n            0,\n            newgroup.group\n          )\n        } else {\n          // Now, make sure we have a target group\n          newgroup.group = last_join ? last_group.group : group.group\n        }\n\n        if (type === NodeType.DATA) {\n          const ipos = newgroup.group.insertSingleBranchGroup(newgroup)\n          if (!last_join && !next_join) {\n            this.ldoc_bst.add(newgroup.group)\n          }\n          insert(newgroup.group, ipos, empty_offset, newgroup.length)\n        } else {\n          newgroup.group.insertSingleBranchGroup(newgroup)\n          if (!last_join && !next_join) {\n            this.ldoc_bst.add(newgroup.group)\n          }\n        }\n\n        last_group = newgroup\n        this.logoot_bst.add(newgroup)\n      }\n\n      const group_length = group_level_end.copy().sub(group_level_start).js_int\n      const group_offset = group_level_start.copy().sub(nstart.l(level)).js_int\n      // Now, add the new node to the existing group\n      if (\n        group.start.levels === level &&\n        group_length > 0 &&\n        (!group.br(br) ||\n          // Data nodes have the lowest priority\n          nrclk.cmp(group.br(br).rclk) > (type === NodeType.DATA ? 0 : -1))\n      ) {\n        // Split off the trailing start\n        if (group.start.cmp(nstart) < 0) {\n          last_group = group\n          group = group.splitAround(\n            nstart.l(level).sub(group.start.l(level)).js_int\n          )\n          this.logoot_bst.add(group)\n        }\n        // Split off the trailing end\n        if (group.end.cmp(nend) > 0) {\n          const newgroup = group.splitAround(\n            group.length - group.end.l(level).sub(nend.l(level)).js_int\n          )\n          this.logoot_bst.add(newgroup)\n          next_group = newgroup\n        }\n        debug.info(`Adding to existing group at ${group.start.toString()}`)\n\n        // Ensure that this group is in the branch order\n        if (!group.group.branch_order.includes(br)) {\n          group.group.branch_order.push(br)\n        }\n\n        // Now, capture this node's target position\n        const known_position = group.group.insertPos(br, group)\n        // Remove old conflicts\n        if (group.br(br) && group.br(br).type === NodeType.DATA) {\n          remove(group.group, known_position, group.length)\n        }\n        // Ensure the new data is correct\n        group.br(br, { type, rclk: nrclk })\n        // Add new data\n        if (type === NodeType.DATA) {\n          insert(group.group, known_position, group_offset, group.length)\n        }\n\n        const fixJoined = (a: LogootNodeGroup, b: LogootNodeGroup): void => {\n          if (!a || !b) {\n            return\n          }\n          const joined = a.group === b.group\n          const should_join = canJoin(a, b)\n          if (!joined && should_join) {\n            joinCg(a.group, b.group)\n          } else if (joined && !should_join) {\n            // The BST allows chaning of the `known_position` after adding a\n            // node, **so long as the nodes are in the same order.** Since not\n            // all node positions have been updated, we cannot add the node with\n            // the pre-incremented position\n            splitCg(a.group, a)\n          }\n        }\n\n        // Double check that these nodes still should be joined\n        fixJoined(last_group, group)\n        fixJoined(group, next_group)\n      }\n\n      last_start = group.end.clamp(nstart, nend, level).level(level)\n      last_group = group\n    })\n\n    // TODO: Actually figure out which CGs have changed state\n    conflict_order.forEach(({ known_position, ldoc_length, conflicted }) => {\n      mark(known_position, ldoc_length, conflicted)\n    })\n\n    return operations\n  }\n\n  insertLogoot(\n    br: BranchKey,\n    start: LogootPosition,\n    length: number,\n    rclk: LogootInt\n  ): Operation[] {\n    return this._mergeNode(br, start, length, rclk, NodeType.DATA, this.canJoin)\n  }\n\n  removeLogoot(\n    br: BranchKey,\n    start: LogootPosition,\n    length: number,\n    rclk: LogootInt\n  ): Operation[] {\n    return this._mergeNode(\n      br,\n      start,\n      length,\n      rclk,\n      NodeType.REMOVAL,\n      this.canJoin\n    )\n  }\n\n  /**\n   * An extremely expensive operation that scans the BSTs for obvious signs of\n   * corruption (empty CGs, non-continuous ldoc, out-of-order ldoc, etc.)\n   * @throws {FatalError} If any corruption detected\n   */\n  selfTest(): void {\n    let last_pos: LogootPosition\n    let last_kp = 0\n    this.ldoc_bst.operateOnAll((data) => {\n      if (!data.groups.length) {\n        throw new FatalError('Node with no groups detected.')\n      }\n      if (data.known_position !== last_kp) {\n        throw new Error(\n          `Ldoc is out of order. Found known position ${data.known_position} after ${last_kp}`\n        )\n      }\n      last_kp = data.ldoc_end\n      data.groups.forEach(({ start }) => {\n        if (last_pos && last_pos.cmp(start) >= 0) {\n          throw new FatalError(\n            `Ldoc is out of order. Found ${start.toString()} after ${last_pos.toString()}.`\n          )\n        }\n        last_pos = start\n      })\n    })\n  }\n}\n\nnamespace ListDocumentModel {\n  export type LogOperation = {\n    br: BranchKey\n    start: LogootPosition\n    length: number\n    rclk: LogootInt\n    type: NodeType\n  }\n  export interface Logger {\n    log(op: LogOperation): void\n    replayAll(\n      ldm: ListDocumentModel,\n      post?: (ldm: ListDocumentModel) => void\n    ): void\n  }\n  export class JsonableLogger implements Logger {\n    ops: LogOperation[] = []\n    log(op: LogOperation): void {\n      this.ops.push(op)\n    }\n    replayAll(\n      ldm: ListDocumentModel,\n      post: (\n        ldm: ListDocumentModel,\n        logop: LogOperation,\n        newops: Operation[]\n      ) => void = (): void => undefined\n    ): Operation[] {\n      let ops: Operation[] = []\n      let newops: Operation[]\n      this.ops.forEach((o) => {\n        newops = ldm._mergeNode(\n          o.br,\n          o.start,\n          o.length,\n          o.rclk,\n          o.type,\n          ldm.canJoin\n        )\n        ops = ops.concat(newops)\n        post(ldm, o, newops)\n      })\n      return ops\n    }\n\n    restoreFromJSON(j: JsonableLogger.JSON[]): JsonableLogger {\n      this.ops = j.map((o) => ({\n        br: `BR[${o.b.toString(16)}]`,\n        start: LogootPosition.fromJSON(o.s),\n        length: o.l,\n        rclk: LogootInt.fromJSON(o.r),\n        type:\n          o.t === 'D'\n            ? NodeType.DATA\n            : o.t === 'R'\n            ? NodeType.REMOVAL\n            : ((): NodeType => {\n                throw new TypeError('Node type was not one of DATA or REMOVAL')\n              })()\n      }))\n      return this\n    }\n    toJSON(): JsonableLogger.JSON[] {\n      const brk_tbl: { [key: string]: number } = {}\n      let _brk_i = 0\n      const map_brk = (k: BranchKey): number => {\n        if (brk_tbl[(k as unknown) as string] === undefined) {\n          brk_tbl[(k as unknown) as string] = _brk_i++\n        }\n        return brk_tbl[(k as unknown) as string]\n      }\n      return this.ops.map((o) => ({\n        b: map_brk(o.br),\n        s: o.start.toJSON(),\n        l: o.length,\n        r: o.rclk.toJSON(),\n        t:\n          o.type === NodeType.DATA\n            ? 'D'\n            : NodeType.REMOVAL\n            ? 'R'\n            : ((): string => {\n                throw new TypeError('Node type was not one of DATA or REMOVAL')\n              })()\n      }))\n    }\n  }\n  export namespace JsonableLogger {\n    export type JSON = {\n      b: number\n      s: LogootPosition.JSON\n      l: number\n      r: LogootInt.JSON\n      t: string\n    }\n  }\n}\n\nexport {\n  LogootInt,\n  LogootPosition,\n  KnownPositionBst,\n  LogootBst,\n  Removal,\n  ListDocumentModel,\n  NodeType\n}\n","/**\n * @file This contains most of the data types used by the `ListDocumentModel`.\n * While `index.ts` does most of the heavy lifting, this file is the source of\n * most definitions used there. The files were split to make it easier for me to\n * switch since I can switch using tabs in my text editor.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport { DBstNode, DBstSearchable } from '../bst'\nimport { Int32 } from '../ints'\nimport { CompareResult, FatalError, allKeys } from '../utils'\n\n// What a C++ typedef would do\n// This makes it possible to completely swap out the type of the int used in the\n// algorithm w/o actually replacing each instance (which would be a real pain)\nimport LogootInt = Int32\n\n/**\n * A position in Logoot. This is just an array of numbers with some utility\n * functions. In Logoot, it must always be possible to allocate a position\n * between any possible two positions. In this algorithm, a position with more\n * `levels` (or elements in the array) comes first. So, if it is necessary to\n * create a position between `A` and `B`, then another level can be added to the\n * position to make it come after `A` and before `B`. Positions are represented\n * in writing the same as arrays: `[1,2,3]`\n * @example ```typescript\n * const a = new LogootPosition()\n * console.log(a.toString()) // [0]\n *\n * const b = a.offsetLowest(1)\n * console.log(b.toString()) // [1]\n *\n * console.log(new LogootPosition(1, a, b).toString()) // [0]\n * console.log(new LogootPosition(2, a, b).toString()) // [0,0]\n * ```\n */\nclass LogootPosition {\n  protected array: LogootInt[] = [new LogootInt(0)]\n\n  /**\n   * This constructor constructs a new position that is in the range specified\n   * by `start` and `end`. By using `len`, it is possible to enforce that a\n   * certain number of additional positions are available in the selected range.\n   * This guarantees that there's space for a LogootNode of length `len` at this\n   * position between `start` and `end`.\n   *\n   * @param len - The length of the allocation to make. The length is never\n   * actually stored in the Logoot position, but is used when finding space for\n   * the position to be created and `len` position(s) after it.\n   * @param start - This will cause the new position to have a value greater\n   * than or equal to this. This value is tricky: It must be the end of the last\n   * node. So if `A` is at `[1]` and an allocation *after* it is desired, then\n   * `[2]` would need to be passed to `start`.\n   * @param end - This will cause the new position to have a value less than or\n   * equal to this, subject to the value of `len`.\n   */\n  constructor(\n    len = 0,\n    readonly start?: LogootPosition,\n    readonly end?: LogootPosition\n  ) {\n    if (!start && end) {\n      this.array = end.inverseOffsetLowest(len).array\n    } else if (!end && start) {\n      this.array = start.copy().array\n    } else if (start && end) {\n      let done = false\n      const itstart = start.array.values()\n      const itend = end.array.values()\n      let nstart\n      let nend\n\n      this.array.length = 0\n\n      while (!done) {\n        if (!nstart || !nstart.done) {\n          nstart = itstart.next()\n        }\n        if (!nend || !nend.done) {\n          nend = itend.next()\n        }\n\n        if (!nstart.done && !nend.done) {\n          // See if we have enough space to insert 'len' between the nodes\n          if (nend.value.gteq(new LogootInt(nstart.value).add(len))) {\n            // There's space. We're done now: At the shallowest possible level\n            done = true\n          }\n          // Regardless, the start ID is the new ID for this level of our node\n          this.array.push(new LogootInt(nstart.value))\n        } else if (!nstart.done) {\n          // So there's no end restriction, that means we can just add right on\n          // top of the old end (the start of the new node)\n          this.array.push(new LogootInt(nstart.value))\n          done = true\n        } else if (!nend.done) {\n          // We have an end restriction, but no start restriction, so we just\n          // put the new node's start behind the old end\n          this.array.push(new LogootInt(nend.value).sub(len))\n          done = true\n        } else {\n          // So both other IDs have nothing else. It must be time to make a new\n          // level and be done\n          this.array.push(new LogootInt())\n          done = true\n        }\n      }\n    }\n  }\n\n  static fromJSON(eventnode: LogootPosition.JSON): LogootPosition {\n    const pos = new LogootPosition()\n    pos.array.length = 0\n    eventnode.forEach((n) => {\n      pos.array.push(LogootInt.fromJSON(n))\n    })\n    return pos\n  }\n  static fromInts(...ints: (LogootInt | number)[]): LogootPosition {\n    const pos = new LogootPosition()\n    pos.array.length = 0\n    ints.forEach((n) => {\n      pos.array.push(new LogootInt(n))\n    })\n    return pos\n  }\n  toJSON(): LogootPosition.JSON {\n    return this.array.map((n) => n.toJSON())\n  }\n\n  /**\n   * @returns Internal array length\n   */\n  get length(): number {\n    // A zero-length position is NOT valid\n    // Through some sneakiness, you COULD directly assign the array to make it\n    // have a length of zero. Don't do it.\n    return this.array.length\n  }\n  /**\n   * Returns the last index of the array. This is useful because before this,\n   * the algorithm code often contained many occurences of `length - 1`. This\n   * is used to cut down redundancy.\n   */\n  get levels(): number {\n    // A zero-length position is NOT valid\n    // Through some sneakiness, you COULD directly assign the array to make it\n    // have a length of zero. Don't do it.\n    return this.length - 1\n  }\n  /**\n   * An array accessor\n   */\n  level(n: number): LogootInt {\n    return this.array[n]\n  }\n  /**\n   * An array accessor\n   * @alias level\n   */\n  l(n: number): LogootInt {\n    return this.level(n)\n  }\n\n  /**\n   * Returns a new position with `offset` added to the lowest level of the\n   * position.\n   */\n  offsetLowest(offset: number | LogootInt): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((current, i, array) => {\n        return i < array.length - 1\n          ? current\n          : new LogootInt(current).add(offset)\n      })\n    })\n  }\n  /**\n   * Returns a new position with `offset` subtracted from the lowest level of\n   * the position.\n   */\n  inverseOffsetLowest(offset: number | LogootInt): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((current, i, array) => {\n        return i < array.length - 1\n          ? current\n          : new LogootInt(current).sub(offset)\n      })\n    })\n  }\n\n  /**\n   * Duplicates this position.\n   */\n  copy(): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: this.array.map((e) => new LogootInt(e))\n    })\n  }\n\n  /**\n   * Return a copy of this position, but with the number of levels specified by\n   * `level`. If this position has fewer levels, zeroes will be added in place.\n   */\n  equivalentPositionAtLevel(level: number): LogootPosition {\n    return Object.assign(new LogootPosition(), {\n      array: new Array(level + 1).fill(0, 0, level + 1).map((el, i) => {\n        return new LogootInt(this.array[i])\n      })\n    })\n  }\n\n  cmp(pos: LogootPosition, level = 0): CompareResult {\n    if (level >= this.length) {\n      if (this.length === pos.length) {\n        return 0\n      }\n      return 1\n    }\n    if (level >= pos.length) {\n      return -1\n    }\n    switch (this.level(level).cmp(pos.level(level))) {\n      case 1:\n        return 1\n      case -1:\n        return -1\n      case 0:\n        return this.cmp(pos, level + 1)\n      default:\n        return 0\n    }\n  }\n\n  /**\n   * Return this position if it is between `min` or `max`, otherwise return\n   * `min` if this is less and `max` if this is greater.\n   * @param min - The minimum output.\n   * @param max - The maximum output.\n   * @param preserve_levels - If defined, the output number of levels will be\n   * equal to `preserve_levels`.\n   * @returns Either this position, min, or max. It is **not** copied, so if you\n   * want to modify it, you should copy it.\n   */\n  clamp(\n    min: LogootPosition,\n    max: LogootPosition,\n    preserve_levels?: undefined | number\n  ): LogootPosition {\n    const clamped = this.cmp(min) < 0 ? min : this.cmp(max) > 0 ? max : this\n    if (preserve_levels !== undefined) {\n      return clamped.equivalentPositionAtLevel(preserve_levels)\n    } else {\n      return clamped.copy()\n    }\n  }\n\n  toString(): string {\n    let str = '['\n    this.array.forEach((el, i, a) => {\n      str += el.toString() + (i >= a.length - 1 ? '' : ',')\n    })\n    str += ']'\n    return str\n  }\n}\nnamespace LogootPosition {\n  export type JSON = LogootInt.JSON[]\n  export namespace JSON {\n    export const Schema = { type: 'array', items: LogootInt.JSON.Schema }\n  }\n}\n\n/**\n * A type used to identify a branch. This value should be used to look up a\n * user-presentable name in another map stored outside of `logootish-js`. This\n * is implementation-defined and allows for the broadest possible definition of\n * a branch.\n */\ntype BranchKey = symbol | string | number\n\n/**\n * The type of node stored in a `LogootNodeGroup`.\n */\nenum NodeType {\n  DATA,\n  REMOVAL\n}\n/**\n * Names for NodeType that are printed in debug information.\n */\nconst nt_string = {\n  [NodeType.DATA]: 'DATA',\n  [NodeType.REMOVAL]: 'REMOVAL'\n}\n\n/**\n * A group of `LogootNodeGroup`s that are considered by the `JoinFunction` (see\n * the list document model `index.ts` file) to be related. Each Logoot node is\n * not displayed in the order specified in `groups`. Rather, all of the nodes on\n * a particular branch are displayed together and in the order defined by\n * `branch_order`.\n * @TODO Move `branch_order` into the ListDocumentModel. No reason not to have\n * a whole-document branch order.\n */\nclass ConflictGroup extends DBstNode<ConflictGroup> {\n  /**\n   * The order in which branches are displayed. All of the nodes that make up\n   * a single branch are placed together.\n   */\n  readonly branch_order: BranchKey[] = []\n  /**\n   * A list of `LogootNodeGroups` that make up the Logoot side of the local\n   * document. A group's nodes will be split up and placed into one of the\n   * branch sections as defined in `branch_order`. These **absolutely must** be\n   * in order based on their Logoot positions.\n   */\n  groups: LogootNodeGroup[] = []\n\n  constructor(position: number) {\n    super(position)\n  }\n\n  get known_position(): number {\n    return this.absolute_value\n  }\n\n  /**\n   * Get the equivalent length of all data nodes.\n   */\n  get ldoc_length(): number {\n    return this.groups.reduce((n, group) => {\n      return n + group.ldoc_length\n    }, 0)\n  }\n  /**\n   * Find the end in the local document,\n   */\n  get ldoc_end(): number {\n    return this.known_position + this.ldoc_length\n  }\n\n  /**\n   * Get the first group's Logoot position\n   */\n  get logoot_start(): LogootPosition {\n    return this.groups[0] ? this.groups[0].start : undefined\n  }\n  /**\n   * Get the last group's Logoot position\n   */\n  get logoot_end(): LogootPosition {\n    return this.groups.length\n      ? this.groups[this.groups.length - 1].end\n      : undefined\n  }\n\n  preferential_cmp(other: DBstSearchable | ConflictGroup): CompareResult {\n    if ((other as { logoot_start: LogootPosition }).logoot_start) {\n      return this.logoot_start.cmp((other as ConflictGroup).logoot_start)\n    }\n    return 0\n  }\n\n  /**\n   * Get the first branch in this group.\n   */\n  get first_branch(): BranchKey {\n    return this.branch_order[0]\n  }\n  /**\n   * Get the last branch in this group.\n   */\n  get last_branch(): BranchKey {\n    return this.branch_order.length\n      ? this.branch_order[this.branch_order.length - 1]\n      : undefined\n  }\n\n  /**\n   * True if any groups are conflicted.\n   */\n  get conflicted(): boolean {\n    return this.groups.some((g) => g.conflicted)\n  }\n  /**\n   * The length in the local document (only `DATA` nodes) of only `branches`.\n   * @param branches - A list of branches to count.\n   */\n  branchLength(branches: BranchKey[]): number {\n    return this.groups.reduce((n, group) => {\n      return n + group.branchLength(branches)\n    }, 0)\n  }\n\n  /**\n   * Find the position in the local document of a group that **is already** in\n   * this `ConflictGroup`. This is named `insertPos` because it is used to find\n   * the insertion position of a new group, but the naming is a bit confusing.\n   * @param br - The branch on which to determine the position.\n   * @param at - The LogootNodeGroup to determine the position of.\n   * @returns The position of `at`.\n   * @throws {FatalError} Will throw if `after` is not in this CG.\n   */\n  insertPos(br: BranchKey, at: LogootNodeGroup): number {\n    // First, compute the offset for all of the previous branches (ex, A and B)\n    // AAAAAAABBBBccccccdddddeeee\n    let offset =\n      this.known_position +\n      this.branchLength(\n        this.branch_order.slice(0, this.branch_order.indexOf(br) + (at ? 0 : 1))\n      )\n\n    if (!at) {\n      return offset\n    }\n\n    // Sum up all of the prior groups on our branch\n    for (let i = 0; i < this.groups.length; i++) {\n      // Once we've found our group, bail out\n      if (this.groups[i] === at) {\n        return offset\n      }\n      offset += this.groups[i].branchLength([br])\n    }\n    throw new FatalError(\n      'Tried to insert after a LogootNodeGroup that is not in this conflict group'\n    )\n  }\n\n  /**\n   * Get the nodes to the left and right of `start`. If there is already a\n   * `LogootNodeGroup` with the same position, behavior is undefined.\n   * @param start - The position for which to find neighbors of.\n   * @returns An object containing `left` and `right` `LogootNodeGroup`s, as\n   * well as a `pos` number, which is the position of `right` in `this.groups`.\n   */\n  getNeighbors({\n    start\n  }: LogootNodeGroup): {\n    left: LogootNodeGroup\n    right: LogootNodeGroup\n    pos: number\n  } {\n    let left\n    for (let i = 0; i < this.groups.length; i++) {\n      if (this.groups[i].start.cmp(start) <= 0) {\n        left = this.groups[i]\n      }\n      if (this.groups[i].start.cmp(start) > 0) {\n        return { left, right: this.groups[i], pos: i }\n      }\n    }\n    return { left, right: undefined, pos: this.groups.length }\n  }\n\n  /**\n   * Adds a group with only one branch to this CG and returns its position.\n   * @param group - The group to add.\n   * @returns The position in the local document of the insertion.\n   * @throws {TypeError} If the group has more than one branch or if the group's\n   * `ConflictGroup` is not set to `this`. Set `group.group` to this before\n   * calling to avoid this error.\n   */\n  insertSingleBranchGroup(group: LogootNodeGroup): number {\n    if (group.n_branches !== 1) {\n      throw new TypeError('Passed group with no or more than one branch')\n    }\n    if (group.group !== this) {\n      throw new TypeError('Conflict group not assigned to node group')\n    }\n\n    const br = group.branches[0]\n    if (!this.branch_order.includes(br)) {\n      this.branch_order.push(br)\n    }\n\n    const { right, pos } = this.getNeighbors(group)\n\n    const known_position = this.insertPos(br, right)\n    this.groups.splice(pos, 0, group)\n    return known_position\n  }\n\n  toString(): string {\n    let str = `Conflict @ ${this.known_position} (`\n    str += this.branch_order.map((br) => br.toString()).join(' ')\n    str += `) {`\n    str += this.groups.map((gr) => {\n      return (\n        '\\n  ' +\n        gr\n          .toString()\n          .split('\\n')\n          .join('\\n  ')\n      )\n    })\n    str += '\\n}'\n    return str\n  }\n}\n\ntype LogootNode = { type: NodeType; rclk: LogootInt }\n/**\n * A group of nodes that are all on different branches and have different vector\n * clock values, but share the same **Logoot** start, end, and length.\n */\nclass LogootNodeGroup {\n  length = 0\n  start: LogootPosition = new LogootPosition()\n  group: ConflictGroup\n  /**\n   * The `LogootNode`s in this group. Despite what TypeScript thinks, they key\n   * is **not** a string. It is a BranchKey. Problem is, TS doesn't support\n   * using symbols to index a type, which will hopefully fixed when\n   * [TypeScript PR #26797](https://github.com/microsoft/TypeScript/pull/26797) lands.\n   * In the mean time, using `as` to turn the BranchKey into a string is used as\n   * a hacky workaround.\n   */\n  nodes: { [key: string]: LogootNode } = {}\n\n  constructor(old?: LogootNodeGroup) {\n    if (old) {\n      Object.assign(this, {\n        length: old.length,\n        start: old.start.copy(),\n        group: old.group\n      })\n      old.eachNode(({ type, rclk }, k) => {\n        this.br(k, { type, rclk: new LogootInt(rclk) })\n      })\n    }\n  }\n\n  /**\n   * Gets the length of all `DATA` nodes.\n   */\n  get ldoc_length(): number {\n    // For some reason, TS thinks that this will produce a BranchKey. Obviously,\n    // it doesn't, so I have to do the awkward \"as unknown as number\" cast :(\n    return (this.branches.reduce((n: number, br: number) => {\n      return this.br(br).type === NodeType.DATA ? n + this.length : n\n    }, 0) as unknown) as number\n  }\n\n  /**\n   * Gets the length of all `DATA` nodes on `branches`.\n   * @param branches - The branches to search.\n   * @returns The length of all `DATA` nodes\n   */\n  branchLength(branches: BranchKey[]): number {\n    return (this.branches\n      .filter((k) => branches.includes(k))\n      .reduce((n: number, br: number) => {\n        return this.br(br).type === NodeType.DATA ? n + this.length : n\n      }, 0) as unknown) as number\n  }\n\n  /**\n   * The end of the node. Note that technically there is not an atom at this\n   * position, so it's fair game to have another node placed at this position.\n   */\n  get end(): LogootPosition {\n    return this.start.offsetLowest(this.length)\n  }\n\n  get branches(): BranchKey[] {\n    return allKeys(this.nodes)\n  }\n  get n_branches(): number {\n    return this.branches.length\n  }\n  /**\n   * Returns true if there are multiple branches\n   */\n  get conflicted(): boolean {\n    return this.n_branches > 1\n    /* return ( // TODO: Fix\n      this.branches.filter((k) => {\n        return this.br(k).type !== NodeType.MERGE_INTO\n      }).length > 1\n    ) */\n  }\n\n  eachNode(cb: (n: LogootNode, k: BranchKey) => void): void {\n    this.branches.forEach((k) => {\n      cb(this.br(k), k)\n    })\n  }\n  mapNodes(\n    cb: (n: LogootNode, k: BranchKey) => LogootNode\n  ): {\n    [key: string]: LogootNode\n  } {\n    const rval: { [key: string]: LogootNode } = {}\n    this.branches.forEach((k) => {\n      rval[(k as unknown) as string] = cb(this.br(k), k)\n    })\n    return rval\n  }\n\n  /**\n   * This is a method to access and (possibly) assign a `LogootNode` to the\n   * particular branch. This is a thing because TypeScript does not yet support\n   * using symbols as keys and I don't feel like typing\n   * `(key as unknown) as string` a billion times. See\n   * [TypeScript PR #26797](https://github.com/microsoft/TypeScript/pull/26797).\n   */\n  br(key: BranchKey, node?: LogootNode): LogootNode {\n    if (node) {\n      this.nodes[(key as unknown) as string] = node\n    }\n    return this.nodes[(key as unknown) as string]\n  }\n  delBr(key: BranchKey): void {\n    delete this.nodes[(key as unknown) as string]\n  }\n\n  /**\n   * Split this LogootNodeGroup around a position `pos` units after the current\n   * start on the lowest level.\n   * @param pos - The location of where to split this group.\n   * @returns A new LogootNodeGroup. This is spliced into this conflict group,\n   * so no cleanup is necessary after this is run.\n   */\n  splitAround(pos: number): LogootNodeGroup {\n    const newgroup = new LogootNodeGroup(this)\n    newgroup.start = this.start.offsetLowest(pos)\n    newgroup.length = this.length - pos\n\n    // Ensure that we're in the right order in the ConflictGroup\n    const groups = newgroup.group.groups\n    groups.splice(groups.indexOf(this) + 1, 0, newgroup)\n\n    this.length = pos\n    return newgroup\n  }\n\n  toString(): string {\n    let str = `Group ${this.start.toString()} + ${this.length} {`\n    str += this.branches.map((k) => {\n      const br = this.br(k)\n      return `\\n  ${String(k)}: ${nt_string[br.type]} @ ${br.rclk.toString()}`\n    })\n    str += '\\n}'\n    return str\n  }\n}\n\nexport {\n  LogootInt,\n  LogootPosition,\n  NodeType,\n  ConflictGroup,\n  LogootNodeGroup,\n  BranchKey\n}\n","/**\n * @file Various utilities that don't belong anywhere else.\n * @author Nathan Pennie <kb1rd@kb1rd.net>\n */\n/** */\n\nimport {\n  CompareResult,\n  CompareFunction,\n  DualCompareFunction,\n  Comparable\n} from './compare'\n\n/**\n * Like the built-in map function, but it replaces the element with an arbitrary\n * number of elements, making it a combination of map, push, and filter.\n * @template T - The type of the array elements.\n * @param array - The array to map. It will be modified.\n * @param fn - The element mapper function. It takes the current element as an\n * argument and returns the element(s) take its place.\n * @return The same array that was passed as an argument.\n */\nfunction arraymap<T>(array: T[], fn: (el: T) => T[]): T[] {\n  for (let i = 0; i < array.length; ) {\n    const newarray = fn(array[i])\n    array.splice(i, 1, ...newarray)\n    i += newarray.length ? newarray.length : 1\n  }\n  return array\n}\n\n/**\n * A class created with a variable `fatal` added and set to true. This is used\n * for ensuring that a client knows to shut down a document if an error has\n * indicated that the document is corrupt.\n */\nclass FatalError extends Error {\n  fatal = true\n}\n\n/**\n * Designed to emulate pointers to members of an object. This is useful inside\n * the B-trees. This should not be used like a C pointer: If the value in the\n * destination object changes, so does the value reported by this object.\n * @template T - The container object type.\n * @template K - The key inside the object.\n */\nclass MemberPtr<T, K extends keyof T> {\n  private obj: T\n  private key: K\n  /**\n   * @param obj - The object with the member to reference.\n   * @param key - The key of the reference inside the object.\n   */\n  constructor(obj: T, key: K) {\n    this.obj = obj\n    this.key = key\n  }\n  /**\n   * The value of the 'pointer.'\n   */\n  get value(): T[K] {\n    return this.obj[this.key]\n  }\n  set value(val: T[K]) {\n    this.obj[this.key] = val\n  }\n}\n\nfunction allKeys<T, K extends keyof T>(obj: T): K[] {\n  return (Object.keys(obj) as K[]).concat(\n    Object.getOwnPropertySymbols(obj) as K[]\n  )\n}\n\nfunction allValues<T, V extends T[keyof T]>(obj: T): V[] {\n  return allKeys(obj).map((k) => obj[k]) as V[]\n}\n\nconst BreakException = {}\nfunction catchBreak(fn: () => void): void {\n  try {\n    fn()\n  } catch (e) {\n    if (e !== BreakException) {\n      throw e\n    }\n  }\n}\n\nexport {\n  arraymap,\n  FatalError,\n  CompareResult,\n  CompareFunction,\n  DualCompareFunction,\n  Comparable,\n  MemberPtr,\n  allKeys,\n  allValues,\n  BreakException,\n  catchBreak\n}\n"],"sourceRoot":""}